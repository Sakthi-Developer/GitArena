const c=[{id:"intro-commit",title:"Your First Commit",description:"Learn the basics of creating commits in Git.",difficulty:"beginner",category:"Basics",setupCommands:[],goal:'Create two new commits on the main branch. Use `git commit -m "message"` to create each commit.',hints:['Type: git commit -m "Add feature"','Then commit again: git commit -m "Update feature"'],validator:{expectedBranches:{main:null},expectedHead:"main",minCommits:3}},{id:"branching-out",title:"Branching Out",description:"Create a new branch and make commits on it.",difficulty:"beginner",category:"Branches",setupCommands:['git commit -m "Setup commit"'],goal:'Create a branch called "feature" and make one commit on it.',hints:["First: git branch feature","Then: git checkout feature",'Finally: git commit -m "Feature work"'],validator:{expectedBranches:{main:null,feature:null},expectedHead:"feature",minCommits:3}},{id:"merge-basics",title:"Merge Mastery",description:"Merge a feature branch back into main.",difficulty:"intermediate",category:"Merging",setupCommands:['git commit -m "Base work"',"git branch feature","git checkout feature",'git commit -m "Feature A"','git commit -m "Feature B"'],goal:'Switch to main and merge the "feature" branch into it.',hints:["Switch: git checkout main","Merge: git merge feature"],validator:{expectedBranches:{main:null,feature:null},expectedHead:"main",minCommits:4,customCheck:"merge-contains-feature"}},{id:"rebase-flow",title:"Rebase Rhythm",description:"Rebase your feature branch onto an updated main.",difficulty:"advanced",category:"Rebasing",setupCommands:['git commit -m "Main update 1"',"git branch feature","git checkout feature",'git commit -m "Feature work"',"git checkout main",'git commit -m "Main update 2"',"git checkout feature"],goal:`Rebase the "feature" branch onto main so your feature commits come after main's latest.`,hints:["While on feature: git rebase main"],validator:{expectedBranches:{main:null,feature:null},expectedHead:"feature",minCommits:4,customCheck:"rebase-linear"}}];async function d(n,a,r,m){const e=n.validator;if(e.expectedHead&&r!==e.expectedHead)return{passed:!1,message:`Expected HEAD on branch "${e.expectedHead}", but you're on "${r}".`};for(const t of Object.keys(e.expectedBranches))if(!m.includes(t))return{passed:!1,message:`Expected branch "${t}" to exist.`};if(e.minCommits&&a.length<e.minCommits)return{passed:!1,message:`Need at least ${e.minCommits} commits, found ${a.length}.`};if(e.expectedMessages){const t=a.map(i=>i.message.toLowerCase());for(const i of e.expectedMessages)if(!t.some(s=>s.includes(i.toLowerCase())))return{passed:!1,message:`Missing expected commit message containing "${i}".`}}if(e.customCheck){const t=u(e.customCheck,a);if(!t.passed)return t}return{passed:!0,message:"Level completed!"}}function u(n,a,r,m){switch(n){case"merge-contains-feature":{const e=a.find(t=>t.isHead);return e?e.parents.length<2?{passed:!1,message:"HEAD should be a merge commit with two parents. Did you merge the feature branch?"}:{passed:!0,message:"Merge verified!"}:{passed:!1,message:"No HEAD commit found."}}case"rebase-linear":{const e=a.find(s=>s.isHead);if(!e)return{passed:!1,message:"No HEAD commit found."};let t=e,i=0;for(;t&&i<20;){if(t.parents.length>1)return{passed:!1,message:"History is not linear. Did you rebase (not merge)?"};const s=a.find(o=>o.oid===t.parents[0]);if(!s)break;t=s,i++}return{passed:!0,message:"Clean linear history!"}}default:return{passed:!0,message:""}}}function g(n){return c.find(a=>a.id===n)}export{g,c as l,d as v};
