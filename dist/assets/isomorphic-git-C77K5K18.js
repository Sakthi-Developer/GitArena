var Cc=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function El(b){return b&&b.__esModule&&Object.prototype.hasOwnProperty.call(b,"default")?b.default:b}var Et={},Dn,os;function vu(){if(os)return Dn;os=1;var b=function(S){if(S=S||{},this.Promise=S.Promise||Promise,this.queues=Object.create(null),this.domainReentrant=S.domainReentrant||!1,this.domainReentrant){if(typeof process>"u"||typeof process.domain>"u")throw new Error("Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, use a NodeJS version that still implements Domain, or install a browser polyfill.");this.domains=Object.create(null)}this.timeout=S.timeout||b.DEFAULT_TIMEOUT,this.maxOccupationTime=S.maxOccupationTime||b.DEFAULT_MAX_OCCUPATION_TIME,this.maxExecutionTime=S.maxExecutionTime||b.DEFAULT_MAX_EXECUTION_TIME,S.maxPending===1/0||Number.isInteger(S.maxPending)&&S.maxPending>=0?this.maxPending=S.maxPending:this.maxPending=b.DEFAULT_MAX_PENDING};return b.DEFAULT_TIMEOUT=0,b.DEFAULT_MAX_OCCUPATION_TIME=0,b.DEFAULT_MAX_EXECUTION_TIME=0,b.DEFAULT_MAX_PENDING=1e3,b.prototype.acquire=function(S,j,I,N){if(Array.isArray(S))return this._acquireBatch(S,j,I,N);if(typeof j!="function")throw new Error("You must pass a function to execute");var T=null,R=null,m=null;typeof I!="function"&&(N=I,I=null,m=new this.Promise(function(G,st){T=G,R=st})),N=N||{};var _=!1,D=null,C=null,A=null,U=this,L=function(G,st,ht){C&&(clearTimeout(C),C=null),A&&(clearTimeout(A),A=null),G&&(U.queues[S]&&U.queues[S].length===0&&delete U.queues[S],U.domainReentrant&&delete U.domains[S]),_||(m?st?R(st):T(ht):typeof I=="function"&&I(st,ht),_=!0),G&&U.queues[S]&&U.queues[S].length>0&&U.queues[S].shift()()},et=function(G){if(_)return L(G);D&&(clearTimeout(D),D=null),U.domainReentrant&&G&&(U.domains[S]=process.domain);var st=N.maxExecutionTime||U.maxExecutionTime;if(st&&(A=setTimeout(function(){U.queues[S]&&L(G,new Error("Maximum execution time is exceeded "+S))},st)),j.length===1){var ht=!1;try{j(function(pt,V){ht||(ht=!0,L(G,pt,V))})}catch(pt){ht||(ht=!0,L(G,pt))}}else U._promiseTry(function(){return j()}).then(function(pt){L(G,void 0,pt)},function(pt){L(G,pt)})};U.domainReentrant&&process.domain&&(et=process.domain.bind(et));var lt=N.maxPending||U.maxPending;if(!U.queues[S])U.queues[S]=[],et(!0);else if(U.domainReentrant&&process.domain&&process.domain===U.domains[S])et(!1);else if(U.queues[S].length>=lt)L(!1,new Error("Too many pending tasks in queue "+S));else{var Z=function(){et(!0)};N.skipQueue?U.queues[S].unshift(Z):U.queues[S].push(Z);var X=N.timeout||U.timeout;X&&(D=setTimeout(function(){D=null,L(!1,new Error("async-lock timed out in queue "+S))},X))}var Q=N.maxOccupationTime||U.maxOccupationTime;if(Q&&(C=setTimeout(function(){U.queues[S]&&L(!1,new Error("Maximum occupation time is exceeded in queue "+S))},Q)),m)return m},b.prototype._acquireBatch=function(S,j,I,N){typeof I!="function"&&(N=I,I=null);var T=this,R=function(_,D){return function(C){T.acquire(_,D,C,N)}},m=S.reduceRight(function(_,D){return R(D,_)},j);if(typeof I=="function")m(I);else return new this.Promise(function(_,D){m.length===1?m(function(C,A){C?D(C):_(A)}):_(m())})},b.prototype.isBusy=function(S){return S?!!this.queues[S]:Object.keys(this.queues).length>0},b.prototype._promiseTry=function(S){try{return this.Promise.resolve(S())}catch(j){return this.Promise.reject(j)}},Dn=b,Dn}var Un,ss;function bu(){return ss||(ss=1,Un=vu()),Un}var ln={exports:{}},cs;function xu(){return cs||(cs=1,typeof Object.create=="function"?ln.exports=function(S,j){j&&(S.super_=j,S.prototype=Object.create(j.prototype,{constructor:{value:S,enumerable:!1,writable:!0,configurable:!0}}))}:ln.exports=function(S,j){if(j){S.super_=j;var I=function(){};I.prototype=j.prototype,S.prototype=new I,S.prototype.constructor=S}}),ln.exports}var hn={exports:{}},Nn={},Xr={},fs;function Eu(){if(fs)return Xr;fs=1,Xr.byteLength=m,Xr.toByteArray=D,Xr.fromByteArray=U;for(var b=[],S=[],j=typeof Uint8Array<"u"?Uint8Array:Array,I="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",N=0,T=I.length;N<T;++N)b[N]=I[N],S[I.charCodeAt(N)]=N;S[45]=62,S[95]=63;function R(L){var et=L.length;if(et%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var lt=L.indexOf("=");lt===-1&&(lt=et);var Z=lt===et?0:4-lt%4;return[lt,Z]}function m(L){var et=R(L),lt=et[0],Z=et[1];return(lt+Z)*3/4-Z}function _(L,et,lt){return(et+lt)*3/4-lt}function D(L){var et,lt=R(L),Z=lt[0],X=lt[1],Q=new j(_(L,Z,X)),G=0,st=X>0?Z-4:Z,ht;for(ht=0;ht<st;ht+=4)et=S[L.charCodeAt(ht)]<<18|S[L.charCodeAt(ht+1)]<<12|S[L.charCodeAt(ht+2)]<<6|S[L.charCodeAt(ht+3)],Q[G++]=et>>16&255,Q[G++]=et>>8&255,Q[G++]=et&255;return X===2&&(et=S[L.charCodeAt(ht)]<<2|S[L.charCodeAt(ht+1)]>>4,Q[G++]=et&255),X===1&&(et=S[L.charCodeAt(ht)]<<10|S[L.charCodeAt(ht+1)]<<4|S[L.charCodeAt(ht+2)]>>2,Q[G++]=et>>8&255,Q[G++]=et&255),Q}function C(L){return b[L>>18&63]+b[L>>12&63]+b[L>>6&63]+b[L&63]}function A(L,et,lt){for(var Z,X=[],Q=et;Q<lt;Q+=3)Z=(L[Q]<<16&16711680)+(L[Q+1]<<8&65280)+(L[Q+2]&255),X.push(C(Z));return X.join("")}function U(L){for(var et,lt=L.length,Z=lt%3,X=[],Q=16383,G=0,st=lt-Z;G<st;G+=Q)X.push(A(L,G,G+Q>st?st:G+Q));return Z===1?(et=L[lt-1],X.push(b[et>>2]+b[et<<4&63]+"==")):Z===2&&(et=(L[lt-2]<<8)+L[lt-1],X.push(b[et>>10]+b[et>>4&63]+b[et<<2&63]+"=")),X.join("")}return Xr}var dn={};/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */var us;function Su(){return us||(us=1,dn.read=function(b,S,j,I,N){var T,R,m=N*8-I-1,_=(1<<m)-1,D=_>>1,C=-7,A=j?N-1:0,U=j?-1:1,L=b[S+A];for(A+=U,T=L&(1<<-C)-1,L>>=-C,C+=m;C>0;T=T*256+b[S+A],A+=U,C-=8);for(R=T&(1<<-C)-1,T>>=-C,C+=I;C>0;R=R*256+b[S+A],A+=U,C-=8);if(T===0)T=1-D;else{if(T===_)return R?NaN:(L?-1:1)*(1/0);R=R+Math.pow(2,I),T=T-D}return(L?-1:1)*R*Math.pow(2,T-I)},dn.write=function(b,S,j,I,N,T){var R,m,_,D=T*8-N-1,C=(1<<D)-1,A=C>>1,U=N===23?Math.pow(2,-24)-Math.pow(2,-77):0,L=I?0:T-1,et=I?1:-1,lt=S<0||S===0&&1/S<0?1:0;for(S=Math.abs(S),isNaN(S)||S===1/0?(m=isNaN(S)?1:0,R=C):(R=Math.floor(Math.log(S)/Math.LN2),S*(_=Math.pow(2,-R))<1&&(R--,_*=2),R+A>=1?S+=U/_:S+=U*Math.pow(2,1-A),S*_>=2&&(R++,_/=2),R+A>=C?(m=0,R=C):R+A>=1?(m=(S*_-1)*Math.pow(2,N),R=R+A):(m=S*Math.pow(2,A-1)*Math.pow(2,N),R=0));N>=8;b[j+L]=m&255,L+=et,m/=256,N-=8);for(R=R<<N|m,D+=N;D>0;b[j+L]=R&255,L+=et,R/=256,D-=8);b[j+L-et]|=lt*128}),dn}/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */var ls;function Au(){return ls||(ls=1,(function(b){const S=Eu(),j=Su(),I=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;b.Buffer=m,b.SlowBuffer=Q,b.INSPECT_MAX_BYTES=50;const N=2147483647;b.kMaxLength=N,m.TYPED_ARRAY_SUPPORT=T(),!m.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function T(){try{const w=new Uint8Array(1),s={foo:function(){return 42}};return Object.setPrototypeOf(s,Uint8Array.prototype),Object.setPrototypeOf(w,s),w.foo()===42}catch{return!1}}Object.defineProperty(m.prototype,"parent",{enumerable:!0,get:function(){if(m.isBuffer(this))return this.buffer}}),Object.defineProperty(m.prototype,"offset",{enumerable:!0,get:function(){if(m.isBuffer(this))return this.byteOffset}});function R(w){if(w>N)throw new RangeError('The value "'+w+'" is invalid for option "size"');const s=new Uint8Array(w);return Object.setPrototypeOf(s,m.prototype),s}function m(w,s,f){if(typeof w=="number"){if(typeof s=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return A(w)}return _(w,s,f)}m.poolSize=8192;function _(w,s,f){if(typeof w=="string")return U(w,s);if(ArrayBuffer.isView(w))return et(w);if(w==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof w);if(Jt(w,ArrayBuffer)||w&&Jt(w.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(Jt(w,SharedArrayBuffer)||w&&Jt(w.buffer,SharedArrayBuffer)))return lt(w,s,f);if(typeof w=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const E=w.valueOf&&w.valueOf();if(E!=null&&E!==w)return m.from(E,s,f);const u=Z(w);if(u)return u;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof w[Symbol.toPrimitive]=="function")return m.from(w[Symbol.toPrimitive]("string"),s,f);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof w)}m.from=function(w,s,f){return _(w,s,f)},Object.setPrototypeOf(m.prototype,Uint8Array.prototype),Object.setPrototypeOf(m,Uint8Array);function D(w){if(typeof w!="number")throw new TypeError('"size" argument must be of type number');if(w<0)throw new RangeError('The value "'+w+'" is invalid for option "size"')}function C(w,s,f){return D(w),w<=0?R(w):s!==void 0?typeof f=="string"?R(w).fill(s,f):R(w).fill(s):R(w)}m.alloc=function(w,s,f){return C(w,s,f)};function A(w){return D(w),R(w<0?0:X(w)|0)}m.allocUnsafe=function(w){return A(w)},m.allocUnsafeSlow=function(w){return A(w)};function U(w,s){if((typeof s!="string"||s==="")&&(s="utf8"),!m.isEncoding(s))throw new TypeError("Unknown encoding: "+s);const f=G(w,s)|0;let E=R(f);const u=E.write(w,s);return u!==f&&(E=E.slice(0,u)),E}function L(w){const s=w.length<0?0:X(w.length)|0,f=R(s);for(let E=0;E<s;E+=1)f[E]=w[E]&255;return f}function et(w){if(Jt(w,Uint8Array)){const s=new Uint8Array(w);return lt(s.buffer,s.byteOffset,s.byteLength)}return L(w)}function lt(w,s,f){if(s<0||w.byteLength<s)throw new RangeError('"offset" is outside of buffer bounds');if(w.byteLength<s+(f||0))throw new RangeError('"length" is outside of buffer bounds');let E;return s===void 0&&f===void 0?E=new Uint8Array(w):f===void 0?E=new Uint8Array(w,s):E=new Uint8Array(w,s,f),Object.setPrototypeOf(E,m.prototype),E}function Z(w){if(m.isBuffer(w)){const s=X(w.length)|0,f=R(s);return f.length===0||w.copy(f,0,0,s),f}if(w.length!==void 0)return typeof w.length!="number"||xe(w.length)?R(0):L(w);if(w.type==="Buffer"&&Array.isArray(w.data))return L(w.data)}function X(w){if(w>=N)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+N.toString(16)+" bytes");return w|0}function Q(w){return+w!=w&&(w=0),m.alloc(+w)}m.isBuffer=function(s){return s!=null&&s._isBuffer===!0&&s!==m.prototype},m.compare=function(s,f){if(Jt(s,Uint8Array)&&(s=m.from(s,s.offset,s.byteLength)),Jt(f,Uint8Array)&&(f=m.from(f,f.offset,f.byteLength)),!m.isBuffer(s)||!m.isBuffer(f))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(s===f)return 0;let E=s.length,u=f.length;for(let k=0,F=Math.min(E,u);k<F;++k)if(s[k]!==f[k]){E=s[k],u=f[k];break}return E<u?-1:u<E?1:0},m.isEncoding=function(s){switch(String(s).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},m.concat=function(s,f){if(!Array.isArray(s))throw new TypeError('"list" argument must be an Array of Buffers');if(s.length===0)return m.alloc(0);let E;if(f===void 0)for(f=0,E=0;E<s.length;++E)f+=s[E].length;const u=m.allocUnsafe(f);let k=0;for(E=0;E<s.length;++E){let F=s[E];if(Jt(F,Uint8Array))k+F.length>u.length?(m.isBuffer(F)||(F=m.from(F)),F.copy(u,k)):Uint8Array.prototype.set.call(u,F,k);else if(m.isBuffer(F))F.copy(u,k);else throw new TypeError('"list" argument must be an Array of Buffers');k+=F.length}return u};function G(w,s){if(m.isBuffer(w))return w.length;if(ArrayBuffer.isView(w)||Jt(w,ArrayBuffer))return w.byteLength;if(typeof w!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof w);const f=w.length,E=arguments.length>2&&arguments[2]===!0;if(!E&&f===0)return 0;let u=!1;for(;;)switch(s){case"ascii":case"latin1":case"binary":return f;case"utf8":case"utf-8":return W(w).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return f*2;case"hex":return f>>>1;case"base64":return be(w).length;default:if(u)return E?-1:W(w).length;s=(""+s).toLowerCase(),u=!0}}m.byteLength=G;function st(w,s,f){let E=!1;if((s===void 0||s<0)&&(s=0),s>this.length||((f===void 0||f>this.length)&&(f=this.length),f<=0)||(f>>>=0,s>>>=0,f<=s))return"";for(w||(w="utf8");;)switch(w){case"hex":return ft(this,s,f);case"utf8":case"utf-8":return kt(this,s,f);case"ascii":return it(this,s,f);case"latin1":case"binary":return ct(this,s,f);case"base64":return mt(this,s,f);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Ut(this,s,f);default:if(E)throw new TypeError("Unknown encoding: "+w);w=(w+"").toLowerCase(),E=!0}}m.prototype._isBuffer=!0;function ht(w,s,f){const E=w[s];w[s]=w[f],w[f]=E}m.prototype.swap16=function(){const s=this.length;if(s%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let f=0;f<s;f+=2)ht(this,f,f+1);return this},m.prototype.swap32=function(){const s=this.length;if(s%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let f=0;f<s;f+=4)ht(this,f,f+3),ht(this,f+1,f+2);return this},m.prototype.swap64=function(){const s=this.length;if(s%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let f=0;f<s;f+=8)ht(this,f,f+7),ht(this,f+1,f+6),ht(this,f+2,f+5),ht(this,f+3,f+4);return this},m.prototype.toString=function(){const s=this.length;return s===0?"":arguments.length===0?kt(this,0,s):st.apply(this,arguments)},m.prototype.toLocaleString=m.prototype.toString,m.prototype.equals=function(s){if(!m.isBuffer(s))throw new TypeError("Argument must be a Buffer");return this===s?!0:m.compare(this,s)===0},m.prototype.inspect=function(){let s="";const f=b.INSPECT_MAX_BYTES;return s=this.toString("hex",0,f).replace(/(.{2})/g,"$1 ").trim(),this.length>f&&(s+=" ... "),"<Buffer "+s+">"},I&&(m.prototype[I]=m.prototype.inspect),m.prototype.compare=function(s,f,E,u,k){if(Jt(s,Uint8Array)&&(s=m.from(s,s.offset,s.byteLength)),!m.isBuffer(s))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof s);if(f===void 0&&(f=0),E===void 0&&(E=s?s.length:0),u===void 0&&(u=0),k===void 0&&(k=this.length),f<0||E>s.length||u<0||k>this.length)throw new RangeError("out of range index");if(u>=k&&f>=E)return 0;if(u>=k)return-1;if(f>=E)return 1;if(f>>>=0,E>>>=0,u>>>=0,k>>>=0,this===s)return 0;let F=k-u,ut=E-f;const O=Math.min(F,ut),z=this.slice(u,k),h=s.slice(f,E);for(let rt=0;rt<O;++rt)if(z[rt]!==h[rt]){F=z[rt],ut=h[rt];break}return F<ut?-1:ut<F?1:0};function pt(w,s,f,E,u){if(w.length===0)return-1;if(typeof f=="string"?(E=f,f=0):f>2147483647?f=2147483647:f<-2147483648&&(f=-2147483648),f=+f,xe(f)&&(f=u?0:w.length-1),f<0&&(f=w.length+f),f>=w.length){if(u)return-1;f=w.length-1}else if(f<0)if(u)f=0;else return-1;if(typeof s=="string"&&(s=m.from(s,E)),m.isBuffer(s))return s.length===0?-1:V(w,s,f,E,u);if(typeof s=="number")return s=s&255,typeof Uint8Array.prototype.indexOf=="function"?u?Uint8Array.prototype.indexOf.call(w,s,f):Uint8Array.prototype.lastIndexOf.call(w,s,f):V(w,[s],f,E,u);throw new TypeError("val must be string, number or Buffer")}function V(w,s,f,E,u){let k=1,F=w.length,ut=s.length;if(E!==void 0&&(E=String(E).toLowerCase(),E==="ucs2"||E==="ucs-2"||E==="utf16le"||E==="utf-16le")){if(w.length<2||s.length<2)return-1;k=2,F/=2,ut/=2,f/=2}function O(h,rt){return k===1?h[rt]:h.readUInt16BE(rt*k)}let z;if(u){let h=-1;for(z=f;z<F;z++)if(O(w,z)===O(s,h===-1?0:z-h)){if(h===-1&&(h=z),z-h+1===ut)return h*k}else h!==-1&&(z-=z-h),h=-1}else for(f+ut>F&&(f=F-ut),z=f;z>=0;z--){let h=!0;for(let rt=0;rt<ut;rt++)if(O(w,z+rt)!==O(s,rt)){h=!1;break}if(h)return z}return-1}m.prototype.includes=function(s,f,E){return this.indexOf(s,f,E)!==-1},m.prototype.indexOf=function(s,f,E){return pt(this,s,f,E,!0)},m.prototype.lastIndexOf=function(s,f,E){return pt(this,s,f,E,!1)};function K(w,s,f,E){f=Number(f)||0;const u=w.length-f;E?(E=Number(E),E>u&&(E=u)):E=u;const k=s.length;E>k/2&&(E=k/2);let F;for(F=0;F<E;++F){const ut=parseInt(s.substr(F*2,2),16);if(xe(ut))return F;w[f+F]=ut}return F}function gt(w,s,f,E){return ae(W(s,w.length-f),w,f,E)}function nt(w,s,f,E){return ae(Mt(s),w,f,E)}function _t(w,s,f,E){return ae(be(s),w,f,E)}function dt(w,s,f,E){return ae(ie(s,w.length-f),w,f,E)}m.prototype.write=function(s,f,E,u){if(f===void 0)u="utf8",E=this.length,f=0;else if(E===void 0&&typeof f=="string")u=f,E=this.length,f=0;else if(isFinite(f))f=f>>>0,isFinite(E)?(E=E>>>0,u===void 0&&(u="utf8")):(u=E,E=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const k=this.length-f;if((E===void 0||E>k)&&(E=k),s.length>0&&(E<0||f<0)||f>this.length)throw new RangeError("Attempt to write outside buffer bounds");u||(u="utf8");let F=!1;for(;;)switch(u){case"hex":return K(this,s,f,E);case"utf8":case"utf-8":return gt(this,s,f,E);case"ascii":case"latin1":case"binary":return nt(this,s,f,E);case"base64":return _t(this,s,f,E);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return dt(this,s,f,E);default:if(F)throw new TypeError("Unknown encoding: "+u);u=(""+u).toLowerCase(),F=!0}},m.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function mt(w,s,f){return s===0&&f===w.length?S.fromByteArray(w):S.fromByteArray(w.slice(s,f))}function kt(w,s,f){f=Math.min(w.length,f);const E=[];let u=s;for(;u<f;){const k=w[u];let F=null,ut=k>239?4:k>223?3:k>191?2:1;if(u+ut<=f){let O,z,h,rt;switch(ut){case 1:k<128&&(F=k);break;case 2:O=w[u+1],(O&192)===128&&(rt=(k&31)<<6|O&63,rt>127&&(F=rt));break;case 3:O=w[u+1],z=w[u+2],(O&192)===128&&(z&192)===128&&(rt=(k&15)<<12|(O&63)<<6|z&63,rt>2047&&(rt<55296||rt>57343)&&(F=rt));break;case 4:O=w[u+1],z=w[u+2],h=w[u+3],(O&192)===128&&(z&192)===128&&(h&192)===128&&(rt=(k&15)<<18|(O&63)<<12|(z&63)<<6|h&63,rt>65535&&rt<1114112&&(F=rt))}}F===null?(F=65533,ut=1):F>65535&&(F-=65536,E.push(F>>>10&1023|55296),F=56320|F&1023),E.push(F),u+=ut}return re(E)}const Wt=4096;function re(w){const s=w.length;if(s<=Wt)return String.fromCharCode.apply(String,w);let f="",E=0;for(;E<s;)f+=String.fromCharCode.apply(String,w.slice(E,E+=Wt));return f}function it(w,s,f){let E="";f=Math.min(w.length,f);for(let u=s;u<f;++u)E+=String.fromCharCode(w[u]&127);return E}function ct(w,s,f){let E="";f=Math.min(w.length,f);for(let u=s;u<f;++u)E+=String.fromCharCode(w[u]);return E}function ft(w,s,f){const E=w.length;(!s||s<0)&&(s=0),(!f||f<0||f>E)&&(f=E);let u="";for(let k=s;k<f;++k)u+=Ee[w[k]];return u}function Ut(w,s,f){const E=w.slice(s,f);let u="";for(let k=0;k<E.length-1;k+=2)u+=String.fromCharCode(E[k]+E[k+1]*256);return u}m.prototype.slice=function(s,f){const E=this.length;s=~~s,f=f===void 0?E:~~f,s<0?(s+=E,s<0&&(s=0)):s>E&&(s=E),f<0?(f+=E,f<0&&(f=0)):f>E&&(f=E),f<s&&(f=s);const u=this.subarray(s,f);return Object.setPrototypeOf(u,m.prototype),u};function Rt(w,s,f){if(w%1!==0||w<0)throw new RangeError("offset is not uint");if(w+s>f)throw new RangeError("Trying to access beyond buffer length")}m.prototype.readUintLE=m.prototype.readUIntLE=function(s,f,E){s=s>>>0,f=f>>>0,E||Rt(s,f,this.length);let u=this[s],k=1,F=0;for(;++F<f&&(k*=256);)u+=this[s+F]*k;return u},m.prototype.readUintBE=m.prototype.readUIntBE=function(s,f,E){s=s>>>0,f=f>>>0,E||Rt(s,f,this.length);let u=this[s+--f],k=1;for(;f>0&&(k*=256);)u+=this[s+--f]*k;return u},m.prototype.readUint8=m.prototype.readUInt8=function(s,f){return s=s>>>0,f||Rt(s,1,this.length),this[s]},m.prototype.readUint16LE=m.prototype.readUInt16LE=function(s,f){return s=s>>>0,f||Rt(s,2,this.length),this[s]|this[s+1]<<8},m.prototype.readUint16BE=m.prototype.readUInt16BE=function(s,f){return s=s>>>0,f||Rt(s,2,this.length),this[s]<<8|this[s+1]},m.prototype.readUint32LE=m.prototype.readUInt32LE=function(s,f){return s=s>>>0,f||Rt(s,4,this.length),(this[s]|this[s+1]<<8|this[s+2]<<16)+this[s+3]*16777216},m.prototype.readUint32BE=m.prototype.readUInt32BE=function(s,f){return s=s>>>0,f||Rt(s,4,this.length),this[s]*16777216+(this[s+1]<<16|this[s+2]<<8|this[s+3])},m.prototype.readBigUInt64LE=he(function(s){s=s>>>0,zt(s,"offset");const f=this[s],E=this[s+7];(f===void 0||E===void 0)&&ne(s,this.length-8);const u=f+this[++s]*2**8+this[++s]*2**16+this[++s]*2**24,k=this[++s]+this[++s]*2**8+this[++s]*2**16+E*2**24;return BigInt(u)+(BigInt(k)<<BigInt(32))}),m.prototype.readBigUInt64BE=he(function(s){s=s>>>0,zt(s,"offset");const f=this[s],E=this[s+7];(f===void 0||E===void 0)&&ne(s,this.length-8);const u=f*2**24+this[++s]*2**16+this[++s]*2**8+this[++s],k=this[++s]*2**24+this[++s]*2**16+this[++s]*2**8+E;return(BigInt(u)<<BigInt(32))+BigInt(k)}),m.prototype.readIntLE=function(s,f,E){s=s>>>0,f=f>>>0,E||Rt(s,f,this.length);let u=this[s],k=1,F=0;for(;++F<f&&(k*=256);)u+=this[s+F]*k;return k*=128,u>=k&&(u-=Math.pow(2,8*f)),u},m.prototype.readIntBE=function(s,f,E){s=s>>>0,f=f>>>0,E||Rt(s,f,this.length);let u=f,k=1,F=this[s+--u];for(;u>0&&(k*=256);)F+=this[s+--u]*k;return k*=128,F>=k&&(F-=Math.pow(2,8*f)),F},m.prototype.readInt8=function(s,f){return s=s>>>0,f||Rt(s,1,this.length),this[s]&128?(255-this[s]+1)*-1:this[s]},m.prototype.readInt16LE=function(s,f){s=s>>>0,f||Rt(s,2,this.length);const E=this[s]|this[s+1]<<8;return E&32768?E|4294901760:E},m.prototype.readInt16BE=function(s,f){s=s>>>0,f||Rt(s,2,this.length);const E=this[s+1]|this[s]<<8;return E&32768?E|4294901760:E},m.prototype.readInt32LE=function(s,f){return s=s>>>0,f||Rt(s,4,this.length),this[s]|this[s+1]<<8|this[s+2]<<16|this[s+3]<<24},m.prototype.readInt32BE=function(s,f){return s=s>>>0,f||Rt(s,4,this.length),this[s]<<24|this[s+1]<<16|this[s+2]<<8|this[s+3]},m.prototype.readBigInt64LE=he(function(s){s=s>>>0,zt(s,"offset");const f=this[s],E=this[s+7];(f===void 0||E===void 0)&&ne(s,this.length-8);const u=this[s+4]+this[s+5]*2**8+this[s+6]*2**16+(E<<24);return(BigInt(u)<<BigInt(32))+BigInt(f+this[++s]*2**8+this[++s]*2**16+this[++s]*2**24)}),m.prototype.readBigInt64BE=he(function(s){s=s>>>0,zt(s,"offset");const f=this[s],E=this[s+7];(f===void 0||E===void 0)&&ne(s,this.length-8);const u=(f<<24)+this[++s]*2**16+this[++s]*2**8+this[++s];return(BigInt(u)<<BigInt(32))+BigInt(this[++s]*2**24+this[++s]*2**16+this[++s]*2**8+E)}),m.prototype.readFloatLE=function(s,f){return s=s>>>0,f||Rt(s,4,this.length),j.read(this,s,!0,23,4)},m.prototype.readFloatBE=function(s,f){return s=s>>>0,f||Rt(s,4,this.length),j.read(this,s,!1,23,4)},m.prototype.readDoubleLE=function(s,f){return s=s>>>0,f||Rt(s,8,this.length),j.read(this,s,!0,52,8)},m.prototype.readDoubleBE=function(s,f){return s=s>>>0,f||Rt(s,8,this.length),j.read(this,s,!1,52,8)};function Nt(w,s,f,E,u,k){if(!m.isBuffer(w))throw new TypeError('"buffer" argument must be a Buffer instance');if(s>u||s<k)throw new RangeError('"value" argument is out of bounds');if(f+E>w.length)throw new RangeError("Index out of range")}m.prototype.writeUintLE=m.prototype.writeUIntLE=function(s,f,E,u){if(s=+s,f=f>>>0,E=E>>>0,!u){const ut=Math.pow(2,8*E)-1;Nt(this,s,f,E,ut,0)}let k=1,F=0;for(this[f]=s&255;++F<E&&(k*=256);)this[f+F]=s/k&255;return f+E},m.prototype.writeUintBE=m.prototype.writeUIntBE=function(s,f,E,u){if(s=+s,f=f>>>0,E=E>>>0,!u){const ut=Math.pow(2,8*E)-1;Nt(this,s,f,E,ut,0)}let k=E-1,F=1;for(this[f+k]=s&255;--k>=0&&(F*=256);)this[f+k]=s/F&255;return f+E},m.prototype.writeUint8=m.prototype.writeUInt8=function(s,f,E){return s=+s,f=f>>>0,E||Nt(this,s,f,1,255,0),this[f]=s&255,f+1},m.prototype.writeUint16LE=m.prototype.writeUInt16LE=function(s,f,E){return s=+s,f=f>>>0,E||Nt(this,s,f,2,65535,0),this[f]=s&255,this[f+1]=s>>>8,f+2},m.prototype.writeUint16BE=m.prototype.writeUInt16BE=function(s,f,E){return s=+s,f=f>>>0,E||Nt(this,s,f,2,65535,0),this[f]=s>>>8,this[f+1]=s&255,f+2},m.prototype.writeUint32LE=m.prototype.writeUInt32LE=function(s,f,E){return s=+s,f=f>>>0,E||Nt(this,s,f,4,4294967295,0),this[f+3]=s>>>24,this[f+2]=s>>>16,this[f+1]=s>>>8,this[f]=s&255,f+4},m.prototype.writeUint32BE=m.prototype.writeUInt32BE=function(s,f,E){return s=+s,f=f>>>0,E||Nt(this,s,f,4,4294967295,0),this[f]=s>>>24,this[f+1]=s>>>16,this[f+2]=s>>>8,this[f+3]=s&255,f+4};function Zt(w,s,f,E,u){Pt(s,E,u,w,f,7);let k=Number(s&BigInt(4294967295));w[f++]=k,k=k>>8,w[f++]=k,k=k>>8,w[f++]=k,k=k>>8,w[f++]=k;let F=Number(s>>BigInt(32)&BigInt(4294967295));return w[f++]=F,F=F>>8,w[f++]=F,F=F>>8,w[f++]=F,F=F>>8,w[f++]=F,f}function fe(w,s,f,E,u){Pt(s,E,u,w,f,7);let k=Number(s&BigInt(4294967295));w[f+7]=k,k=k>>8,w[f+6]=k,k=k>>8,w[f+5]=k,k=k>>8,w[f+4]=k;let F=Number(s>>BigInt(32)&BigInt(4294967295));return w[f+3]=F,F=F>>8,w[f+2]=F,F=F>>8,w[f+1]=F,F=F>>8,w[f]=F,f+8}m.prototype.writeBigUInt64LE=he(function(s,f=0){return Zt(this,s,f,BigInt(0),BigInt("0xffffffffffffffff"))}),m.prototype.writeBigUInt64BE=he(function(s,f=0){return fe(this,s,f,BigInt(0),BigInt("0xffffffffffffffff"))}),m.prototype.writeIntLE=function(s,f,E,u){if(s=+s,f=f>>>0,!u){const O=Math.pow(2,8*E-1);Nt(this,s,f,E,O-1,-O)}let k=0,F=1,ut=0;for(this[f]=s&255;++k<E&&(F*=256);)s<0&&ut===0&&this[f+k-1]!==0&&(ut=1),this[f+k]=(s/F>>0)-ut&255;return f+E},m.prototype.writeIntBE=function(s,f,E,u){if(s=+s,f=f>>>0,!u){const O=Math.pow(2,8*E-1);Nt(this,s,f,E,O-1,-O)}let k=E-1,F=1,ut=0;for(this[f+k]=s&255;--k>=0&&(F*=256);)s<0&&ut===0&&this[f+k+1]!==0&&(ut=1),this[f+k]=(s/F>>0)-ut&255;return f+E},m.prototype.writeInt8=function(s,f,E){return s=+s,f=f>>>0,E||Nt(this,s,f,1,127,-128),s<0&&(s=255+s+1),this[f]=s&255,f+1},m.prototype.writeInt16LE=function(s,f,E){return s=+s,f=f>>>0,E||Nt(this,s,f,2,32767,-32768),this[f]=s&255,this[f+1]=s>>>8,f+2},m.prototype.writeInt16BE=function(s,f,E){return s=+s,f=f>>>0,E||Nt(this,s,f,2,32767,-32768),this[f]=s>>>8,this[f+1]=s&255,f+2},m.prototype.writeInt32LE=function(s,f,E){return s=+s,f=f>>>0,E||Nt(this,s,f,4,2147483647,-2147483648),this[f]=s&255,this[f+1]=s>>>8,this[f+2]=s>>>16,this[f+3]=s>>>24,f+4},m.prototype.writeInt32BE=function(s,f,E){return s=+s,f=f>>>0,E||Nt(this,s,f,4,2147483647,-2147483648),s<0&&(s=4294967295+s+1),this[f]=s>>>24,this[f+1]=s>>>16,this[f+2]=s>>>8,this[f+3]=s&255,f+4},m.prototype.writeBigInt64LE=he(function(s,f=0){return Zt(this,s,f,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),m.prototype.writeBigInt64BE=he(function(s,f=0){return fe(this,s,f,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function te(w,s,f,E,u,k){if(f+E>w.length)throw new RangeError("Index out of range");if(f<0)throw new RangeError("Index out of range")}function qt(w,s,f,E,u){return s=+s,f=f>>>0,u||te(w,s,f,4),j.write(w,s,f,E,23,4),f+4}m.prototype.writeFloatLE=function(s,f,E){return qt(this,s,f,!0,E)},m.prototype.writeFloatBE=function(s,f,E){return qt(this,s,f,!1,E)};function Ct(w,s,f,E,u){return s=+s,f=f>>>0,u||te(w,s,f,8),j.write(w,s,f,E,52,8),f+8}m.prototype.writeDoubleLE=function(s,f,E){return Ct(this,s,f,!0,E)},m.prototype.writeDoubleBE=function(s,f,E){return Ct(this,s,f,!1,E)},m.prototype.copy=function(s,f,E,u){if(!m.isBuffer(s))throw new TypeError("argument should be a Buffer");if(E||(E=0),!u&&u!==0&&(u=this.length),f>=s.length&&(f=s.length),f||(f=0),u>0&&u<E&&(u=E),u===E||s.length===0||this.length===0)return 0;if(f<0)throw new RangeError("targetStart out of bounds");if(E<0||E>=this.length)throw new RangeError("Index out of range");if(u<0)throw new RangeError("sourceEnd out of bounds");u>this.length&&(u=this.length),s.length-f<u-E&&(u=s.length-f+E);const k=u-E;return this===s&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(f,E,u):Uint8Array.prototype.set.call(s,this.subarray(E,u),f),k},m.prototype.fill=function(s,f,E,u){if(typeof s=="string"){if(typeof f=="string"?(u=f,f=0,E=this.length):typeof E=="string"&&(u=E,E=this.length),u!==void 0&&typeof u!="string")throw new TypeError("encoding must be a string");if(typeof u=="string"&&!m.isEncoding(u))throw new TypeError("Unknown encoding: "+u);if(s.length===1){const F=s.charCodeAt(0);(u==="utf8"&&F<128||u==="latin1")&&(s=F)}}else typeof s=="number"?s=s&255:typeof s=="boolean"&&(s=Number(s));if(f<0||this.length<f||this.length<E)throw new RangeError("Out of range index");if(E<=f)return this;f=f>>>0,E=E===void 0?this.length:E>>>0,s||(s=0);let k;if(typeof s=="number")for(k=f;k<E;++k)this[k]=s;else{const F=m.isBuffer(s)?s:m.from(s,u),ut=F.length;if(ut===0)throw new TypeError('The value "'+s+'" is invalid for argument "value"');for(k=0;k<E-f;++k)this[k+f]=F[k%ut]}return this};const Ft={};function Ht(w,s,f){Ft[w]=class extends f{constructor(){super(),Object.defineProperty(this,"message",{value:s.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${w}]`,this.stack,delete this.name}get code(){return w}set code(u){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:u,writable:!0})}toString(){return`${this.name} [${w}]: ${this.message}`}}}Ht("ERR_BUFFER_OUT_OF_BOUNDS",function(w){return w?`${w} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),Ht("ERR_INVALID_ARG_TYPE",function(w,s){return`The "${w}" argument must be of type number. Received type ${typeof s}`},TypeError),Ht("ERR_OUT_OF_RANGE",function(w,s,f){let E=`The value of "${w}" is out of range.`,u=f;return Number.isInteger(f)&&Math.abs(f)>2**32?u=jt(String(f)):typeof f=="bigint"&&(u=String(f),(f>BigInt(2)**BigInt(32)||f<-(BigInt(2)**BigInt(32)))&&(u=jt(u)),u+="n"),E+=` It must be ${s}. Received ${u}`,E},RangeError);function jt(w){let s="",f=w.length;const E=w[0]==="-"?1:0;for(;f>=E+4;f-=3)s=`_${w.slice(f-3,f)}${s}`;return`${w.slice(0,f)}${s}`}function Xt(w,s,f){zt(s,"offset"),(w[s]===void 0||w[s+f]===void 0)&&ne(s,w.length-(f+1))}function Pt(w,s,f,E,u,k){if(w>f||w<s){const F=typeof s=="bigint"?"n":"";let ut;throw s===0||s===BigInt(0)?ut=`>= 0${F} and < 2${F} ** ${(k+1)*8}${F}`:ut=`>= -(2${F} ** ${(k+1)*8-1}${F}) and < 2 ** ${(k+1)*8-1}${F}`,new Ft.ERR_OUT_OF_RANGE("value",ut,w)}Xt(E,u,k)}function zt(w,s){if(typeof w!="number")throw new Ft.ERR_INVALID_ARG_TYPE(s,"number",w)}function ne(w,s,f){throw Math.floor(w)!==w?(zt(w,f),new Ft.ERR_OUT_OF_RANGE("offset","an integer",w)):s<0?new Ft.ERR_BUFFER_OUT_OF_BOUNDS:new Ft.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${s}`,w)}const ue=/[^+/0-9A-Za-z-_]/g;function Kt(w){if(w=w.split("=")[0],w=w.trim().replace(ue,""),w.length<2)return"";for(;w.length%4!==0;)w=w+"=";return w}function W(w,s){s=s||1/0;let f;const E=w.length;let u=null;const k=[];for(let F=0;F<E;++F){if(f=w.charCodeAt(F),f>55295&&f<57344){if(!u){if(f>56319){(s-=3)>-1&&k.push(239,191,189);continue}else if(F+1===E){(s-=3)>-1&&k.push(239,191,189);continue}u=f;continue}if(f<56320){(s-=3)>-1&&k.push(239,191,189),u=f;continue}f=(u-55296<<10|f-56320)+65536}else u&&(s-=3)>-1&&k.push(239,191,189);if(u=null,f<128){if((s-=1)<0)break;k.push(f)}else if(f<2048){if((s-=2)<0)break;k.push(f>>6|192,f&63|128)}else if(f<65536){if((s-=3)<0)break;k.push(f>>12|224,f>>6&63|128,f&63|128)}else if(f<1114112){if((s-=4)<0)break;k.push(f>>18|240,f>>12&63|128,f>>6&63|128,f&63|128)}else throw new Error("Invalid code point")}return k}function Mt(w){const s=[];for(let f=0;f<w.length;++f)s.push(w.charCodeAt(f)&255);return s}function ie(w,s){let f,E,u;const k=[];for(let F=0;F<w.length&&!((s-=2)<0);++F)f=w.charCodeAt(F),E=f>>8,u=f%256,k.push(u),k.push(E);return k}function be(w){return S.toByteArray(Kt(w))}function ae(w,s,f,E){let u;for(u=0;u<E&&!(u+f>=s.length||u>=w.length);++u)s[u+f]=w[u];return u}function Jt(w,s){return w instanceof s||w!=null&&w.constructor!=null&&w.constructor.name!=null&&w.constructor.name===s.name}function xe(w){return w!==w}const Ee=(function(){const w="0123456789abcdef",s=new Array(256);for(let f=0;f<16;++f){const E=f*16;for(let u=0;u<16;++u)s[E+u]=w[f]+w[u]}return s})();function he(w){return typeof BigInt>"u"?ze:w}function ze(){throw new Error("BigInt not supported")}})(Nn)),Nn}/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */var hs;function Qi(){return hs||(hs=1,(function(b,S){var j=Au(),I=j.Buffer;function N(R,m){for(var _ in R)m[_]=R[_]}I.from&&I.alloc&&I.allocUnsafe&&I.allocUnsafeSlow?b.exports=j:(N(j,S),S.Buffer=T);function T(R,m,_){return I(R,m,_)}T.prototype=Object.create(I.prototype),N(I,T),T.from=function(R,m,_){if(typeof R=="number")throw new TypeError("Argument must not be a number");return I(R,m,_)},T.alloc=function(R,m,_){if(typeof R!="number")throw new TypeError("Argument must be a number");var D=I(R);return m!==void 0?typeof _=="string"?D.fill(m,_):D.fill(m):D.fill(0),D},T.allocUnsafe=function(R){if(typeof R!="number")throw new TypeError("Argument must be a number");return I(R)},T.allocUnsafeSlow=function(R){if(typeof R!="number")throw new TypeError("Argument must be a number");return j.SlowBuffer(R)}})(hn,hn.exports)),hn.exports}var Mn,ds;function ku(){if(ds)return Mn;ds=1;var b={}.toString;return Mn=Array.isArray||function(S){return b.call(S)=="[object Array]"},Mn}var jn,ps;function Vr(){return ps||(ps=1,jn=TypeError),jn}var Ln,ws;function Fc(){return ws||(ws=1,Ln=Object),Ln}var qn,gs;function Ru(){return gs||(gs=1,qn=Error),qn}var zn,ms;function Bu(){return ms||(ms=1,zn=EvalError),zn}var Gn,ys;function Iu(){return ys||(ys=1,Gn=RangeError),Gn}var Hn,_s;function Tu(){return _s||(_s=1,Hn=ReferenceError),Hn}var Zn,vs;function Dc(){return vs||(vs=1,Zn=SyntaxError),Zn}var Wn,bs;function Ou(){return bs||(bs=1,Wn=URIError),Wn}var Xn,xs;function $u(){return xs||(xs=1,Xn=Math.abs),Xn}var Vn,Es;function Pu(){return Es||(Es=1,Vn=Math.floor),Vn}var Yn,Ss;function Cu(){return Ss||(Ss=1,Yn=Math.max),Yn}var Kn,As;function Fu(){return As||(As=1,Kn=Math.min),Kn}var Jn,ks;function Du(){return ks||(ks=1,Jn=Math.pow),Jn}var Qn,Rs;function Uu(){return Rs||(Rs=1,Qn=Math.round),Qn}var ti,Bs;function Nu(){return Bs||(Bs=1,ti=Number.isNaN||function(S){return S!==S}),ti}var ei,Is;function Mu(){if(Is)return ei;Is=1;var b=Nu();return ei=function(j){return b(j)||j===0?j:j<0?-1:1},ei}var ri,Ts;function ju(){return Ts||(Ts=1,ri=Object.getOwnPropertyDescriptor),ri}var ni,Os;function Yr(){if(Os)return ni;Os=1;var b=ju();if(b)try{b([],"length")}catch{b=null}return ni=b,ni}var ii,$s;function pn(){if($s)return ii;$s=1;var b=Object.defineProperty||!1;if(b)try{b({},"a",{value:1})}catch{b=!1}return ii=b,ii}var ai,Ps;function Uc(){return Ps||(Ps=1,ai=function(){if(typeof Symbol!="function"||typeof Object.getOwnPropertySymbols!="function")return!1;if(typeof Symbol.iterator=="symbol")return!0;var S={},j=Symbol("test"),I=Object(j);if(typeof j=="string"||Object.prototype.toString.call(j)!=="[object Symbol]"||Object.prototype.toString.call(I)!=="[object Symbol]")return!1;var N=42;S[j]=N;for(var T in S)return!1;if(typeof Object.keys=="function"&&Object.keys(S).length!==0||typeof Object.getOwnPropertyNames=="function"&&Object.getOwnPropertyNames(S).length!==0)return!1;var R=Object.getOwnPropertySymbols(S);if(R.length!==1||R[0]!==j||!Object.prototype.propertyIsEnumerable.call(S,j))return!1;if(typeof Object.getOwnPropertyDescriptor=="function"){var m=Object.getOwnPropertyDescriptor(S,j);if(m.value!==N||m.enumerable!==!0)return!1}return!0}),ai}var oi,Cs;function Lu(){if(Cs)return oi;Cs=1;var b=typeof Symbol<"u"&&Symbol,S=Uc();return oi=function(){return typeof b!="function"||typeof Symbol!="function"||typeof b("foo")!="symbol"||typeof Symbol("bar")!="symbol"?!1:S()},oi}var si,Fs;function Nc(){return Fs||(Fs=1,si=typeof Reflect<"u"&&Reflect.getPrototypeOf||null),si}var ci,Ds;function Mc(){if(Ds)return ci;Ds=1;var b=Fc();return ci=b.getPrototypeOf||null,ci}var fi,Us;function qu(){if(Us)return fi;Us=1;var b="Function.prototype.bind called on incompatible ",S=Object.prototype.toString,j=Math.max,I="[object Function]",N=function(_,D){for(var C=[],A=0;A<_.length;A+=1)C[A]=_[A];for(var U=0;U<D.length;U+=1)C[U+_.length]=D[U];return C},T=function(_,D){for(var C=[],A=D,U=0;A<_.length;A+=1,U+=1)C[U]=_[A];return C},R=function(m,_){for(var D="",C=0;C<m.length;C+=1)D+=m[C],C+1<m.length&&(D+=_);return D};return fi=function(_){var D=this;if(typeof D!="function"||S.apply(D)!==I)throw new TypeError(b+D);for(var C=T(arguments,1),A,U=function(){if(this instanceof A){var X=D.apply(this,N(C,arguments));return Object(X)===X?X:this}return D.apply(_,N(C,arguments))},L=j(0,D.length-C.length),et=[],lt=0;lt<L;lt++)et[lt]="$"+lt;if(A=Function("binder","return function ("+R(et,",")+"){ return binder.apply(this,arguments); }")(U),D.prototype){var Z=function(){};Z.prototype=D.prototype,A.prototype=new Z,Z.prototype=null}return A},fi}var ui,Ns;function Kr(){if(Ns)return ui;Ns=1;var b=qu();return ui=Function.prototype.bind||b,ui}var li,Ms;function ta(){return Ms||(Ms=1,li=Function.prototype.call),li}var hi,js;function ea(){return js||(js=1,hi=Function.prototype.apply),hi}var di,Ls;function zu(){return Ls||(Ls=1,di=typeof Reflect<"u"&&Reflect&&Reflect.apply),di}var pi,qs;function jc(){if(qs)return pi;qs=1;var b=Kr(),S=ea(),j=ta(),I=zu();return pi=I||b.call(j,S),pi}var wi,zs;function ra(){if(zs)return wi;zs=1;var b=Kr(),S=Vr(),j=ta(),I=jc();return wi=function(T){if(T.length<1||typeof T[0]!="function")throw new S("a function is required");return I(b,j,T)},wi}var gi,Gs;function Gu(){if(Gs)return gi;Gs=1;var b=ra(),S=Yr(),j;try{j=[].__proto__===Array.prototype}catch(R){if(!R||typeof R!="object"||!("code"in R)||R.code!=="ERR_PROTO_ACCESS")throw R}var I=!!j&&S&&S(Object.prototype,"__proto__"),N=Object,T=N.getPrototypeOf;return gi=I&&typeof I.get=="function"?b([I.get]):typeof T=="function"?function(m){return T(m==null?m:N(m))}:!1,gi}var mi,Hs;function Lc(){if(Hs)return mi;Hs=1;var b=Nc(),S=Mc(),j=Gu();return mi=b?function(N){return b(N)}:S?function(N){if(!N||typeof N!="object"&&typeof N!="function")throw new TypeError("getProto: not an object");return S(N)}:j?function(N){return j(N)}:null,mi}var yi,Zs;function Hu(){if(Zs)return yi;Zs=1;var b=Function.prototype.call,S=Object.prototype.hasOwnProperty,j=Kr();return yi=j.call(b,S),yi}var _i,Ws;function qc(){if(Ws)return _i;Ws=1;var b,S=Fc(),j=Ru(),I=Bu(),N=Iu(),T=Tu(),R=Dc(),m=Vr(),_=Ou(),D=$u(),C=Pu(),A=Cu(),U=Fu(),L=Du(),et=Uu(),lt=Mu(),Z=Function,X=function(Ht){try{return Z('"use strict"; return ('+Ht+").constructor;")()}catch{}},Q=Yr(),G=pn(),st=function(){throw new m},ht=Q?(function(){try{return arguments.callee,st}catch{try{return Q(arguments,"callee").get}catch{return st}}})():st,pt=Lu()(),V=Lc(),K=Mc(),gt=Nc(),nt=ea(),_t=ta(),dt={},mt=typeof Uint8Array>"u"||!V?b:V(Uint8Array),kt={__proto__:null,"%AggregateError%":typeof AggregateError>"u"?b:AggregateError,"%Array%":Array,"%ArrayBuffer%":typeof ArrayBuffer>"u"?b:ArrayBuffer,"%ArrayIteratorPrototype%":pt&&V?V([][Symbol.iterator]()):b,"%AsyncFromSyncIteratorPrototype%":b,"%AsyncFunction%":dt,"%AsyncGenerator%":dt,"%AsyncGeneratorFunction%":dt,"%AsyncIteratorPrototype%":dt,"%Atomics%":typeof Atomics>"u"?b:Atomics,"%BigInt%":typeof BigInt>"u"?b:BigInt,"%BigInt64Array%":typeof BigInt64Array>"u"?b:BigInt64Array,"%BigUint64Array%":typeof BigUint64Array>"u"?b:BigUint64Array,"%Boolean%":Boolean,"%DataView%":typeof DataView>"u"?b:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":j,"%eval%":eval,"%EvalError%":I,"%Float16Array%":typeof Float16Array>"u"?b:Float16Array,"%Float32Array%":typeof Float32Array>"u"?b:Float32Array,"%Float64Array%":typeof Float64Array>"u"?b:Float64Array,"%FinalizationRegistry%":typeof FinalizationRegistry>"u"?b:FinalizationRegistry,"%Function%":Z,"%GeneratorFunction%":dt,"%Int8Array%":typeof Int8Array>"u"?b:Int8Array,"%Int16Array%":typeof Int16Array>"u"?b:Int16Array,"%Int32Array%":typeof Int32Array>"u"?b:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":pt&&V?V(V([][Symbol.iterator]())):b,"%JSON%":typeof JSON=="object"?JSON:b,"%Map%":typeof Map>"u"?b:Map,"%MapIteratorPrototype%":typeof Map>"u"||!pt||!V?b:V(new Map()[Symbol.iterator]()),"%Math%":Math,"%Number%":Number,"%Object%":S,"%Object.getOwnPropertyDescriptor%":Q,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":typeof Promise>"u"?b:Promise,"%Proxy%":typeof Proxy>"u"?b:Proxy,"%RangeError%":N,"%ReferenceError%":T,"%Reflect%":typeof Reflect>"u"?b:Reflect,"%RegExp%":RegExp,"%Set%":typeof Set>"u"?b:Set,"%SetIteratorPrototype%":typeof Set>"u"||!pt||!V?b:V(new Set()[Symbol.iterator]()),"%SharedArrayBuffer%":typeof SharedArrayBuffer>"u"?b:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":pt&&V?V(""[Symbol.iterator]()):b,"%Symbol%":pt?Symbol:b,"%SyntaxError%":R,"%ThrowTypeError%":ht,"%TypedArray%":mt,"%TypeError%":m,"%Uint8Array%":typeof Uint8Array>"u"?b:Uint8Array,"%Uint8ClampedArray%":typeof Uint8ClampedArray>"u"?b:Uint8ClampedArray,"%Uint16Array%":typeof Uint16Array>"u"?b:Uint16Array,"%Uint32Array%":typeof Uint32Array>"u"?b:Uint32Array,"%URIError%":_,"%WeakMap%":typeof WeakMap>"u"?b:WeakMap,"%WeakRef%":typeof WeakRef>"u"?b:WeakRef,"%WeakSet%":typeof WeakSet>"u"?b:WeakSet,"%Function.prototype.call%":_t,"%Function.prototype.apply%":nt,"%Object.defineProperty%":G,"%Object.getPrototypeOf%":K,"%Math.abs%":D,"%Math.floor%":C,"%Math.max%":A,"%Math.min%":U,"%Math.pow%":L,"%Math.round%":et,"%Math.sign%":lt,"%Reflect.getPrototypeOf%":gt};if(V)try{null.error}catch(Ht){var Wt=V(V(Ht));kt["%Error.prototype%"]=Wt}var re=function Ht(jt){var Xt;if(jt==="%AsyncFunction%")Xt=X("async function () {}");else if(jt==="%GeneratorFunction%")Xt=X("function* () {}");else if(jt==="%AsyncGeneratorFunction%")Xt=X("async function* () {}");else if(jt==="%AsyncGenerator%"){var Pt=Ht("%AsyncGeneratorFunction%");Pt&&(Xt=Pt.prototype)}else if(jt==="%AsyncIteratorPrototype%"){var zt=Ht("%AsyncGenerator%");zt&&V&&(Xt=V(zt.prototype))}return kt[jt]=Xt,Xt},it={__proto__:null,"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},ct=Kr(),ft=Hu(),Ut=ct.call(_t,Array.prototype.concat),Rt=ct.call(nt,Array.prototype.splice),Nt=ct.call(_t,String.prototype.replace),Zt=ct.call(_t,String.prototype.slice),fe=ct.call(_t,RegExp.prototype.exec),te=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,qt=/\\(\\)?/g,Ct=function(jt){var Xt=Zt(jt,0,1),Pt=Zt(jt,-1);if(Xt==="%"&&Pt!=="%")throw new R("invalid intrinsic syntax, expected closing `%`");if(Pt==="%"&&Xt!=="%")throw new R("invalid intrinsic syntax, expected opening `%`");var zt=[];return Nt(jt,te,function(ne,ue,Kt,W){zt[zt.length]=Kt?Nt(W,qt,"$1"):ue||ne}),zt},Ft=function(jt,Xt){var Pt=jt,zt;if(ft(it,Pt)&&(zt=it[Pt],Pt="%"+zt[0]+"%"),ft(kt,Pt)){var ne=kt[Pt];if(ne===dt&&(ne=re(Pt)),typeof ne>"u"&&!Xt)throw new m("intrinsic "+jt+" exists, but is not available. Please file an issue!");return{alias:zt,name:Pt,value:ne}}throw new R("intrinsic "+jt+" does not exist!")};return _i=function(jt,Xt){if(typeof jt!="string"||jt.length===0)throw new m("intrinsic name must be a non-empty string");if(arguments.length>1&&typeof Xt!="boolean")throw new m('"allowMissing" argument must be a boolean');if(fe(/^%?[^%]*%?$/,jt)===null)throw new R("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var Pt=Ct(jt),zt=Pt.length>0?Pt[0]:"",ne=Ft("%"+zt+"%",Xt),ue=ne.name,Kt=ne.value,W=!1,Mt=ne.alias;Mt&&(zt=Mt[0],Rt(Pt,Ut([0,1],Mt)));for(var ie=1,be=!0;ie<Pt.length;ie+=1){var ae=Pt[ie],Jt=Zt(ae,0,1),xe=Zt(ae,-1);if((Jt==='"'||Jt==="'"||Jt==="`"||xe==='"'||xe==="'"||xe==="`")&&Jt!==xe)throw new R("property names with quotes must have matching quotes");if((ae==="constructor"||!be)&&(W=!0),zt+="."+ae,ue="%"+zt+"%",ft(kt,ue))Kt=kt[ue];else if(Kt!=null){if(!(ae in Kt)){if(!Xt)throw new m("base intrinsic for "+jt+" exists, but the property is not available.");return}if(Q&&ie+1>=Pt.length){var Ee=Q(Kt,ae);be=!!Ee,be&&"get"in Ee&&!("originalValue"in Ee.get)?Kt=Ee.get:Kt=Kt[ae]}else be=ft(Kt,ae),Kt=Kt[ae];be&&!W&&(kt[ue]=Kt)}}return Kt},_i}var vi,Xs;function zc(){if(Xs)return vi;Xs=1;var b=qc(),S=ra(),j=S([b("%String.prototype.indexOf%")]);return vi=function(N,T){var R=b(N,!!T);return typeof R=="function"&&j(N,".prototype.")>-1?S([R]):R},vi}var bi,Vs;function Zu(){if(Vs)return bi;Vs=1;var b=Function.prototype.toString,S=typeof Reflect=="object"&&Reflect!==null&&Reflect.apply,j,I;if(typeof S=="function"&&typeof Object.defineProperty=="function")try{j=Object.defineProperty({},"length",{get:function(){throw I}}),I={},S(function(){throw 42},null,j)}catch(Q){Q!==I&&(S=null)}else S=null;var N=/^\s*class\b/,T=function(G){try{var st=b.call(G);return N.test(st)}catch{return!1}},R=function(G){try{return T(G)?!1:(b.call(G),!0)}catch{return!1}},m=Object.prototype.toString,_="[object Object]",D="[object Function]",C="[object GeneratorFunction]",A="[object HTMLAllCollection]",U="[object HTML document.all class]",L="[object HTMLCollection]",et=typeof Symbol=="function"&&!!Symbol.toStringTag,lt=!(0 in[,]),Z=function(){return!1};if(typeof document=="object"){var X=document.all;m.call(X)===m.call(document.all)&&(Z=function(G){if((lt||!G)&&(typeof G>"u"||typeof G=="object"))try{var st=m.call(G);return(st===A||st===U||st===L||st===_)&&G("")==null}catch{}return!1})}return bi=S?function(G){if(Z(G))return!0;if(!G||typeof G!="function"&&typeof G!="object")return!1;try{S(G,null,j)}catch(st){if(st!==I)return!1}return!T(G)&&R(G)}:function(G){if(Z(G))return!0;if(!G||typeof G!="function"&&typeof G!="object")return!1;if(et)return R(G);if(T(G))return!1;var st=m.call(G);return st!==D&&st!==C&&!/^\[object HTML/.test(st)?!1:R(G)},bi}var xi,Ys;function Wu(){if(Ys)return xi;Ys=1;var b=Zu(),S=Object.prototype.toString,j=Object.prototype.hasOwnProperty,I=function(_,D,C){for(var A=0,U=_.length;A<U;A++)j.call(_,A)&&(C==null?D(_[A],A,_):D.call(C,_[A],A,_))},N=function(_,D,C){for(var A=0,U=_.length;A<U;A++)C==null?D(_.charAt(A),A,_):D.call(C,_.charAt(A),A,_)},T=function(_,D,C){for(var A in _)j.call(_,A)&&(C==null?D(_[A],A,_):D.call(C,_[A],A,_))};function R(m){return S.call(m)==="[object Array]"}return xi=function(_,D,C){if(!b(D))throw new TypeError("iterator must be a function");var A;arguments.length>=3&&(A=C),R(_)?I(_,D,A):typeof _=="string"?N(_,D,A):T(_,D,A)},xi}var Ei,Ks;function Xu(){return Ks||(Ks=1,Ei=["Float16Array","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array"]),Ei}var Si,Js;function Vu(){if(Js)return Si;Js=1;var b=Xu(),S=typeof globalThis>"u"?Cc:globalThis;return Si=function(){for(var I=[],N=0;N<b.length;N++)typeof S[b[N]]=="function"&&(I[I.length]=b[N]);return I},Si}var Ai={exports:{}},ki,Qs;function Yu(){if(Qs)return ki;Qs=1;var b=pn(),S=Dc(),j=Vr(),I=Yr();return ki=function(T,R,m){if(!T||typeof T!="object"&&typeof T!="function")throw new j("`obj` must be an object or a function`");if(typeof R!="string"&&typeof R!="symbol")throw new j("`property` must be a string or a symbol`");if(arguments.length>3&&typeof arguments[3]!="boolean"&&arguments[3]!==null)throw new j("`nonEnumerable`, if provided, must be a boolean or null");if(arguments.length>4&&typeof arguments[4]!="boolean"&&arguments[4]!==null)throw new j("`nonWritable`, if provided, must be a boolean or null");if(arguments.length>5&&typeof arguments[5]!="boolean"&&arguments[5]!==null)throw new j("`nonConfigurable`, if provided, must be a boolean or null");if(arguments.length>6&&typeof arguments[6]!="boolean")throw new j("`loose`, if provided, must be a boolean");var _=arguments.length>3?arguments[3]:null,D=arguments.length>4?arguments[4]:null,C=arguments.length>5?arguments[5]:null,A=arguments.length>6?arguments[6]:!1,U=!!I&&I(T,R);if(b)b(T,R,{configurable:C===null&&U?U.configurable:!C,enumerable:_===null&&U?U.enumerable:!_,value:m,writable:D===null&&U?U.writable:!D});else if(A||!_&&!D&&!C)T[R]=m;else throw new S("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")},ki}var Ri,tc;function Ku(){if(tc)return Ri;tc=1;var b=pn(),S=function(){return!!b};return S.hasArrayLengthDefineBug=function(){if(!b)return null;try{return b([],"length",{value:1}).length!==1}catch{return!0}},Ri=S,Ri}var Bi,ec;function Ju(){if(ec)return Bi;ec=1;var b=qc(),S=Yu(),j=Ku()(),I=Yr(),N=Vr(),T=b("%Math.floor%");return Bi=function(m,_){if(typeof m!="function")throw new N("`fn` is not a function");if(typeof _!="number"||_<0||_>4294967295||T(_)!==_)throw new N("`length` must be a positive 32-bit integer");var D=arguments.length>2&&!!arguments[2],C=!0,A=!0;if("length"in m&&I){var U=I(m,"length");U&&!U.configurable&&(C=!1),U&&!U.writable&&(A=!1)}return(C||A||!D)&&(j?S(m,"length",_,!0,!0):S(m,"length",_)),m},Bi}var Ii,rc;function Qu(){if(rc)return Ii;rc=1;var b=Kr(),S=ea(),j=jc();return Ii=function(){return j(b,S,arguments)},Ii}var nc;function tl(){return nc||(nc=1,(function(b){var S=Ju(),j=pn(),I=ra(),N=Qu();b.exports=function(R){var m=I(arguments),_=R.length-(arguments.length-1);return S(m,1+(_>0?_:0),!0)},j?j(b.exports,"apply",{value:N}):b.exports.apply=N})(Ai)),Ai.exports}var Ti,ic;function el(){if(ic)return Ti;ic=1;var b=Uc();return Ti=function(){return b()&&!!Symbol.toStringTag},Ti}var Oi,ac;function rl(){if(ac)return Oi;ac=1;var b=Wu(),S=Vu(),j=tl(),I=zc(),N=Yr(),T=Lc(),R=I("Object.prototype.toString"),m=el()(),_=typeof globalThis>"u"?Cc:globalThis,D=S(),C=I("String.prototype.slice"),A=I("Array.prototype.indexOf",!0)||function(Z,X){for(var Q=0;Q<Z.length;Q+=1)if(Z[Q]===X)return Q;return-1},U={__proto__:null};m&&N&&T?b(D,function(lt){var Z=new _[lt];if(Symbol.toStringTag in Z&&T){var X=T(Z),Q=N(X,Symbol.toStringTag);if(!Q&&X){var G=T(X);Q=N(G,Symbol.toStringTag)}if(Q&&Q.get){var st=j(Q.get);U["$"+lt]=st}}}):b(D,function(lt){var Z=new _[lt],X=Z.slice||Z.set;if(X){var Q=j(X);U["$"+lt]=Q}});var L=function(Z){var X=!1;return b(U,function(Q,G){if(!X)try{"$"+Q(Z)===G&&(X=C(G,1))}catch{}}),X},et=function(Z){var X=!1;return b(U,function(Q,G){if(!X)try{Q(Z),X=C(G,1)}catch{}}),X};return Oi=function(Z){if(!Z||typeof Z!="object")return!1;if(!m){var X=C(R(Z),8,-1);return A(D,X)>-1?X:X!=="Object"?!1:et(Z)}return N?L(Z):null},Oi}var $i,oc;function nl(){if(oc)return $i;oc=1;var b=rl();return $i=function(j){return!!b(j)},$i}var Pi,sc;function il(){if(sc)return Pi;sc=1;var b=Vr(),S=zc(),j=S("TypedArray.prototype.buffer",!0),I=nl();return Pi=j||function(T){if(!I(T))throw new b("Not a Typed Array");return T.buffer},Pi}var Ci,cc;function al(){if(cc)return Ci;cc=1;var b=Qi().Buffer,S=ku(),j=il(),I=ArrayBuffer.isView||function(_){try{return j(_),!0}catch{return!1}},N=typeof Uint8Array<"u",T=typeof ArrayBuffer<"u"&&typeof Uint8Array<"u",R=T&&(b.prototype instanceof Uint8Array||b.TYPED_ARRAY_SUPPORT);return Ci=function(_,D){if(b.isBuffer(_))return _.constructor&&!("isBuffer"in _)?b.from(_):_;if(typeof _=="string")return b.from(_,D);if(T&&I(_)){if(_.byteLength===0)return b.alloc(0);if(R){var C=b.from(_.buffer,_.byteOffset,_.byteLength);if(C.byteLength===_.byteLength)return C}var A=_ instanceof Uint8Array?_:new Uint8Array(_.buffer,_.byteOffset,_.byteLength),U=b.from(A);if(U.length===_.byteLength)return U}if(N&&_ instanceof Uint8Array)return b.from(_);var L=S(_);if(L)for(var et=0;et<_.length;et+=1){var lt=_[et];if(typeof lt!="number"||lt<0||lt>255||~~lt!==lt)throw new RangeError("Array items must be numbers in the range 0-255.")}if(L||b.isBuffer(_)&&_.constructor&&typeof _.constructor.isBuffer=="function"&&_.constructor.isBuffer(_))return b.from(_);throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.')},Ci}var Fi,fc;function ol(){if(fc)return Fi;fc=1;var b=Qi().Buffer,S=al();function j(I,N){this._block=b.alloc(I),this._finalSize=N,this._blockSize=I,this._len=0}return j.prototype.update=function(I,N){I=S(I,N||"utf8");for(var T=this._block,R=this._blockSize,m=I.length,_=this._len,D=0;D<m;){for(var C=_%R,A=Math.min(m-D,R-C),U=0;U<A;U++)T[C+U]=I[D+U];_+=A,D+=A,_%R===0&&this._update(T)}return this._len+=m,this},j.prototype.digest=function(I){var N=this._len%this._blockSize;this._block[N]=128,this._block.fill(0,N+1),N>=this._finalSize&&(this._update(this._block),this._block.fill(0));var T=this._len*8;if(T<=4294967295)this._block.writeUInt32BE(T,this._blockSize-4);else{var R=(T&4294967295)>>>0,m=(T-R)/4294967296;this._block.writeUInt32BE(m,this._blockSize-8),this._block.writeUInt32BE(R,this._blockSize-4)}this._update(this._block);var _=this._hash();return I?_.toString(I):_},j.prototype._update=function(){throw new Error("_update must be implemented by subclass")},Fi=j,Fi}var Di,uc;function sl(){if(uc)return Di;uc=1;var b=xu(),S=ol(),j=Qi().Buffer,I=[1518500249,1859775393,-1894007588,-899497514],N=new Array(80);function T(){this.init(),this._w=N,S.call(this,64,56)}b(T,S),T.prototype.init=function(){return this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878,this._e=3285377520,this};function R(C){return C<<1|C>>>31}function m(C){return C<<5|C>>>27}function _(C){return C<<30|C>>>2}function D(C,A,U,L){return C===0?A&U|~A&L:C===2?A&U|A&L|U&L:A^U^L}return T.prototype._update=function(C){for(var A=this._w,U=this._a|0,L=this._b|0,et=this._c|0,lt=this._d|0,Z=this._e|0,X=0;X<16;++X)A[X]=C.readInt32BE(X*4);for(;X<80;++X)A[X]=R(A[X-3]^A[X-8]^A[X-14]^A[X-16]);for(var Q=0;Q<80;++Q){var G=~~(Q/20),st=m(U)+D(G,L,et,lt)+Z+A[Q]+I[G]|0;Z=lt,lt=et,et=_(L),L=U,U=st}this._a=U+this._a|0,this._b=L+this._b|0,this._c=et+this._c|0,this._d=lt+this._d|0,this._e=Z+this._e|0},T.prototype._hash=function(){var C=j.allocUnsafe(20);return C.writeInt32BE(this._a|0,0),C.writeInt32BE(this._b|0,4),C.writeInt32BE(this._c|0,8),C.writeInt32BE(this._d|0,12),C.writeInt32BE(this._e|0,16),C},Di=T,Di}var Ui={};/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */var lc;function cl(){return lc||(lc=1,(function(b){(function(S){S(typeof DO_NOT_EXPORT_CRC>"u"?b:{})})(function(S){S.version="1.2.2";function j(){for(var K=0,gt=new Array(256),nt=0;nt!=256;++nt)K=nt,K=K&1?-306674912^K>>>1:K>>>1,K=K&1?-306674912^K>>>1:K>>>1,K=K&1?-306674912^K>>>1:K>>>1,K=K&1?-306674912^K>>>1:K>>>1,K=K&1?-306674912^K>>>1:K>>>1,K=K&1?-306674912^K>>>1:K>>>1,K=K&1?-306674912^K>>>1:K>>>1,K=K&1?-306674912^K>>>1:K>>>1,gt[nt]=K;return typeof Int32Array<"u"?new Int32Array(gt):gt}var I=j();function N(K){var gt=0,nt=0,_t=0,dt=typeof Int32Array<"u"?new Int32Array(4096):new Array(4096);for(_t=0;_t!=256;++_t)dt[_t]=K[_t];for(_t=0;_t!=256;++_t)for(nt=K[_t],gt=256+_t;gt<4096;gt+=256)nt=dt[gt]=nt>>>8^K[nt&255];var mt=[];for(_t=1;_t!=16;++_t)mt[_t-1]=typeof Int32Array<"u"?dt.subarray(_t*256,_t*256+256):dt.slice(_t*256,_t*256+256);return mt}var T=N(I),R=T[0],m=T[1],_=T[2],D=T[3],C=T[4],A=T[5],U=T[6],L=T[7],et=T[8],lt=T[9],Z=T[10],X=T[11],Q=T[12],G=T[13],st=T[14];function ht(K,gt){for(var nt=gt^-1,_t=0,dt=K.length;_t<dt;)nt=nt>>>8^I[(nt^K.charCodeAt(_t++))&255];return~nt}function pt(K,gt){for(var nt=gt^-1,_t=K.length-15,dt=0;dt<_t;)nt=st[K[dt++]^nt&255]^G[K[dt++]^nt>>8&255]^Q[K[dt++]^nt>>16&255]^X[K[dt++]^nt>>>24]^Z[K[dt++]]^lt[K[dt++]]^et[K[dt++]]^L[K[dt++]]^U[K[dt++]]^A[K[dt++]]^C[K[dt++]]^D[K[dt++]]^_[K[dt++]]^m[K[dt++]]^R[K[dt++]]^I[K[dt++]];for(_t+=15;dt<_t;)nt=nt>>>8^I[(nt^K[dt++])&255];return~nt}function V(K,gt){for(var nt=gt^-1,_t=0,dt=K.length,mt=0,kt=0;_t<dt;)mt=K.charCodeAt(_t++),mt<128?nt=nt>>>8^I[(nt^mt)&255]:mt<2048?(nt=nt>>>8^I[(nt^(192|mt>>6&31))&255],nt=nt>>>8^I[(nt^(128|mt&63))&255]):mt>=55296&&mt<57344?(mt=(mt&1023)+64,kt=K.charCodeAt(_t++)&1023,nt=nt>>>8^I[(nt^(240|mt>>8&7))&255],nt=nt>>>8^I[(nt^(128|mt>>2&63))&255],nt=nt>>>8^I[(nt^(128|kt>>6&15|(mt&3)<<4))&255],nt=nt>>>8^I[(nt^(128|kt&63))&255]):(nt=nt>>>8^I[(nt^(224|mt>>12&15))&255],nt=nt>>>8^I[(nt^(128|mt>>6&63))&255],nt=nt>>>8^I[(nt^(128|mt&63))&255]);return~nt}S.table=I,S.bstr=ht,S.buf=pt,S.str=V})})(Ui)),Ui}var Ni={},hc;function Qe(){return hc||(hc=1,(function(b){var S=typeof Uint8Array<"u"&&typeof Uint16Array<"u"&&typeof Int32Array<"u";function j(T,R){return Object.prototype.hasOwnProperty.call(T,R)}b.assign=function(T){for(var R=Array.prototype.slice.call(arguments,1);R.length;){var m=R.shift();if(m){if(typeof m!="object")throw new TypeError(m+"must be non-object");for(var _ in m)j(m,_)&&(T[_]=m[_])}}return T},b.shrinkBuf=function(T,R){return T.length===R?T:T.subarray?T.subarray(0,R):(T.length=R,T)};var I={arraySet:function(T,R,m,_,D){if(R.subarray&&T.subarray){T.set(R.subarray(m,m+_),D);return}for(var C=0;C<_;C++)T[D+C]=R[m+C]},flattenChunks:function(T){var R,m,_,D,C,A;for(_=0,R=0,m=T.length;R<m;R++)_+=T[R].length;for(A=new Uint8Array(_),D=0,R=0,m=T.length;R<m;R++)C=T[R],A.set(C,D),D+=C.length;return A}},N={arraySet:function(T,R,m,_,D){for(var C=0;C<_;C++)T[D+C]=R[m+C]},flattenChunks:function(T){return[].concat.apply([],T)}};b.setTyped=function(T){T?(b.Buf8=Uint8Array,b.Buf16=Uint16Array,b.Buf32=Int32Array,b.assign(b,I)):(b.Buf8=Array,b.Buf16=Array,b.Buf32=Array,b.assign(b,N))},b.setTyped(S)})(Ni)),Ni}var Sr={},qe={},cr={},dc;function fl(){if(dc)return cr;dc=1;var b=Qe(),S=4,j=0,I=1,N=2;function T(u){for(var k=u.length;--k>=0;)u[k]=0}var R=0,m=1,_=2,D=3,C=258,A=29,U=256,L=U+1+A,et=30,lt=19,Z=2*L+1,X=15,Q=16,G=7,st=256,ht=16,pt=17,V=18,K=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],gt=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],nt=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],_t=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],dt=512,mt=new Array((L+2)*2);T(mt);var kt=new Array(et*2);T(kt);var Wt=new Array(dt);T(Wt);var re=new Array(C-D+1);T(re);var it=new Array(A);T(it);var ct=new Array(et);T(ct);function ft(u,k,F,ut,O){this.static_tree=u,this.extra_bits=k,this.extra_base=F,this.elems=ut,this.max_length=O,this.has_stree=u&&u.length}var Ut,Rt,Nt;function Zt(u,k){this.dyn_tree=u,this.max_code=0,this.stat_desc=k}function fe(u){return u<256?Wt[u]:Wt[256+(u>>>7)]}function te(u,k){u.pending_buf[u.pending++]=k&255,u.pending_buf[u.pending++]=k>>>8&255}function qt(u,k,F){u.bi_valid>Q-F?(u.bi_buf|=k<<u.bi_valid&65535,te(u,u.bi_buf),u.bi_buf=k>>Q-u.bi_valid,u.bi_valid+=F-Q):(u.bi_buf|=k<<u.bi_valid&65535,u.bi_valid+=F)}function Ct(u,k,F){qt(u,F[k*2],F[k*2+1])}function Ft(u,k){var F=0;do F|=u&1,u>>>=1,F<<=1;while(--k>0);return F>>>1}function Ht(u){u.bi_valid===16?(te(u,u.bi_buf),u.bi_buf=0,u.bi_valid=0):u.bi_valid>=8&&(u.pending_buf[u.pending++]=u.bi_buf&255,u.bi_buf>>=8,u.bi_valid-=8)}function jt(u,k){var F=k.dyn_tree,ut=k.max_code,O=k.stat_desc.static_tree,z=k.stat_desc.has_stree,h=k.stat_desc.extra_bits,rt=k.stat_desc.extra_base,Dt=k.stat_desc.max_length,o,B,J,g,P,H,Ot=0;for(g=0;g<=X;g++)u.bl_count[g]=0;for(F[u.heap[u.heap_max]*2+1]=0,o=u.heap_max+1;o<Z;o++)B=u.heap[o],g=F[F[B*2+1]*2+1]+1,g>Dt&&(g=Dt,Ot++),F[B*2+1]=g,!(B>ut)&&(u.bl_count[g]++,P=0,B>=rt&&(P=h[B-rt]),H=F[B*2],u.opt_len+=H*(g+P),z&&(u.static_len+=H*(O[B*2+1]+P)));if(Ot!==0){do{for(g=Dt-1;u.bl_count[g]===0;)g--;u.bl_count[g]--,u.bl_count[g+1]+=2,u.bl_count[Dt]--,Ot-=2}while(Ot>0);for(g=Dt;g!==0;g--)for(B=u.bl_count[g];B!==0;)J=u.heap[--o],!(J>ut)&&(F[J*2+1]!==g&&(u.opt_len+=(g-F[J*2+1])*F[J*2],F[J*2+1]=g),B--)}}function Xt(u,k,F){var ut=new Array(X+1),O=0,z,h;for(z=1;z<=X;z++)ut[z]=O=O+F[z-1]<<1;for(h=0;h<=k;h++){var rt=u[h*2+1];rt!==0&&(u[h*2]=Ft(ut[rt]++,rt))}}function Pt(){var u,k,F,ut,O,z=new Array(X+1);for(F=0,ut=0;ut<A-1;ut++)for(it[ut]=F,u=0;u<1<<K[ut];u++)re[F++]=ut;for(re[F-1]=ut,O=0,ut=0;ut<16;ut++)for(ct[ut]=O,u=0;u<1<<gt[ut];u++)Wt[O++]=ut;for(O>>=7;ut<et;ut++)for(ct[ut]=O<<7,u=0;u<1<<gt[ut]-7;u++)Wt[256+O++]=ut;for(k=0;k<=X;k++)z[k]=0;for(u=0;u<=143;)mt[u*2+1]=8,u++,z[8]++;for(;u<=255;)mt[u*2+1]=9,u++,z[9]++;for(;u<=279;)mt[u*2+1]=7,u++,z[7]++;for(;u<=287;)mt[u*2+1]=8,u++,z[8]++;for(Xt(mt,L+1,z),u=0;u<et;u++)kt[u*2+1]=5,kt[u*2]=Ft(u,5);Ut=new ft(mt,K,U+1,L,X),Rt=new ft(kt,gt,0,et,X),Nt=new ft(new Array(0),nt,0,lt,G)}function zt(u){var k;for(k=0;k<L;k++)u.dyn_ltree[k*2]=0;for(k=0;k<et;k++)u.dyn_dtree[k*2]=0;for(k=0;k<lt;k++)u.bl_tree[k*2]=0;u.dyn_ltree[st*2]=1,u.opt_len=u.static_len=0,u.last_lit=u.matches=0}function ne(u){u.bi_valid>8?te(u,u.bi_buf):u.bi_valid>0&&(u.pending_buf[u.pending++]=u.bi_buf),u.bi_buf=0,u.bi_valid=0}function ue(u,k,F,ut){ne(u),te(u,F),te(u,~F),b.arraySet(u.pending_buf,u.window,k,F,u.pending),u.pending+=F}function Kt(u,k,F,ut){var O=k*2,z=F*2;return u[O]<u[z]||u[O]===u[z]&&ut[k]<=ut[F]}function W(u,k,F){for(var ut=u.heap[F],O=F<<1;O<=u.heap_len&&(O<u.heap_len&&Kt(k,u.heap[O+1],u.heap[O],u.depth)&&O++,!Kt(k,ut,u.heap[O],u.depth));)u.heap[F]=u.heap[O],F=O,O<<=1;u.heap[F]=ut}function Mt(u,k,F){var ut,O,z=0,h,rt;if(u.last_lit!==0)do ut=u.pending_buf[u.d_buf+z*2]<<8|u.pending_buf[u.d_buf+z*2+1],O=u.pending_buf[u.l_buf+z],z++,ut===0?Ct(u,O,k):(h=re[O],Ct(u,h+U+1,k),rt=K[h],rt!==0&&(O-=it[h],qt(u,O,rt)),ut--,h=fe(ut),Ct(u,h,F),rt=gt[h],rt!==0&&(ut-=ct[h],qt(u,ut,rt)));while(z<u.last_lit);Ct(u,st,k)}function ie(u,k){var F=k.dyn_tree,ut=k.stat_desc.static_tree,O=k.stat_desc.has_stree,z=k.stat_desc.elems,h,rt,Dt=-1,o;for(u.heap_len=0,u.heap_max=Z,h=0;h<z;h++)F[h*2]!==0?(u.heap[++u.heap_len]=Dt=h,u.depth[h]=0):F[h*2+1]=0;for(;u.heap_len<2;)o=u.heap[++u.heap_len]=Dt<2?++Dt:0,F[o*2]=1,u.depth[o]=0,u.opt_len--,O&&(u.static_len-=ut[o*2+1]);for(k.max_code=Dt,h=u.heap_len>>1;h>=1;h--)W(u,F,h);o=z;do h=u.heap[1],u.heap[1]=u.heap[u.heap_len--],W(u,F,1),rt=u.heap[1],u.heap[--u.heap_max]=h,u.heap[--u.heap_max]=rt,F[o*2]=F[h*2]+F[rt*2],u.depth[o]=(u.depth[h]>=u.depth[rt]?u.depth[h]:u.depth[rt])+1,F[h*2+1]=F[rt*2+1]=o,u.heap[1]=o++,W(u,F,1);while(u.heap_len>=2);u.heap[--u.heap_max]=u.heap[1],jt(u,k),Xt(F,Dt,u.bl_count)}function be(u,k,F){var ut,O=-1,z,h=k[1],rt=0,Dt=7,o=4;for(h===0&&(Dt=138,o=3),k[(F+1)*2+1]=65535,ut=0;ut<=F;ut++)z=h,h=k[(ut+1)*2+1],!(++rt<Dt&&z===h)&&(rt<o?u.bl_tree[z*2]+=rt:z!==0?(z!==O&&u.bl_tree[z*2]++,u.bl_tree[ht*2]++):rt<=10?u.bl_tree[pt*2]++:u.bl_tree[V*2]++,rt=0,O=z,h===0?(Dt=138,o=3):z===h?(Dt=6,o=3):(Dt=7,o=4))}function ae(u,k,F){var ut,O=-1,z,h=k[1],rt=0,Dt=7,o=4;for(h===0&&(Dt=138,o=3),ut=0;ut<=F;ut++)if(z=h,h=k[(ut+1)*2+1],!(++rt<Dt&&z===h)){if(rt<o)do Ct(u,z,u.bl_tree);while(--rt!==0);else z!==0?(z!==O&&(Ct(u,z,u.bl_tree),rt--),Ct(u,ht,u.bl_tree),qt(u,rt-3,2)):rt<=10?(Ct(u,pt,u.bl_tree),qt(u,rt-3,3)):(Ct(u,V,u.bl_tree),qt(u,rt-11,7));rt=0,O=z,h===0?(Dt=138,o=3):z===h?(Dt=6,o=3):(Dt=7,o=4)}}function Jt(u){var k;for(be(u,u.dyn_ltree,u.l_desc.max_code),be(u,u.dyn_dtree,u.d_desc.max_code),ie(u,u.bl_desc),k=lt-1;k>=3&&u.bl_tree[_t[k]*2+1]===0;k--);return u.opt_len+=3*(k+1)+5+5+4,k}function xe(u,k,F,ut){var O;for(qt(u,k-257,5),qt(u,F-1,5),qt(u,ut-4,4),O=0;O<ut;O++)qt(u,u.bl_tree[_t[O]*2+1],3);ae(u,u.dyn_ltree,k-1),ae(u,u.dyn_dtree,F-1)}function Ee(u){var k=4093624447,F;for(F=0;F<=31;F++,k>>>=1)if(k&1&&u.dyn_ltree[F*2]!==0)return j;if(u.dyn_ltree[18]!==0||u.dyn_ltree[20]!==0||u.dyn_ltree[26]!==0)return I;for(F=32;F<U;F++)if(u.dyn_ltree[F*2]!==0)return I;return j}var he=!1;function ze(u){he||(Pt(),he=!0),u.l_desc=new Zt(u.dyn_ltree,Ut),u.d_desc=new Zt(u.dyn_dtree,Rt),u.bl_desc=new Zt(u.bl_tree,Nt),u.bi_buf=0,u.bi_valid=0,zt(u)}function w(u,k,F,ut){qt(u,(R<<1)+(ut?1:0),3),ue(u,k,F)}function s(u){qt(u,m<<1,3),Ct(u,st,mt),Ht(u)}function f(u,k,F,ut){var O,z,h=0;u.level>0?(u.strm.data_type===N&&(u.strm.data_type=Ee(u)),ie(u,u.l_desc),ie(u,u.d_desc),h=Jt(u),O=u.opt_len+3+7>>>3,z=u.static_len+3+7>>>3,z<=O&&(O=z)):O=z=F+5,F+4<=O&&k!==-1?w(u,k,F,ut):u.strategy===S||z===O?(qt(u,(m<<1)+(ut?1:0),3),Mt(u,mt,kt)):(qt(u,(_<<1)+(ut?1:0),3),xe(u,u.l_desc.max_code+1,u.d_desc.max_code+1,h+1),Mt(u,u.dyn_ltree,u.dyn_dtree)),zt(u),ut&&ne(u)}function E(u,k,F){return u.pending_buf[u.d_buf+u.last_lit*2]=k>>>8&255,u.pending_buf[u.d_buf+u.last_lit*2+1]=k&255,u.pending_buf[u.l_buf+u.last_lit]=F&255,u.last_lit++,k===0?u.dyn_ltree[F*2]++:(u.matches++,k--,u.dyn_ltree[(re[F]+U+1)*2]++,u.dyn_dtree[fe(k)*2]++),u.last_lit===u.lit_bufsize-1}return cr._tr_init=ze,cr._tr_stored_block=w,cr._tr_flush_block=f,cr._tr_tally=E,cr._tr_align=s,cr}var Mi,pc;function Gc(){if(pc)return Mi;pc=1;function b(S,j,I,N){for(var T=S&65535|0,R=S>>>16&65535|0,m=0;I!==0;){m=I>2e3?2e3:I,I-=m;do T=T+j[N++]|0,R=R+T|0;while(--m);T%=65521,R%=65521}return T|R<<16|0}return Mi=b,Mi}var ji,wc;function Hc(){if(wc)return ji;wc=1;function b(){for(var I,N=[],T=0;T<256;T++){I=T;for(var R=0;R<8;R++)I=I&1?3988292384^I>>>1:I>>>1;N[T]=I}return N}var S=b();function j(I,N,T,R){var m=S,_=R+T;I^=-1;for(var D=R;D<_;D++)I=I>>>8^m[(I^N[D])&255];return I^-1}return ji=j,ji}var Li,gc;function na(){return gc||(gc=1,Li={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}),Li}var mc;function ul(){if(mc)return qe;mc=1;var b=Qe(),S=fl(),j=Gc(),I=Hc(),N=na(),T=0,R=1,m=3,_=4,D=5,C=0,A=1,U=-2,L=-3,et=-5,lt=-1,Z=1,X=2,Q=3,G=4,st=0,ht=2,pt=8,V=9,K=15,gt=8,nt=29,_t=256,dt=_t+1+nt,mt=30,kt=19,Wt=2*dt+1,re=15,it=3,ct=258,ft=ct+it+1,Ut=32,Rt=42,Nt=69,Zt=73,fe=91,te=103,qt=113,Ct=666,Ft=1,Ht=2,jt=3,Xt=4,Pt=3;function zt(o,B){return o.msg=N[B],B}function ne(o){return(o<<1)-(o>4?9:0)}function ue(o){for(var B=o.length;--B>=0;)o[B]=0}function Kt(o){var B=o.state,J=B.pending;J>o.avail_out&&(J=o.avail_out),J!==0&&(b.arraySet(o.output,B.pending_buf,B.pending_out,J,o.next_out),o.next_out+=J,B.pending_out+=J,o.total_out+=J,o.avail_out-=J,B.pending-=J,B.pending===0&&(B.pending_out=0))}function W(o,B){S._tr_flush_block(o,o.block_start>=0?o.block_start:-1,o.strstart-o.block_start,B),o.block_start=o.strstart,Kt(o.strm)}function Mt(o,B){o.pending_buf[o.pending++]=B}function ie(o,B){o.pending_buf[o.pending++]=B>>>8&255,o.pending_buf[o.pending++]=B&255}function be(o,B,J,g){var P=o.avail_in;return P>g&&(P=g),P===0?0:(o.avail_in-=P,b.arraySet(B,o.input,o.next_in,P,J),o.state.wrap===1?o.adler=j(o.adler,B,P,J):o.state.wrap===2&&(o.adler=I(o.adler,B,P,J)),o.next_in+=P,o.total_in+=P,P)}function ae(o,B){var J=o.max_chain_length,g=o.strstart,P,H,Ot=o.prev_length,St=o.nice_match,bt=o.strstart>o.w_size-ft?o.strstart-(o.w_size-ft):0,Gt=o.window,Fe=o.w_mask,se=o.prev,Vt=o.strstart+ct,de=Gt[g+Ot-1],ge=Gt[g+Ot];o.prev_length>=o.good_match&&(J>>=2),St>o.lookahead&&(St=o.lookahead);do if(P=B,!(Gt[P+Ot]!==ge||Gt[P+Ot-1]!==de||Gt[P]!==Gt[g]||Gt[++P]!==Gt[g+1])){g+=2,P++;do;while(Gt[++g]===Gt[++P]&&Gt[++g]===Gt[++P]&&Gt[++g]===Gt[++P]&&Gt[++g]===Gt[++P]&&Gt[++g]===Gt[++P]&&Gt[++g]===Gt[++P]&&Gt[++g]===Gt[++P]&&Gt[++g]===Gt[++P]&&g<Vt);if(H=ct-(Vt-g),g=Vt-ct,H>Ot){if(o.match_start=B,Ot=H,H>=St)break;de=Gt[g+Ot-1],ge=Gt[g+Ot]}}while((B=se[B&Fe])>bt&&--J!==0);return Ot<=o.lookahead?Ot:o.lookahead}function Jt(o){var B=o.w_size,J,g,P,H,Ot;do{if(H=o.window_size-o.lookahead-o.strstart,o.strstart>=B+(B-ft)){b.arraySet(o.window,o.window,B,B,0),o.match_start-=B,o.strstart-=B,o.block_start-=B,g=o.hash_size,J=g;do P=o.head[--J],o.head[J]=P>=B?P-B:0;while(--g);g=B,J=g;do P=o.prev[--J],o.prev[J]=P>=B?P-B:0;while(--g);H+=B}if(o.strm.avail_in===0)break;if(g=be(o.strm,o.window,o.strstart+o.lookahead,H),o.lookahead+=g,o.lookahead+o.insert>=it)for(Ot=o.strstart-o.insert,o.ins_h=o.window[Ot],o.ins_h=(o.ins_h<<o.hash_shift^o.window[Ot+1])&o.hash_mask;o.insert&&(o.ins_h=(o.ins_h<<o.hash_shift^o.window[Ot+it-1])&o.hash_mask,o.prev[Ot&o.w_mask]=o.head[o.ins_h],o.head[o.ins_h]=Ot,Ot++,o.insert--,!(o.lookahead+o.insert<it)););}while(o.lookahead<ft&&o.strm.avail_in!==0)}function xe(o,B){var J=65535;for(J>o.pending_buf_size-5&&(J=o.pending_buf_size-5);;){if(o.lookahead<=1){if(Jt(o),o.lookahead===0&&B===T)return Ft;if(o.lookahead===0)break}o.strstart+=o.lookahead,o.lookahead=0;var g=o.block_start+J;if((o.strstart===0||o.strstart>=g)&&(o.lookahead=o.strstart-g,o.strstart=g,W(o,!1),o.strm.avail_out===0)||o.strstart-o.block_start>=o.w_size-ft&&(W(o,!1),o.strm.avail_out===0))return Ft}return o.insert=0,B===_?(W(o,!0),o.strm.avail_out===0?jt:Xt):(o.strstart>o.block_start&&(W(o,!1),o.strm.avail_out===0),Ft)}function Ee(o,B){for(var J,g;;){if(o.lookahead<ft){if(Jt(o),o.lookahead<ft&&B===T)return Ft;if(o.lookahead===0)break}if(J=0,o.lookahead>=it&&(o.ins_h=(o.ins_h<<o.hash_shift^o.window[o.strstart+it-1])&o.hash_mask,J=o.prev[o.strstart&o.w_mask]=o.head[o.ins_h],o.head[o.ins_h]=o.strstart),J!==0&&o.strstart-J<=o.w_size-ft&&(o.match_length=ae(o,J)),o.match_length>=it)if(g=S._tr_tally(o,o.strstart-o.match_start,o.match_length-it),o.lookahead-=o.match_length,o.match_length<=o.max_lazy_match&&o.lookahead>=it){o.match_length--;do o.strstart++,o.ins_h=(o.ins_h<<o.hash_shift^o.window[o.strstart+it-1])&o.hash_mask,J=o.prev[o.strstart&o.w_mask]=o.head[o.ins_h],o.head[o.ins_h]=o.strstart;while(--o.match_length!==0);o.strstart++}else o.strstart+=o.match_length,o.match_length=0,o.ins_h=o.window[o.strstart],o.ins_h=(o.ins_h<<o.hash_shift^o.window[o.strstart+1])&o.hash_mask;else g=S._tr_tally(o,0,o.window[o.strstart]),o.lookahead--,o.strstart++;if(g&&(W(o,!1),o.strm.avail_out===0))return Ft}return o.insert=o.strstart<it-1?o.strstart:it-1,B===_?(W(o,!0),o.strm.avail_out===0?jt:Xt):o.last_lit&&(W(o,!1),o.strm.avail_out===0)?Ft:Ht}function he(o,B){for(var J,g,P;;){if(o.lookahead<ft){if(Jt(o),o.lookahead<ft&&B===T)return Ft;if(o.lookahead===0)break}if(J=0,o.lookahead>=it&&(o.ins_h=(o.ins_h<<o.hash_shift^o.window[o.strstart+it-1])&o.hash_mask,J=o.prev[o.strstart&o.w_mask]=o.head[o.ins_h],o.head[o.ins_h]=o.strstart),o.prev_length=o.match_length,o.prev_match=o.match_start,o.match_length=it-1,J!==0&&o.prev_length<o.max_lazy_match&&o.strstart-J<=o.w_size-ft&&(o.match_length=ae(o,J),o.match_length<=5&&(o.strategy===Z||o.match_length===it&&o.strstart-o.match_start>4096)&&(o.match_length=it-1)),o.prev_length>=it&&o.match_length<=o.prev_length){P=o.strstart+o.lookahead-it,g=S._tr_tally(o,o.strstart-1-o.prev_match,o.prev_length-it),o.lookahead-=o.prev_length-1,o.prev_length-=2;do++o.strstart<=P&&(o.ins_h=(o.ins_h<<o.hash_shift^o.window[o.strstart+it-1])&o.hash_mask,J=o.prev[o.strstart&o.w_mask]=o.head[o.ins_h],o.head[o.ins_h]=o.strstart);while(--o.prev_length!==0);if(o.match_available=0,o.match_length=it-1,o.strstart++,g&&(W(o,!1),o.strm.avail_out===0))return Ft}else if(o.match_available){if(g=S._tr_tally(o,0,o.window[o.strstart-1]),g&&W(o,!1),o.strstart++,o.lookahead--,o.strm.avail_out===0)return Ft}else o.match_available=1,o.strstart++,o.lookahead--}return o.match_available&&(g=S._tr_tally(o,0,o.window[o.strstart-1]),o.match_available=0),o.insert=o.strstart<it-1?o.strstart:it-1,B===_?(W(o,!0),o.strm.avail_out===0?jt:Xt):o.last_lit&&(W(o,!1),o.strm.avail_out===0)?Ft:Ht}function ze(o,B){for(var J,g,P,H,Ot=o.window;;){if(o.lookahead<=ct){if(Jt(o),o.lookahead<=ct&&B===T)return Ft;if(o.lookahead===0)break}if(o.match_length=0,o.lookahead>=it&&o.strstart>0&&(P=o.strstart-1,g=Ot[P],g===Ot[++P]&&g===Ot[++P]&&g===Ot[++P])){H=o.strstart+ct;do;while(g===Ot[++P]&&g===Ot[++P]&&g===Ot[++P]&&g===Ot[++P]&&g===Ot[++P]&&g===Ot[++P]&&g===Ot[++P]&&g===Ot[++P]&&P<H);o.match_length=ct-(H-P),o.match_length>o.lookahead&&(o.match_length=o.lookahead)}if(o.match_length>=it?(J=S._tr_tally(o,1,o.match_length-it),o.lookahead-=o.match_length,o.strstart+=o.match_length,o.match_length=0):(J=S._tr_tally(o,0,o.window[o.strstart]),o.lookahead--,o.strstart++),J&&(W(o,!1),o.strm.avail_out===0))return Ft}return o.insert=0,B===_?(W(o,!0),o.strm.avail_out===0?jt:Xt):o.last_lit&&(W(o,!1),o.strm.avail_out===0)?Ft:Ht}function w(o,B){for(var J;;){if(o.lookahead===0&&(Jt(o),o.lookahead===0)){if(B===T)return Ft;break}if(o.match_length=0,J=S._tr_tally(o,0,o.window[o.strstart]),o.lookahead--,o.strstart++,J&&(W(o,!1),o.strm.avail_out===0))return Ft}return o.insert=0,B===_?(W(o,!0),o.strm.avail_out===0?jt:Xt):o.last_lit&&(W(o,!1),o.strm.avail_out===0)?Ft:Ht}function s(o,B,J,g,P){this.good_length=o,this.max_lazy=B,this.nice_length=J,this.max_chain=g,this.func=P}var f;f=[new s(0,0,0,0,xe),new s(4,4,8,4,Ee),new s(4,5,16,8,Ee),new s(4,6,32,32,Ee),new s(4,4,16,16,he),new s(8,16,32,32,he),new s(8,16,128,128,he),new s(8,32,128,256,he),new s(32,128,258,1024,he),new s(32,258,258,4096,he)];function E(o){o.window_size=2*o.w_size,ue(o.head),o.max_lazy_match=f[o.level].max_lazy,o.good_match=f[o.level].good_length,o.nice_match=f[o.level].nice_length,o.max_chain_length=f[o.level].max_chain,o.strstart=0,o.block_start=0,o.lookahead=0,o.insert=0,o.match_length=o.prev_length=it-1,o.match_available=0,o.ins_h=0}function u(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=pt,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new b.Buf16(Wt*2),this.dyn_dtree=new b.Buf16((2*mt+1)*2),this.bl_tree=new b.Buf16((2*kt+1)*2),ue(this.dyn_ltree),ue(this.dyn_dtree),ue(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new b.Buf16(re+1),this.heap=new b.Buf16(2*dt+1),ue(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new b.Buf16(2*dt+1),ue(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function k(o){var B;return!o||!o.state?zt(o,U):(o.total_in=o.total_out=0,o.data_type=ht,B=o.state,B.pending=0,B.pending_out=0,B.wrap<0&&(B.wrap=-B.wrap),B.status=B.wrap?Rt:qt,o.adler=B.wrap===2?0:1,B.last_flush=T,S._tr_init(B),C)}function F(o){var B=k(o);return B===C&&E(o.state),B}function ut(o,B){return!o||!o.state||o.state.wrap!==2?U:(o.state.gzhead=B,C)}function O(o,B,J,g,P,H){if(!o)return U;var Ot=1;if(B===lt&&(B=6),g<0?(Ot=0,g=-g):g>15&&(Ot=2,g-=16),P<1||P>V||J!==pt||g<8||g>15||B<0||B>9||H<0||H>G)return zt(o,U);g===8&&(g=9);var St=new u;return o.state=St,St.strm=o,St.wrap=Ot,St.gzhead=null,St.w_bits=g,St.w_size=1<<St.w_bits,St.w_mask=St.w_size-1,St.hash_bits=P+7,St.hash_size=1<<St.hash_bits,St.hash_mask=St.hash_size-1,St.hash_shift=~~((St.hash_bits+it-1)/it),St.window=new b.Buf8(St.w_size*2),St.head=new b.Buf16(St.hash_size),St.prev=new b.Buf16(St.w_size),St.lit_bufsize=1<<P+6,St.pending_buf_size=St.lit_bufsize*4,St.pending_buf=new b.Buf8(St.pending_buf_size),St.d_buf=1*St.lit_bufsize,St.l_buf=3*St.lit_bufsize,St.level=B,St.strategy=H,St.method=J,F(o)}function z(o,B){return O(o,B,pt,K,gt,st)}function h(o,B){var J,g,P,H;if(!o||!o.state||B>D||B<0)return o?zt(o,U):U;if(g=o.state,!o.output||!o.input&&o.avail_in!==0||g.status===Ct&&B!==_)return zt(o,o.avail_out===0?et:U);if(g.strm=o,J=g.last_flush,g.last_flush=B,g.status===Rt)if(g.wrap===2)o.adler=0,Mt(g,31),Mt(g,139),Mt(g,8),g.gzhead?(Mt(g,(g.gzhead.text?1:0)+(g.gzhead.hcrc?2:0)+(g.gzhead.extra?4:0)+(g.gzhead.name?8:0)+(g.gzhead.comment?16:0)),Mt(g,g.gzhead.time&255),Mt(g,g.gzhead.time>>8&255),Mt(g,g.gzhead.time>>16&255),Mt(g,g.gzhead.time>>24&255),Mt(g,g.level===9?2:g.strategy>=X||g.level<2?4:0),Mt(g,g.gzhead.os&255),g.gzhead.extra&&g.gzhead.extra.length&&(Mt(g,g.gzhead.extra.length&255),Mt(g,g.gzhead.extra.length>>8&255)),g.gzhead.hcrc&&(o.adler=I(o.adler,g.pending_buf,g.pending,0)),g.gzindex=0,g.status=Nt):(Mt(g,0),Mt(g,0),Mt(g,0),Mt(g,0),Mt(g,0),Mt(g,g.level===9?2:g.strategy>=X||g.level<2?4:0),Mt(g,Pt),g.status=qt);else{var Ot=pt+(g.w_bits-8<<4)<<8,St=-1;g.strategy>=X||g.level<2?St=0:g.level<6?St=1:g.level===6?St=2:St=3,Ot|=St<<6,g.strstart!==0&&(Ot|=Ut),Ot+=31-Ot%31,g.status=qt,ie(g,Ot),g.strstart!==0&&(ie(g,o.adler>>>16),ie(g,o.adler&65535)),o.adler=1}if(g.status===Nt)if(g.gzhead.extra){for(P=g.pending;g.gzindex<(g.gzhead.extra.length&65535)&&!(g.pending===g.pending_buf_size&&(g.gzhead.hcrc&&g.pending>P&&(o.adler=I(o.adler,g.pending_buf,g.pending-P,P)),Kt(o),P=g.pending,g.pending===g.pending_buf_size));)Mt(g,g.gzhead.extra[g.gzindex]&255),g.gzindex++;g.gzhead.hcrc&&g.pending>P&&(o.adler=I(o.adler,g.pending_buf,g.pending-P,P)),g.gzindex===g.gzhead.extra.length&&(g.gzindex=0,g.status=Zt)}else g.status=Zt;if(g.status===Zt)if(g.gzhead.name){P=g.pending;do{if(g.pending===g.pending_buf_size&&(g.gzhead.hcrc&&g.pending>P&&(o.adler=I(o.adler,g.pending_buf,g.pending-P,P)),Kt(o),P=g.pending,g.pending===g.pending_buf_size)){H=1;break}g.gzindex<g.gzhead.name.length?H=g.gzhead.name.charCodeAt(g.gzindex++)&255:H=0,Mt(g,H)}while(H!==0);g.gzhead.hcrc&&g.pending>P&&(o.adler=I(o.adler,g.pending_buf,g.pending-P,P)),H===0&&(g.gzindex=0,g.status=fe)}else g.status=fe;if(g.status===fe)if(g.gzhead.comment){P=g.pending;do{if(g.pending===g.pending_buf_size&&(g.gzhead.hcrc&&g.pending>P&&(o.adler=I(o.adler,g.pending_buf,g.pending-P,P)),Kt(o),P=g.pending,g.pending===g.pending_buf_size)){H=1;break}g.gzindex<g.gzhead.comment.length?H=g.gzhead.comment.charCodeAt(g.gzindex++)&255:H=0,Mt(g,H)}while(H!==0);g.gzhead.hcrc&&g.pending>P&&(o.adler=I(o.adler,g.pending_buf,g.pending-P,P)),H===0&&(g.status=te)}else g.status=te;if(g.status===te&&(g.gzhead.hcrc?(g.pending+2>g.pending_buf_size&&Kt(o),g.pending+2<=g.pending_buf_size&&(Mt(g,o.adler&255),Mt(g,o.adler>>8&255),o.adler=0,g.status=qt)):g.status=qt),g.pending!==0){if(Kt(o),o.avail_out===0)return g.last_flush=-1,C}else if(o.avail_in===0&&ne(B)<=ne(J)&&B!==_)return zt(o,et);if(g.status===Ct&&o.avail_in!==0)return zt(o,et);if(o.avail_in!==0||g.lookahead!==0||B!==T&&g.status!==Ct){var bt=g.strategy===X?w(g,B):g.strategy===Q?ze(g,B):f[g.level].func(g,B);if((bt===jt||bt===Xt)&&(g.status=Ct),bt===Ft||bt===jt)return o.avail_out===0&&(g.last_flush=-1),C;if(bt===Ht&&(B===R?S._tr_align(g):B!==D&&(S._tr_stored_block(g,0,0,!1),B===m&&(ue(g.head),g.lookahead===0&&(g.strstart=0,g.block_start=0,g.insert=0))),Kt(o),o.avail_out===0))return g.last_flush=-1,C}return B!==_?C:g.wrap<=0?A:(g.wrap===2?(Mt(g,o.adler&255),Mt(g,o.adler>>8&255),Mt(g,o.adler>>16&255),Mt(g,o.adler>>24&255),Mt(g,o.total_in&255),Mt(g,o.total_in>>8&255),Mt(g,o.total_in>>16&255),Mt(g,o.total_in>>24&255)):(ie(g,o.adler>>>16),ie(g,o.adler&65535)),Kt(o),g.wrap>0&&(g.wrap=-g.wrap),g.pending!==0?C:A)}function rt(o){var B;return!o||!o.state?U:(B=o.state.status,B!==Rt&&B!==Nt&&B!==Zt&&B!==fe&&B!==te&&B!==qt&&B!==Ct?zt(o,U):(o.state=null,B===qt?zt(o,L):C))}function Dt(o,B){var J=B.length,g,P,H,Ot,St,bt,Gt,Fe;if(!o||!o.state||(g=o.state,Ot=g.wrap,Ot===2||Ot===1&&g.status!==Rt||g.lookahead))return U;for(Ot===1&&(o.adler=j(o.adler,B,J,0)),g.wrap=0,J>=g.w_size&&(Ot===0&&(ue(g.head),g.strstart=0,g.block_start=0,g.insert=0),Fe=new b.Buf8(g.w_size),b.arraySet(Fe,B,J-g.w_size,g.w_size,0),B=Fe,J=g.w_size),St=o.avail_in,bt=o.next_in,Gt=o.input,o.avail_in=J,o.next_in=0,o.input=B,Jt(g);g.lookahead>=it;){P=g.strstart,H=g.lookahead-(it-1);do g.ins_h=(g.ins_h<<g.hash_shift^g.window[P+it-1])&g.hash_mask,g.prev[P&g.w_mask]=g.head[g.ins_h],g.head[g.ins_h]=P,P++;while(--H);g.strstart=P,g.lookahead=it-1,Jt(g)}return g.strstart+=g.lookahead,g.block_start=g.strstart,g.insert=g.lookahead,g.lookahead=0,g.match_length=g.prev_length=it-1,g.match_available=0,o.next_in=bt,o.input=Gt,o.avail_in=St,g.wrap=Ot,C}return qe.deflateInit=z,qe.deflateInit2=O,qe.deflateReset=F,qe.deflateResetKeep=k,qe.deflateSetHeader=ut,qe.deflate=h,qe.deflateEnd=rt,qe.deflateSetDictionary=Dt,qe.deflateInfo="pako deflate (from Nodeca project)",qe}var fr={},yc;function Zc(){if(yc)return fr;yc=1;var b=Qe(),S=!0,j=!0;try{String.fromCharCode.apply(null,[0])}catch{S=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch{j=!1}for(var I=new b.Buf8(256),N=0;N<256;N++)I[N]=N>=252?6:N>=248?5:N>=240?4:N>=224?3:N>=192?2:1;I[254]=I[254]=1,fr.string2buf=function(R){var m,_,D,C,A,U=R.length,L=0;for(C=0;C<U;C++)_=R.charCodeAt(C),(_&64512)===55296&&C+1<U&&(D=R.charCodeAt(C+1),(D&64512)===56320&&(_=65536+(_-55296<<10)+(D-56320),C++)),L+=_<128?1:_<2048?2:_<65536?3:4;for(m=new b.Buf8(L),A=0,C=0;A<L;C++)_=R.charCodeAt(C),(_&64512)===55296&&C+1<U&&(D=R.charCodeAt(C+1),(D&64512)===56320&&(_=65536+(_-55296<<10)+(D-56320),C++)),_<128?m[A++]=_:_<2048?(m[A++]=192|_>>>6,m[A++]=128|_&63):_<65536?(m[A++]=224|_>>>12,m[A++]=128|_>>>6&63,m[A++]=128|_&63):(m[A++]=240|_>>>18,m[A++]=128|_>>>12&63,m[A++]=128|_>>>6&63,m[A++]=128|_&63);return m};function T(R,m){if(m<65534&&(R.subarray&&j||!R.subarray&&S))return String.fromCharCode.apply(null,b.shrinkBuf(R,m));for(var _="",D=0;D<m;D++)_+=String.fromCharCode(R[D]);return _}return fr.buf2binstring=function(R){return T(R,R.length)},fr.binstring2buf=function(R){for(var m=new b.Buf8(R.length),_=0,D=m.length;_<D;_++)m[_]=R.charCodeAt(_);return m},fr.buf2string=function(R,m){var _,D,C,A,U=m||R.length,L=new Array(U*2);for(D=0,_=0;_<U;){if(C=R[_++],C<128){L[D++]=C;continue}if(A=I[C],A>4){L[D++]=65533,_+=A-1;continue}for(C&=A===2?31:A===3?15:7;A>1&&_<U;)C=C<<6|R[_++]&63,A--;if(A>1){L[D++]=65533;continue}C<65536?L[D++]=C:(C-=65536,L[D++]=55296|C>>10&1023,L[D++]=56320|C&1023)}return T(L,D)},fr.utf8border=function(R,m){var _;for(m=m||R.length,m>R.length&&(m=R.length),_=m-1;_>=0&&(R[_]&192)===128;)_--;return _<0||_===0?m:_+I[R[_]]>m?_:m},fr}var qi,_c;function Wc(){if(_c)return qi;_c=1;function b(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}return qi=b,qi}var vc;function ll(){if(vc)return Sr;vc=1;var b=ul(),S=Qe(),j=Zc(),I=na(),N=Wc(),T=Object.prototype.toString,R=0,m=4,_=0,D=1,C=2,A=-1,U=0,L=8;function et(Q){if(!(this instanceof et))return new et(Q);this.options=S.assign({level:A,method:L,chunkSize:16384,windowBits:15,memLevel:8,strategy:U,to:""},Q||{});var G=this.options;G.raw&&G.windowBits>0?G.windowBits=-G.windowBits:G.gzip&&G.windowBits>0&&G.windowBits<16&&(G.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new N,this.strm.avail_out=0;var st=b.deflateInit2(this.strm,G.level,G.method,G.windowBits,G.memLevel,G.strategy);if(st!==_)throw new Error(I[st]);if(G.header&&b.deflateSetHeader(this.strm,G.header),G.dictionary){var ht;if(typeof G.dictionary=="string"?ht=j.string2buf(G.dictionary):T.call(G.dictionary)==="[object ArrayBuffer]"?ht=new Uint8Array(G.dictionary):ht=G.dictionary,st=b.deflateSetDictionary(this.strm,ht),st!==_)throw new Error(I[st]);this._dict_set=!0}}et.prototype.push=function(Q,G){var st=this.strm,ht=this.options.chunkSize,pt,V;if(this.ended)return!1;V=G===~~G?G:G===!0?m:R,typeof Q=="string"?st.input=j.string2buf(Q):T.call(Q)==="[object ArrayBuffer]"?st.input=new Uint8Array(Q):st.input=Q,st.next_in=0,st.avail_in=st.input.length;do{if(st.avail_out===0&&(st.output=new S.Buf8(ht),st.next_out=0,st.avail_out=ht),pt=b.deflate(st,V),pt!==D&&pt!==_)return this.onEnd(pt),this.ended=!0,!1;(st.avail_out===0||st.avail_in===0&&(V===m||V===C))&&(this.options.to==="string"?this.onData(j.buf2binstring(S.shrinkBuf(st.output,st.next_out))):this.onData(S.shrinkBuf(st.output,st.next_out)))}while((st.avail_in>0||st.avail_out===0)&&pt!==D);return V===m?(pt=b.deflateEnd(this.strm),this.onEnd(pt),this.ended=!0,pt===_):(V===C&&(this.onEnd(_),st.avail_out=0),!0)},et.prototype.onData=function(Q){this.chunks.push(Q)},et.prototype.onEnd=function(Q){Q===_&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=S.flattenChunks(this.chunks)),this.chunks=[],this.err=Q,this.msg=this.strm.msg};function lt(Q,G){var st=new et(G);if(st.push(Q,!0),st.err)throw st.msg||I[st.err];return st.result}function Z(Q,G){return G=G||{},G.raw=!0,lt(Q,G)}function X(Q,G){return G=G||{},G.gzip=!0,lt(Q,G)}return Sr.Deflate=et,Sr.deflate=lt,Sr.deflateRaw=Z,Sr.gzip=X,Sr}var Ar={},Me={},zi,bc;function hl(){if(bc)return zi;bc=1;var b=30,S=12;return zi=function(I,N){var T,R,m,_,D,C,A,U,L,et,lt,Z,X,Q,G,st,ht,pt,V,K,gt,nt,_t,dt,mt;T=I.state,R=I.next_in,dt=I.input,m=R+(I.avail_in-5),_=I.next_out,mt=I.output,D=_-(N-I.avail_out),C=_+(I.avail_out-257),A=T.dmax,U=T.wsize,L=T.whave,et=T.wnext,lt=T.window,Z=T.hold,X=T.bits,Q=T.lencode,G=T.distcode,st=(1<<T.lenbits)-1,ht=(1<<T.distbits)-1;t:do{X<15&&(Z+=dt[R++]<<X,X+=8,Z+=dt[R++]<<X,X+=8),pt=Q[Z&st];e:for(;;){if(V=pt>>>24,Z>>>=V,X-=V,V=pt>>>16&255,V===0)mt[_++]=pt&65535;else if(V&16){K=pt&65535,V&=15,V&&(X<V&&(Z+=dt[R++]<<X,X+=8),K+=Z&(1<<V)-1,Z>>>=V,X-=V),X<15&&(Z+=dt[R++]<<X,X+=8,Z+=dt[R++]<<X,X+=8),pt=G[Z&ht];r:for(;;){if(V=pt>>>24,Z>>>=V,X-=V,V=pt>>>16&255,V&16){if(gt=pt&65535,V&=15,X<V&&(Z+=dt[R++]<<X,X+=8,X<V&&(Z+=dt[R++]<<X,X+=8)),gt+=Z&(1<<V)-1,gt>A){I.msg="invalid distance too far back",T.mode=b;break t}if(Z>>>=V,X-=V,V=_-D,gt>V){if(V=gt-V,V>L&&T.sane){I.msg="invalid distance too far back",T.mode=b;break t}if(nt=0,_t=lt,et===0){if(nt+=U-V,V<K){K-=V;do mt[_++]=lt[nt++];while(--V);nt=_-gt,_t=mt}}else if(et<V){if(nt+=U+et-V,V-=et,V<K){K-=V;do mt[_++]=lt[nt++];while(--V);if(nt=0,et<K){V=et,K-=V;do mt[_++]=lt[nt++];while(--V);nt=_-gt,_t=mt}}}else if(nt+=et-V,V<K){K-=V;do mt[_++]=lt[nt++];while(--V);nt=_-gt,_t=mt}for(;K>2;)mt[_++]=_t[nt++],mt[_++]=_t[nt++],mt[_++]=_t[nt++],K-=3;K&&(mt[_++]=_t[nt++],K>1&&(mt[_++]=_t[nt++]))}else{nt=_-gt;do mt[_++]=mt[nt++],mt[_++]=mt[nt++],mt[_++]=mt[nt++],K-=3;while(K>2);K&&(mt[_++]=mt[nt++],K>1&&(mt[_++]=mt[nt++]))}}else if((V&64)===0){pt=G[(pt&65535)+(Z&(1<<V)-1)];continue r}else{I.msg="invalid distance code",T.mode=b;break t}break}}else if((V&64)===0){pt=Q[(pt&65535)+(Z&(1<<V)-1)];continue e}else if(V&32){T.mode=S;break t}else{I.msg="invalid literal/length code",T.mode=b;break t}break}}while(R<m&&_<C);K=X>>3,R-=K,X-=K<<3,Z&=(1<<X)-1,I.next_in=R,I.next_out=_,I.avail_in=R<m?5+(m-R):5-(R-m),I.avail_out=_<C?257+(C-_):257-(_-C),T.hold=Z,T.bits=X},zi}var Gi,xc;function dl(){if(xc)return Gi;xc=1;var b=Qe(),S=15,j=852,I=592,N=0,T=1,R=2,m=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],_=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],D=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],C=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];return Gi=function(U,L,et,lt,Z,X,Q,G){var st=G.bits,ht=0,pt=0,V=0,K=0,gt=0,nt=0,_t=0,dt=0,mt=0,kt=0,Wt,re,it,ct,ft,Ut=null,Rt=0,Nt,Zt=new b.Buf16(S+1),fe=new b.Buf16(S+1),te=null,qt=0,Ct,Ft,Ht;for(ht=0;ht<=S;ht++)Zt[ht]=0;for(pt=0;pt<lt;pt++)Zt[L[et+pt]]++;for(gt=st,K=S;K>=1&&Zt[K]===0;K--);if(gt>K&&(gt=K),K===0)return Z[X++]=1<<24|64<<16|0,Z[X++]=1<<24|64<<16|0,G.bits=1,0;for(V=1;V<K&&Zt[V]===0;V++);for(gt<V&&(gt=V),dt=1,ht=1;ht<=S;ht++)if(dt<<=1,dt-=Zt[ht],dt<0)return-1;if(dt>0&&(U===N||K!==1))return-1;for(fe[1]=0,ht=1;ht<S;ht++)fe[ht+1]=fe[ht]+Zt[ht];for(pt=0;pt<lt;pt++)L[et+pt]!==0&&(Q[fe[L[et+pt]]++]=pt);if(U===N?(Ut=te=Q,Nt=19):U===T?(Ut=m,Rt-=257,te=_,qt-=257,Nt=256):(Ut=D,te=C,Nt=-1),kt=0,pt=0,ht=V,ft=X,nt=gt,_t=0,it=-1,mt=1<<gt,ct=mt-1,U===T&&mt>j||U===R&&mt>I)return 1;for(;;){Ct=ht-_t,Q[pt]<Nt?(Ft=0,Ht=Q[pt]):Q[pt]>Nt?(Ft=te[qt+Q[pt]],Ht=Ut[Rt+Q[pt]]):(Ft=96,Ht=0),Wt=1<<ht-_t,re=1<<nt,V=re;do re-=Wt,Z[ft+(kt>>_t)+re]=Ct<<24|Ft<<16|Ht|0;while(re!==0);for(Wt=1<<ht-1;kt&Wt;)Wt>>=1;if(Wt!==0?(kt&=Wt-1,kt+=Wt):kt=0,pt++,--Zt[ht]===0){if(ht===K)break;ht=L[et+Q[pt]]}if(ht>gt&&(kt&ct)!==it){for(_t===0&&(_t=gt),ft+=V,nt=ht-_t,dt=1<<nt;nt+_t<K&&(dt-=Zt[nt+_t],!(dt<=0));)nt++,dt<<=1;if(mt+=1<<nt,U===T&&mt>j||U===R&&mt>I)return 1;it=kt&ct,Z[it]=gt<<24|nt<<16|ft-X|0}}return kt!==0&&(Z[ft+kt]=ht-_t<<24|64<<16|0),G.bits=gt,0},Gi}var Ec;function pl(){if(Ec)return Me;Ec=1;var b=Qe(),S=Gc(),j=Hc(),I=hl(),N=dl(),T=0,R=1,m=2,_=4,D=5,C=6,A=0,U=1,L=2,et=-2,lt=-3,Z=-4,X=-5,Q=8,G=1,st=2,ht=3,pt=4,V=5,K=6,gt=7,nt=8,_t=9,dt=10,mt=11,kt=12,Wt=13,re=14,it=15,ct=16,ft=17,Ut=18,Rt=19,Nt=20,Zt=21,fe=22,te=23,qt=24,Ct=25,Ft=26,Ht=27,jt=28,Xt=29,Pt=30,zt=31,ne=32,ue=852,Kt=592,W=15,Mt=W;function ie(O){return(O>>>24&255)+(O>>>8&65280)+((O&65280)<<8)+((O&255)<<24)}function be(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new b.Buf16(320),this.work=new b.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function ae(O){var z;return!O||!O.state?et:(z=O.state,O.total_in=O.total_out=z.total=0,O.msg="",z.wrap&&(O.adler=z.wrap&1),z.mode=G,z.last=0,z.havedict=0,z.dmax=32768,z.head=null,z.hold=0,z.bits=0,z.lencode=z.lendyn=new b.Buf32(ue),z.distcode=z.distdyn=new b.Buf32(Kt),z.sane=1,z.back=-1,A)}function Jt(O){var z;return!O||!O.state?et:(z=O.state,z.wsize=0,z.whave=0,z.wnext=0,ae(O))}function xe(O,z){var h,rt;return!O||!O.state||(rt=O.state,z<0?(h=0,z=-z):(h=(z>>4)+1,z<48&&(z&=15)),z&&(z<8||z>15))?et:(rt.window!==null&&rt.wbits!==z&&(rt.window=null),rt.wrap=h,rt.wbits=z,Jt(O))}function Ee(O,z){var h,rt;return O?(rt=new be,O.state=rt,rt.window=null,h=xe(O,z),h!==A&&(O.state=null),h):et}function he(O){return Ee(O,Mt)}var ze=!0,w,s;function f(O){if(ze){var z;for(w=new b.Buf32(512),s=new b.Buf32(32),z=0;z<144;)O.lens[z++]=8;for(;z<256;)O.lens[z++]=9;for(;z<280;)O.lens[z++]=7;for(;z<288;)O.lens[z++]=8;for(N(R,O.lens,0,288,w,0,O.work,{bits:9}),z=0;z<32;)O.lens[z++]=5;N(m,O.lens,0,32,s,0,O.work,{bits:5}),ze=!1}O.lencode=w,O.lenbits=9,O.distcode=s,O.distbits=5}function E(O,z,h,rt){var Dt,o=O.state;return o.window===null&&(o.wsize=1<<o.wbits,o.wnext=0,o.whave=0,o.window=new b.Buf8(o.wsize)),rt>=o.wsize?(b.arraySet(o.window,z,h-o.wsize,o.wsize,0),o.wnext=0,o.whave=o.wsize):(Dt=o.wsize-o.wnext,Dt>rt&&(Dt=rt),b.arraySet(o.window,z,h-rt,Dt,o.wnext),rt-=Dt,rt?(b.arraySet(o.window,z,h-rt,rt,0),o.wnext=rt,o.whave=o.wsize):(o.wnext+=Dt,o.wnext===o.wsize&&(o.wnext=0),o.whave<o.wsize&&(o.whave+=Dt))),0}function u(O,z){var h,rt,Dt,o,B,J,g,P,H,Ot,St,bt,Gt,Fe,se=0,Vt,de,ge,ke,tr,er,pe,Te,me=new b.Buf8(4),De,Ue,Jr=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!O||!O.state||!O.output||!O.input&&O.avail_in!==0)return et;h=O.state,h.mode===kt&&(h.mode=Wt),B=O.next_out,Dt=O.output,g=O.avail_out,o=O.next_in,rt=O.input,J=O.avail_in,P=h.hold,H=h.bits,Ot=J,St=g,Te=A;t:for(;;)switch(h.mode){case G:if(h.wrap===0){h.mode=Wt;break}for(;H<16;){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}if(h.wrap&2&&P===35615){h.check=0,me[0]=P&255,me[1]=P>>>8&255,h.check=j(h.check,me,2,0),P=0,H=0,h.mode=st;break}if(h.flags=0,h.head&&(h.head.done=!1),!(h.wrap&1)||(((P&255)<<8)+(P>>8))%31){O.msg="incorrect header check",h.mode=Pt;break}if((P&15)!==Q){O.msg="unknown compression method",h.mode=Pt;break}if(P>>>=4,H-=4,pe=(P&15)+8,h.wbits===0)h.wbits=pe;else if(pe>h.wbits){O.msg="invalid window size",h.mode=Pt;break}h.dmax=1<<pe,O.adler=h.check=1,h.mode=P&512?dt:kt,P=0,H=0;break;case st:for(;H<16;){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}if(h.flags=P,(h.flags&255)!==Q){O.msg="unknown compression method",h.mode=Pt;break}if(h.flags&57344){O.msg="unknown header flags set",h.mode=Pt;break}h.head&&(h.head.text=P>>8&1),h.flags&512&&(me[0]=P&255,me[1]=P>>>8&255,h.check=j(h.check,me,2,0)),P=0,H=0,h.mode=ht;case ht:for(;H<32;){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}h.head&&(h.head.time=P),h.flags&512&&(me[0]=P&255,me[1]=P>>>8&255,me[2]=P>>>16&255,me[3]=P>>>24&255,h.check=j(h.check,me,4,0)),P=0,H=0,h.mode=pt;case pt:for(;H<16;){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}h.head&&(h.head.xflags=P&255,h.head.os=P>>8),h.flags&512&&(me[0]=P&255,me[1]=P>>>8&255,h.check=j(h.check,me,2,0)),P=0,H=0,h.mode=V;case V:if(h.flags&1024){for(;H<16;){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}h.length=P,h.head&&(h.head.extra_len=P),h.flags&512&&(me[0]=P&255,me[1]=P>>>8&255,h.check=j(h.check,me,2,0)),P=0,H=0}else h.head&&(h.head.extra=null);h.mode=K;case K:if(h.flags&1024&&(bt=h.length,bt>J&&(bt=J),bt&&(h.head&&(pe=h.head.extra_len-h.length,h.head.extra||(h.head.extra=new Array(h.head.extra_len)),b.arraySet(h.head.extra,rt,o,bt,pe)),h.flags&512&&(h.check=j(h.check,rt,bt,o)),J-=bt,o+=bt,h.length-=bt),h.length))break t;h.length=0,h.mode=gt;case gt:if(h.flags&2048){if(J===0)break t;bt=0;do pe=rt[o+bt++],h.head&&pe&&h.length<65536&&(h.head.name+=String.fromCharCode(pe));while(pe&&bt<J);if(h.flags&512&&(h.check=j(h.check,rt,bt,o)),J-=bt,o+=bt,pe)break t}else h.head&&(h.head.name=null);h.length=0,h.mode=nt;case nt:if(h.flags&4096){if(J===0)break t;bt=0;do pe=rt[o+bt++],h.head&&pe&&h.length<65536&&(h.head.comment+=String.fromCharCode(pe));while(pe&&bt<J);if(h.flags&512&&(h.check=j(h.check,rt,bt,o)),J-=bt,o+=bt,pe)break t}else h.head&&(h.head.comment=null);h.mode=_t;case _t:if(h.flags&512){for(;H<16;){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}if(P!==(h.check&65535)){O.msg="header crc mismatch",h.mode=Pt;break}P=0,H=0}h.head&&(h.head.hcrc=h.flags>>9&1,h.head.done=!0),O.adler=h.check=0,h.mode=kt;break;case dt:for(;H<32;){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}O.adler=h.check=ie(P),P=0,H=0,h.mode=mt;case mt:if(h.havedict===0)return O.next_out=B,O.avail_out=g,O.next_in=o,O.avail_in=J,h.hold=P,h.bits=H,L;O.adler=h.check=1,h.mode=kt;case kt:if(z===D||z===C)break t;case Wt:if(h.last){P>>>=H&7,H-=H&7,h.mode=Ht;break}for(;H<3;){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}switch(h.last=P&1,P>>>=1,H-=1,P&3){case 0:h.mode=re;break;case 1:if(f(h),h.mode=Nt,z===C){P>>>=2,H-=2;break t}break;case 2:h.mode=ft;break;case 3:O.msg="invalid block type",h.mode=Pt}P>>>=2,H-=2;break;case re:for(P>>>=H&7,H-=H&7;H<32;){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}if((P&65535)!==(P>>>16^65535)){O.msg="invalid stored block lengths",h.mode=Pt;break}if(h.length=P&65535,P=0,H=0,h.mode=it,z===C)break t;case it:h.mode=ct;case ct:if(bt=h.length,bt){if(bt>J&&(bt=J),bt>g&&(bt=g),bt===0)break t;b.arraySet(Dt,rt,o,bt,B),J-=bt,o+=bt,g-=bt,B+=bt,h.length-=bt;break}h.mode=kt;break;case ft:for(;H<14;){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}if(h.nlen=(P&31)+257,P>>>=5,H-=5,h.ndist=(P&31)+1,P>>>=5,H-=5,h.ncode=(P&15)+4,P>>>=4,H-=4,h.nlen>286||h.ndist>30){O.msg="too many length or distance symbols",h.mode=Pt;break}h.have=0,h.mode=Ut;case Ut:for(;h.have<h.ncode;){for(;H<3;){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}h.lens[Jr[h.have++]]=P&7,P>>>=3,H-=3}for(;h.have<19;)h.lens[Jr[h.have++]]=0;if(h.lencode=h.lendyn,h.lenbits=7,De={bits:h.lenbits},Te=N(T,h.lens,0,19,h.lencode,0,h.work,De),h.lenbits=De.bits,Te){O.msg="invalid code lengths set",h.mode=Pt;break}h.have=0,h.mode=Rt;case Rt:for(;h.have<h.nlen+h.ndist;){for(;se=h.lencode[P&(1<<h.lenbits)-1],Vt=se>>>24,de=se>>>16&255,ge=se&65535,!(Vt<=H);){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}if(ge<16)P>>>=Vt,H-=Vt,h.lens[h.have++]=ge;else{if(ge===16){for(Ue=Vt+2;H<Ue;){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}if(P>>>=Vt,H-=Vt,h.have===0){O.msg="invalid bit length repeat",h.mode=Pt;break}pe=h.lens[h.have-1],bt=3+(P&3),P>>>=2,H-=2}else if(ge===17){for(Ue=Vt+3;H<Ue;){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}P>>>=Vt,H-=Vt,pe=0,bt=3+(P&7),P>>>=3,H-=3}else{for(Ue=Vt+7;H<Ue;){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}P>>>=Vt,H-=Vt,pe=0,bt=11+(P&127),P>>>=7,H-=7}if(h.have+bt>h.nlen+h.ndist){O.msg="invalid bit length repeat",h.mode=Pt;break}for(;bt--;)h.lens[h.have++]=pe}}if(h.mode===Pt)break;if(h.lens[256]===0){O.msg="invalid code -- missing end-of-block",h.mode=Pt;break}if(h.lenbits=9,De={bits:h.lenbits},Te=N(R,h.lens,0,h.nlen,h.lencode,0,h.work,De),h.lenbits=De.bits,Te){O.msg="invalid literal/lengths set",h.mode=Pt;break}if(h.distbits=6,h.distcode=h.distdyn,De={bits:h.distbits},Te=N(m,h.lens,h.nlen,h.ndist,h.distcode,0,h.work,De),h.distbits=De.bits,Te){O.msg="invalid distances set",h.mode=Pt;break}if(h.mode=Nt,z===C)break t;case Nt:h.mode=Zt;case Zt:if(J>=6&&g>=258){O.next_out=B,O.avail_out=g,O.next_in=o,O.avail_in=J,h.hold=P,h.bits=H,I(O,St),B=O.next_out,Dt=O.output,g=O.avail_out,o=O.next_in,rt=O.input,J=O.avail_in,P=h.hold,H=h.bits,h.mode===kt&&(h.back=-1);break}for(h.back=0;se=h.lencode[P&(1<<h.lenbits)-1],Vt=se>>>24,de=se>>>16&255,ge=se&65535,!(Vt<=H);){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}if(de&&(de&240)===0){for(ke=Vt,tr=de,er=ge;se=h.lencode[er+((P&(1<<ke+tr)-1)>>ke)],Vt=se>>>24,de=se>>>16&255,ge=se&65535,!(ke+Vt<=H);){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}P>>>=ke,H-=ke,h.back+=ke}if(P>>>=Vt,H-=Vt,h.back+=Vt,h.length=ge,de===0){h.mode=Ft;break}if(de&32){h.back=-1,h.mode=kt;break}if(de&64){O.msg="invalid literal/length code",h.mode=Pt;break}h.extra=de&15,h.mode=fe;case fe:if(h.extra){for(Ue=h.extra;H<Ue;){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}h.length+=P&(1<<h.extra)-1,P>>>=h.extra,H-=h.extra,h.back+=h.extra}h.was=h.length,h.mode=te;case te:for(;se=h.distcode[P&(1<<h.distbits)-1],Vt=se>>>24,de=se>>>16&255,ge=se&65535,!(Vt<=H);){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}if((de&240)===0){for(ke=Vt,tr=de,er=ge;se=h.distcode[er+((P&(1<<ke+tr)-1)>>ke)],Vt=se>>>24,de=se>>>16&255,ge=se&65535,!(ke+Vt<=H);){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}P>>>=ke,H-=ke,h.back+=ke}if(P>>>=Vt,H-=Vt,h.back+=Vt,de&64){O.msg="invalid distance code",h.mode=Pt;break}h.offset=ge,h.extra=de&15,h.mode=qt;case qt:if(h.extra){for(Ue=h.extra;H<Ue;){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}h.offset+=P&(1<<h.extra)-1,P>>>=h.extra,H-=h.extra,h.back+=h.extra}if(h.offset>h.dmax){O.msg="invalid distance too far back",h.mode=Pt;break}h.mode=Ct;case Ct:if(g===0)break t;if(bt=St-g,h.offset>bt){if(bt=h.offset-bt,bt>h.whave&&h.sane){O.msg="invalid distance too far back",h.mode=Pt;break}bt>h.wnext?(bt-=h.wnext,Gt=h.wsize-bt):Gt=h.wnext-bt,bt>h.length&&(bt=h.length),Fe=h.window}else Fe=Dt,Gt=B-h.offset,bt=h.length;bt>g&&(bt=g),g-=bt,h.length-=bt;do Dt[B++]=Fe[Gt++];while(--bt);h.length===0&&(h.mode=Zt);break;case Ft:if(g===0)break t;Dt[B++]=h.length,g--,h.mode=Zt;break;case Ht:if(h.wrap){for(;H<32;){if(J===0)break t;J--,P|=rt[o++]<<H,H+=8}if(St-=g,O.total_out+=St,h.total+=St,St&&(O.adler=h.check=h.flags?j(h.check,Dt,St,B-St):S(h.check,Dt,St,B-St)),St=g,(h.flags?P:ie(P))!==h.check){O.msg="incorrect data check",h.mode=Pt;break}P=0,H=0}h.mode=jt;case jt:if(h.wrap&&h.flags){for(;H<32;){if(J===0)break t;J--,P+=rt[o++]<<H,H+=8}if(P!==(h.total&4294967295)){O.msg="incorrect length check",h.mode=Pt;break}P=0,H=0}h.mode=Xt;case Xt:Te=U;break t;case Pt:Te=lt;break t;case zt:return Z;case ne:default:return et}return O.next_out=B,O.avail_out=g,O.next_in=o,O.avail_in=J,h.hold=P,h.bits=H,(h.wsize||St!==O.avail_out&&h.mode<Pt&&(h.mode<Ht||z!==_))&&E(O,O.output,O.next_out,St-O.avail_out),Ot-=O.avail_in,St-=O.avail_out,O.total_in+=Ot,O.total_out+=St,h.total+=St,h.wrap&&St&&(O.adler=h.check=h.flags?j(h.check,Dt,St,O.next_out-St):S(h.check,Dt,St,O.next_out-St)),O.data_type=h.bits+(h.last?64:0)+(h.mode===kt?128:0)+(h.mode===Nt||h.mode===it?256:0),(Ot===0&&St===0||z===_)&&Te===A&&(Te=X),Te}function k(O){if(!O||!O.state)return et;var z=O.state;return z.window&&(z.window=null),O.state=null,A}function F(O,z){var h;return!O||!O.state||(h=O.state,(h.wrap&2)===0)?et:(h.head=z,z.done=!1,A)}function ut(O,z){var h=z.length,rt,Dt,o;return!O||!O.state||(rt=O.state,rt.wrap!==0&&rt.mode!==mt)?et:rt.mode===mt&&(Dt=1,Dt=S(Dt,z,h,0),Dt!==rt.check)?lt:(o=E(O,z,h,h),o?(rt.mode=zt,Z):(rt.havedict=1,A))}return Me.inflateReset=Jt,Me.inflateReset2=xe,Me.inflateResetKeep=ae,Me.inflateInit=he,Me.inflateInit2=Ee,Me.inflate=u,Me.inflateEnd=k,Me.inflateGetHeader=F,Me.inflateSetDictionary=ut,Me.inflateInfo="pako inflate (from Nodeca project)",Me}var Hi,Sc;function Xc(){return Sc||(Sc=1,Hi={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}),Hi}var Zi,Ac;function wl(){if(Ac)return Zi;Ac=1;function b(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}return Zi=b,Zi}var kc;function gl(){if(kc)return Ar;kc=1;var b=pl(),S=Qe(),j=Zc(),I=Xc(),N=na(),T=Wc(),R=wl(),m=Object.prototype.toString;function _(A){if(!(this instanceof _))return new _(A);this.options=S.assign({chunkSize:16384,windowBits:0,to:""},A||{});var U=this.options;U.raw&&U.windowBits>=0&&U.windowBits<16&&(U.windowBits=-U.windowBits,U.windowBits===0&&(U.windowBits=-15)),U.windowBits>=0&&U.windowBits<16&&!(A&&A.windowBits)&&(U.windowBits+=32),U.windowBits>15&&U.windowBits<48&&(U.windowBits&15)===0&&(U.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new T,this.strm.avail_out=0;var L=b.inflateInit2(this.strm,U.windowBits);if(L!==I.Z_OK)throw new Error(N[L]);if(this.header=new R,b.inflateGetHeader(this.strm,this.header),U.dictionary&&(typeof U.dictionary=="string"?U.dictionary=j.string2buf(U.dictionary):m.call(U.dictionary)==="[object ArrayBuffer]"&&(U.dictionary=new Uint8Array(U.dictionary)),U.raw&&(L=b.inflateSetDictionary(this.strm,U.dictionary),L!==I.Z_OK)))throw new Error(N[L])}_.prototype.push=function(A,U){var L=this.strm,et=this.options.chunkSize,lt=this.options.dictionary,Z,X,Q,G,st,ht=!1;if(this.ended)return!1;X=U===~~U?U:U===!0?I.Z_FINISH:I.Z_NO_FLUSH,typeof A=="string"?L.input=j.binstring2buf(A):m.call(A)==="[object ArrayBuffer]"?L.input=new Uint8Array(A):L.input=A,L.next_in=0,L.avail_in=L.input.length;do{if(L.avail_out===0&&(L.output=new S.Buf8(et),L.next_out=0,L.avail_out=et),Z=b.inflate(L,I.Z_NO_FLUSH),Z===I.Z_NEED_DICT&&lt&&(Z=b.inflateSetDictionary(this.strm,lt)),Z===I.Z_BUF_ERROR&&ht===!0&&(Z=I.Z_OK,ht=!1),Z!==I.Z_STREAM_END&&Z!==I.Z_OK)return this.onEnd(Z),this.ended=!0,!1;L.next_out&&(L.avail_out===0||Z===I.Z_STREAM_END||L.avail_in===0&&(X===I.Z_FINISH||X===I.Z_SYNC_FLUSH))&&(this.options.to==="string"?(Q=j.utf8border(L.output,L.next_out),G=L.next_out-Q,st=j.buf2string(L.output,Q),L.next_out=G,L.avail_out=et-G,G&&S.arraySet(L.output,L.output,Q,G,0),this.onData(st)):this.onData(S.shrinkBuf(L.output,L.next_out))),L.avail_in===0&&L.avail_out===0&&(ht=!0)}while((L.avail_in>0||L.avail_out===0)&&Z!==I.Z_STREAM_END);return Z===I.Z_STREAM_END&&(X=I.Z_FINISH),X===I.Z_FINISH?(Z=b.inflateEnd(this.strm),this.onEnd(Z),this.ended=!0,Z===I.Z_OK):(X===I.Z_SYNC_FLUSH&&(this.onEnd(I.Z_OK),L.avail_out=0),!0)},_.prototype.onData=function(A){this.chunks.push(A)},_.prototype.onEnd=function(A){A===I.Z_OK&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=S.flattenChunks(this.chunks)),this.chunks=[],this.err=A,this.msg=this.strm.msg};function D(A,U){var L=new _(U);if(L.push(A,!0),L.err)throw L.msg||N[L.err];return L.result}function C(A,U){return U=U||{},U.raw=!0,D(A,U)}return Ar.Inflate=_,Ar.inflate=D,Ar.inflateRaw=C,Ar.ungzip=D,Ar}var Wi,Rc;function ml(){if(Rc)return Wi;Rc=1;var b=Qe().assign,S=ll(),j=gl(),I=Xc(),N={};return b(N,S,j,I),Wi=N,Wi}var Xi,Bc;function yl(){if(Bc)return Xi;Bc=1;const b=(S,j)=>function(...I){const N=j.promiseModule;return new N((T,R)=>{j.multiArgs?I.push((...m)=>{j.errorFirst?m[0]?R(m):(m.shift(),T(m)):T(m)}):j.errorFirst?I.push((m,_)=>{m?R(m):T(_)}):I.push(T),S.apply(this,I)})};return Xi=(S,j)=>{j=Object.assign({exclude:[/.+(Sync|Stream)$/],errorFirst:!0,promiseModule:Promise},j);const I=typeof S;if(!(S!==null&&(I==="object"||I==="function")))throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${S===null?"null":I}\``);const N=R=>{const m=_=>typeof _=="string"?R===_:_.test(R);return j.include?j.include.some(m):!j.exclude.some(m)};let T;I==="function"?T=function(...R){return j.excludeMain?S(...R):b(S,j).apply(this,R)}:T=Object.create(Object.getPrototypeOf(S));for(const R in S){const m=S[R];T[R]=typeof m=="function"&&N(R)?b(m,j):m}return T},Xi}var Vi,Ic;function _l(){if(Ic)return Vi;Ic=1;var b={};function S(it){return Array.isArray(it)?it:[it]}const j="",I=" ",N="\\",T=/^\s+$/,R=/(?:[^\\]|^)\\$/,m=/^\\!/,_=/^\\#/,D=/\r?\n/g,C=/^\.*\/|^\.+$/,A="/";let U="node-ignore";typeof Symbol<"u"&&(U=Symbol.for("node-ignore"));const L=U,et=(it,ct,ft)=>Object.defineProperty(it,ct,{value:ft}),lt=/([0-z])-([0-z])/g,Z=()=>!1,X=it=>it.replace(lt,(ct,ft,Ut)=>ft.charCodeAt(0)<=Ut.charCodeAt(0)?ct:j),Q=it=>{const{length:ct}=it;return it.slice(0,ct-ct%2)},G=[[/^\uFEFF/,()=>j],[/((?:\\\\)*?)(\\?\s+)$/,(it,ct,ft)=>ct+(ft.indexOf("\\")===0?I:j)],[/(\\+?)\s/g,(it,ct)=>{const{length:ft}=ct;return ct.slice(0,ft-ft%2)+I}],[/[\\$.|*+(){^]/g,it=>`\\${it}`],[/(?!\\)\?/g,()=>"[^/]"],[/^\//,()=>"^"],[/\//g,()=>"\\/"],[/^\^*\\\*\\\*\\\//,()=>"^(?:.*\\/)?"],[/^(?=[^^])/,function(){return/\/(?!$)/.test(this)?"^":"(?:^|\\/)"}],[/\\\/\\\*\\\*(?=\\\/|$)/g,(it,ct,ft)=>ct+6<ft.length?"(?:\\/[^\\/]+)*":"\\/.+"],[/(^|[^\\]+)(\\\*)+(?=.+)/g,(it,ct,ft)=>{const Ut=ft.replace(/\\\*/g,"[^\\/]*");return ct+Ut}],[/\\\\\\(?=[$.|*+(){^])/g,()=>N],[/\\\\/g,()=>N],[/(\\)?\[([^\]/]*?)(\\*)($|\])/g,(it,ct,ft,Ut,Rt)=>ct===N?`\\[${ft}${Q(Ut)}${Rt}`:Rt==="]"&&Ut.length%2===0?`[${X(ft)}${Ut}]`:"[]"],[/(?:[^*])$/,it=>/\/$/.test(it)?`${it}$`:`${it}(?=$|\\/$)`],[/(\^|\\\/)?\\\*$/,(it,ct)=>`${ct?`${ct}[^/]+`:"[^/]*"}(?=$|\\/$)`]],st=Object.create(null),ht=(it,ct)=>{let ft=st[it];return ft||(ft=G.reduce((Ut,[Rt,Nt])=>Ut.replace(Rt,Nt.bind(it)),it),st[it]=ft),ct?new RegExp(ft,"i"):new RegExp(ft)},pt=it=>typeof it=="string",V=it=>it&&pt(it)&&!T.test(it)&&!R.test(it)&&it.indexOf("#")!==0,K=it=>it.split(D);class gt{constructor(ct,ft,Ut,Rt){this.origin=ct,this.pattern=ft,this.negative=Ut,this.regex=Rt}}const nt=(it,ct)=>{const ft=it;let Ut=!1;it.indexOf("!")===0&&(Ut=!0,it=it.substr(1)),it=it.replace(m,"!").replace(_,"#");const Rt=ht(it,ct);return new gt(ft,it,Ut,Rt)},_t=(it,ct)=>{throw new ct(it)},dt=(it,ct,ft)=>pt(it)?it?dt.isNotRelative(it)?ft(`path should be a \`path.relative()\`d string, but got "${ct}"`,RangeError):!0:ft("path must not be empty",TypeError):ft(`path must be a string, but got \`${ct}\``,TypeError),mt=it=>C.test(it);dt.isNotRelative=mt,dt.convert=it=>it;class kt{constructor({ignorecase:ct=!0,ignoreCase:ft=ct,allowRelativePaths:Ut=!1}={}){et(this,L,!0),this._rules=[],this._ignoreCase=ft,this._allowRelativePaths=Ut,this._initCache()}_initCache(){this._ignoreCache=Object.create(null),this._testCache=Object.create(null)}_addPattern(ct){if(ct&&ct[L]){this._rules=this._rules.concat(ct._rules),this._added=!0;return}if(V(ct)){const ft=nt(ct,this._ignoreCase);this._added=!0,this._rules.push(ft)}}add(ct){return this._added=!1,S(pt(ct)?K(ct):ct).forEach(this._addPattern,this),this._added&&this._initCache(),this}addPattern(ct){return this.add(ct)}_testOne(ct,ft){let Ut=!1,Rt=!1;return this._rules.forEach(Nt=>{const{negative:Zt}=Nt;if(Rt===Zt&&Ut!==Rt||Zt&&!Ut&&!Rt&&!ft)return;Nt.regex.test(ct)&&(Ut=!Zt,Rt=Zt)}),{ignored:Ut,unignored:Rt}}_test(ct,ft,Ut,Rt){const Nt=ct&&dt.convert(ct);return dt(Nt,ct,this._allowRelativePaths?Z:_t),this._t(Nt,ft,Ut,Rt)}_t(ct,ft,Ut,Rt){if(ct in ft)return ft[ct];if(Rt||(Rt=ct.split(A)),Rt.pop(),!Rt.length)return ft[ct]=this._testOne(ct,Ut);const Nt=this._t(Rt.join(A)+A,ft,Ut,Rt);return ft[ct]=Nt.ignored?Nt:this._testOne(ct,Ut)}ignores(ct){return this._test(ct,this._ignoreCache,!1).ignored}createFilter(){return ct=>!this.ignores(ct)}filter(ct){return S(ct).filter(this.createFilter())}test(ct){return this._test(ct,this._testCache,!0)}}const Wt=it=>new kt(it),re=it=>dt(it&&dt.convert(it),it,Z);if(Wt.isPathValid=re,Wt.default=Wt,Vi=Wt,typeof process<"u"&&(b&&b.IGNORE_TEST_WIN32||process.platform==="win32")){const it=ft=>/^\\\\\?\\/.test(ft)||/["<>|\u0000-\u001F]+/u.test(ft)?ft:ft.replace(/\\/g,"/");dt.convert=it;const ct=/^[a-z]:\//i;dt.isNotRelative=ft=>ct.test(ft)||mt(ft)}return Vi}var Yi,Tc;function vl(){if(Tc)return Yi;Tc=1;function b(I){return I.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function S(I,N,T){return N=N instanceof RegExp?N:new RegExp(b(N),"g"),I.replace(N,T)}var j={clean:function(N){if(typeof N!="string")throw new Error("Expected a string, received: "+N);return N=S(N,"./","/"),N=S(N,"..","."),N=S(N," ","-"),N=S(N,/^[~^:?*\\\-]/g,""),N=S(N,/[~^:?*\\]/g,"-"),N=S(N,/[~^:?*\\\-]$/g,""),N=S(N,"@{","-"),N=S(N,/\.$/g,""),N=S(N,/\/$/g,""),N=S(N,/\.lock$/g,""),N}};return Yi=j,Yi}var Ki,Oc;function bl(){return Oc||(Oc=1,Ki=function(b,S){var j=b,I=S,N=j.length,T=I.length,R=!1,m=null,_=N+1,D=[],C=[],A=[],U="",L=-1,et=0,lt=1,Z,X,Q=function(){N>=T&&(Z=j,X=N,j=I,I=Z,N=T,T=X,R=!0,_=N+1)},G=function(V,K,gt){return{x:V,y:K,k:gt}},st=function(V,K){return{elem:V,t:K}},ht=function(V,K,gt){var nt,_t,dt;for(K>gt?nt=D[V-1+_]:nt=D[V+1+_],dt=Math.max(K,gt),_t=dt-V;_t<N&&dt<T&&j[_t]===I[dt];)++_t,++dt;return D[V+_]=C.length,C[C.length]=new G(_t,dt,nt),dt},pt=function(V){var K,gt,nt;for(K=gt=0,nt=V.length-1;nt>=0;--nt)for(;K<V[nt].x||gt<V[nt].y;)V[nt].y-V[nt].x>gt-K?(R?A[A.length]=new st(I[gt],L):A[A.length]=new st(I[gt],lt),++gt):V[nt].y-V[nt].x<gt-K?(R?A[A.length]=new st(j[K],lt):A[A.length]=new st(j[K],L),++K):(A[A.length]=new st(j[K],et),U+=j[K],++K,++gt)};return Q(),{SES_DELETE:-1,SES_COMMON:0,SES_ADD:1,editdistance:function(){return m},getlcs:function(){return U},getses:function(){return A},compose:function(){var V,K,gt,nt,_t,dt,mt,kt;for(V=T-N,K=N+T+3,gt={},mt=0;mt<K;++mt)gt[mt]=-1,D[mt]=-1;nt=-1;do{for(++nt,kt=-nt;kt<=V-1;++kt)gt[kt+_]=ht(kt,gt[kt-1+_]+1,gt[kt+1+_]);for(kt=V+nt;kt>=V+1;--kt)gt[kt+_]=ht(kt,gt[kt-1+_]+1,gt[kt+1+_]);gt[V+_]=ht(V,gt[V-1+_]+1,gt[V+1+_])}while(gt[V+_]!==T);for(m=V+2*nt,_t=D[V+_],dt=[];_t!==-1;)dt[dt.length]=new G(C[_t].x,C[_t].y,null),_t=C[_t].k;pt(dt)}}}),Ki}var Ji,$c;function xl(){if($c)return Ji;$c=1;var b=bl();function S(T,R){var m=new b(T,R);m.compose();for(var _=m.getses(),D,C,A=T.length-1,U=R.length-1,L=_.length-1;L>=0;--L)_[L].t===m.SES_COMMON?(C?(C.chain={file1index:A,file2index:U,chain:null},C=C.chain):(D={file1index:A,file2index:U,chain:null},C=D),A--,U--):_[L].t===m.SES_DELETE?A--:_[L].t===m.SES_ADD&&U--;var et={file1index:-1,file2index:-1,chain:null};return C?(C.chain=et,D):et}function j(T,R){for(var m=[],_=T.length,D=R.length,C=S(T,R);C!==null;C=C.chain){var A=_-C.file1index-1,U=D-C.file2index-1;_=C.file1index,D=C.file2index,(A||U)&&m.push({file1:[_+1,A],file2:[D+1,U]})}return m.reverse(),m}function I(T,R,m){var _,D=j(R,T),C=j(R,m),A=[];function U(ct,ft){A.push([ct.file1[0],ft,ct.file1[1],ct.file2[0],ct.file2[1]])}for(_=0;_<D.length;_++)U(D[_],0);for(_=0;_<C.length;_++)U(C[_],2);A.sort(function(ct,ft){return ct[0]-ft[0]});var L=[],et=0;function lt(ct){ct>et&&(L.push([1,et,ct-et]),et=ct)}for(var Z=0;Z<A.length;Z++){for(var X=Z,Q=A[Z],G=Q[0],st=G+Q[2];Z<A.length-1;){var ht=A[Z+1],pt=ht[0];if(pt>st)break;st=Math.max(st,pt+ht[2]),Z++}if(lt(G),X==Z)Q[4]>0&&L.push([Q[1],Q[3],Q[4]]);else{var V={0:[T.length,-1,R.length,-1],2:[m.length,-1,R.length,-1]};for(_=X;_<=Z;_++){Q=A[_];var K=Q[1],gt=V[K],nt=Q[0],_t=nt+Q[2],dt=Q[3],mt=dt+Q[4];gt[0]=Math.min(dt,gt[0]),gt[1]=Math.max(mt,gt[1]),gt[2]=Math.min(nt,gt[2]),gt[3]=Math.max(_t,gt[3])}var kt=V[0][0]+(G-V[0][2]),Wt=V[0][1]+(st-V[0][3]),re=V[2][0]+(G-V[2][2]),it=V[2][1]+(st-V[2][3]);L.push([-1,kt,Wt-kt,G,st-G,re,it-re])}et=st}return lt(R.length),L}function N(T,R,m){var _=[],D=[T,R,m],C=I(T,R,m),A=[];function U(){A.length&&_.push({ok:A}),A=[]}function L(Q){for(var G=0;G<Q.length;G++)A.push(Q[G])}function et(Q){if(Q[2]!=Q[6])return!0;for(var G=Q[1],st=Q[5],ht=0;ht<Q[2];ht++)if(T[ht+G]!=m[ht+st])return!0;return!1}for(var lt=0;lt<C.length;lt++){var Z=C[lt],X=Z[0];X==-1?et(Z)?(U(),_.push({conflict:{a:T.slice(Z[1],Z[1]+Z[2]),aIndex:Z[1],o:R.slice(Z[3],Z[3]+Z[4]),oIndex:Z[3],b:m.slice(Z[5],Z[5]+Z[6]),bIndex:Z[5]}})):L(D[0].slice(Z[1],Z[1]+Z[2])):L(D[X].slice(Z[1],Z[1]+Z[2]))}return U(),_}return Ji=N,Ji}var Pc;function Bl(){if(Pc)return Et;Pc=1,Object.defineProperty(Et,"__esModule",{value:!0});function b(r){return r&&typeof r=="object"&&"default"in r?r.default:r}var S=b(bu()),j=b(sl()),I=b(cl()),N=b(ml()),T=b(yl()),R=b(_l()),m=b(vl()),_=b(xl());class D extends Error{constructor(t){super(t),this.caller=""}toJSON(){return{code:this.code,data:this.data,caller:this.caller,message:this.message,stack:this.stack}}fromJSON(t){const e=new D(t.message);return e.code=t.code,e.data=t.data,e.caller=t.caller,e.stack=t.stack,e}get isIsomorphicGitError(){return!0}}class C extends D{constructor(t){super(`Modifying the index is not possible because you have unmerged files: ${t.toString}. Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.`),this.code=this.name=C.code,this.data={filepaths:t}}}C.code="UnmergedPathsError";class A extends D{constructor(t){super(`An internal error caused this command to fail.

If you're not a developer, report the bug to the developers of the application you're using. If this is a bug in isomorphic-git then you should create a proper bug yourselves. The bug should include a minimal reproduction and details about the version and environment.

Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${t}`),this.code=this.name=A.code,this.data={message:t}}}A.code="InternalError";class U extends D{constructor(t){super(`The filepath "${t}" contains unsafe character sequences`),this.code=this.name=U.code,this.data={filepath:t}}}U.code="UnsafeFilepathError";class L{constructor(t){this.buffer=t,this._start=0}eof(){return this._start>=this.buffer.length}tell(){return this._start}seek(t){this._start=t}slice(t){const e=this.buffer.slice(this._start,this._start+t);return this._start+=t,e}toString(t,e){const n=this.buffer.toString(t,this._start,this._start+e);return this._start+=e,n}write(t,e,n){const i=this.buffer.write(t,this._start,e,n);return this._start+=e,i}copy(t,e,n){const i=t.copy(this.buffer,this._start,e,n);return this._start+=i,i}readUInt8(){const t=this.buffer.readUInt8(this._start);return this._start+=1,t}writeUInt8(t){const e=this.buffer.writeUInt8(t,this._start);return this._start+=1,e}readUInt16BE(){const t=this.buffer.readUInt16BE(this._start);return this._start+=2,t}writeUInt16BE(t){const e=this.buffer.writeUInt16BE(t,this._start);return this._start+=2,e}readUInt32BE(){const t=this.buffer.readUInt32BE(this._start);return this._start+=4,t}writeUInt32BE(t){const e=this.buffer.writeUInt32BE(t,this._start);return this._start+=4,e}}function et(r,t){return-(r<t)||+(r>t)}function lt(r,t){return et(r.path,t.path)}function Z(r){let t=r>0?r>>12:0;t!==4&&t!==8&&t!==10&&t!==14&&(t=8);let e=r&511;return e&73?e=493:e=420,t!==8&&(e=0),(t<<12)+e}const X=2**32;function Q(r,t,e,n){if(r!==void 0&&t!==void 0)return[r,t];e===void 0&&(e=n.valueOf());const i=Math.floor(e/1e3),a=(e-i*1e3)*1e6;return[i,a]}function G(r){const[t,e]=Q(r.ctimeSeconds,r.ctimeNanoseconds,r.ctimeMs,r.ctime),[n,i]=Q(r.mtimeSeconds,r.mtimeNanoseconds,r.mtimeMs,r.mtime);return{ctimeSeconds:t%X,ctimeNanoseconds:e%X,mtimeSeconds:n%X,mtimeNanoseconds:i%X,dev:r.dev%X,ino:r.ino%X,mode:Z(r.mode%X),uid:r.uid%X,gid:r.gid%X,size:r.size>-1?r.size%X:0}}function st(r){let t="";for(const e of new Uint8Array(r))e<16&&(t+="0"),t+=e.toString(16);return t}let ht=null;async function pt(r){return ht===null&&(ht=await gt()),ht?K(r):V(r)}function V(r){return new j().update(r).digest("hex")}async function K(r){const t=await crypto.subtle.digest("SHA-1",r);return st(t)}async function gt(){try{return await K(new Uint8Array([]))==="da39a3ee5e6b4b0d3255bfef95601890afd80709"}catch{}return!1}function nt(r){return{assumeValid:!!(r&32768),extended:!!(r&16384),stage:(r&12288)>>12,nameLength:r&4095}}function _t(r){const t=r.flags;return t.extended=!1,t.nameLength=Math.min(Buffer.from(r.path).length,4095),(t.assumeValid?32768:0)+(t.extended?16384:0)+((t.stage&3)<<12)+(t.nameLength&4095)}class dt{constructor(t,e){this._dirty=!1,this._unmergedPaths=e||new Set,this._entries=t||new Map}_addEntry(t){if(t.flags.stage===0)t.stages=[t],this._entries.set(t.path,t),this._unmergedPaths.delete(t.path);else{let e=this._entries.get(t.path);e||(this._entries.set(t.path,t),e=t),e.stages[t.flags.stage]=t,this._unmergedPaths.add(t.path)}}static async from(t){if(Buffer.isBuffer(t))return dt.fromBuffer(t);if(t===null)return new dt(null);throw new A("invalid type passed to GitIndex.from")}static async fromBuffer(t){if(t.length===0)throw new A("Index file is empty (.git/index)");const e=new dt,n=new L(t),i=n.toString("utf8",4);if(i!=="DIRC")throw new A(`Invalid dircache magic file number: ${i}`);const a=await pt(t.slice(0,-20)),c=t.slice(-20).toString("hex");if(c!==a)throw new A(`Invalid checksum in GitIndex buffer: expected ${c} but saw ${a}`);const l=n.readUInt32BE();if(l!==2)throw new A(`Unsupported dircache version: ${l}`);const p=n.readUInt32BE();let y=0;for(;!n.eof()&&y<p;){const d={};d.ctimeSeconds=n.readUInt32BE(),d.ctimeNanoseconds=n.readUInt32BE(),d.mtimeSeconds=n.readUInt32BE(),d.mtimeNanoseconds=n.readUInt32BE(),d.dev=n.readUInt32BE(),d.ino=n.readUInt32BE(),d.mode=n.readUInt32BE(),d.uid=n.readUInt32BE(),d.gid=n.readUInt32BE(),d.size=n.readUInt32BE(),d.oid=n.slice(20).toString("hex");const v=n.readUInt16BE();d.flags=nt(v);const x=t.indexOf(0,n.tell()+1)-n.tell();if(x<1)throw new A(`Got a path length of: ${x}`);if(d.path=n.toString("utf8",x),d.path.includes("..\\")||d.path.includes("../"))throw new U(d.path);let $=8-(n.tell()-12)%8;for($===0&&($=8);$--;){const q=n.readUInt8();if(q!==0)throw new A(`Expected 1-8 null characters but got '${q}' after ${d.path}`);if(n.eof())throw new A("Unexpected end of file")}d.stages=[],e._addEntry(d),y++}return e}get unmergedPaths(){return[...this._unmergedPaths]}get entries(){return[...this._entries.values()].sort(lt)}get entriesMap(){return this._entries}get entriesFlat(){return[...this.entries].flatMap(t=>t.stages.length>1?t.stages.filter(e=>e):t)}*[Symbol.iterator](){for(const t of this.entries)yield t}insert({filepath:t,stats:e,oid:n,stage:i=0}){e||(e={ctimeSeconds:0,ctimeNanoseconds:0,mtimeSeconds:0,mtimeNanoseconds:0,dev:0,ino:0,mode:0,uid:0,gid:0,size:0}),e=G(e);const a=Buffer.from(t),c={ctimeSeconds:e.ctimeSeconds,ctimeNanoseconds:e.ctimeNanoseconds,mtimeSeconds:e.mtimeSeconds,mtimeNanoseconds:e.mtimeNanoseconds,dev:e.dev,ino:e.ino,mode:e.mode||33188,uid:e.uid,gid:e.gid,size:e.size,path:t,oid:n,flags:{assumeValid:!1,extended:!1,stage:i,nameLength:a.length<4095?a.length:4095},stages:[]};this._addEntry(c),this._dirty=!0}delete({filepath:t}){if(this._entries.has(t))this._entries.delete(t);else for(const e of this._entries.keys())e.startsWith(t+"/")&&this._entries.delete(e);this._unmergedPaths.has(t)&&this._unmergedPaths.delete(t),this._dirty=!0}clear(){this._entries.clear(),this._dirty=!0}has({filepath:t}){return this._entries.has(t)}render(){return this.entries.map(t=>`${t.mode.toString(8)} ${t.oid}    ${t.path}`).join(`
`)}static async _entryToBuffer(t){const e=Buffer.from(t.path),n=Math.ceil((62+e.length+1)/8)*8,i=Buffer.alloc(n),a=new L(i),c=G(t);return a.writeUInt32BE(c.ctimeSeconds),a.writeUInt32BE(c.ctimeNanoseconds),a.writeUInt32BE(c.mtimeSeconds),a.writeUInt32BE(c.mtimeNanoseconds),a.writeUInt32BE(c.dev),a.writeUInt32BE(c.ino),a.writeUInt32BE(c.mode),a.writeUInt32BE(c.uid),a.writeUInt32BE(c.gid),a.writeUInt32BE(c.size),a.write(t.oid,20,"hex"),a.writeUInt16BE(_t(t)),a.write(t.path,e.length,"utf8"),i}async toObject(){const t=Buffer.alloc(12),e=new L(t);e.write("DIRC",4,"utf8"),e.writeUInt32BE(2),e.writeUInt32BE(this.entriesFlat.length);let n=[];for(const l of this.entries)if(n.push(dt._entryToBuffer(l)),l.stages.length>1)for(const p of l.stages)p&&p!==l&&n.push(dt._entryToBuffer(p));n=await Promise.all(n);const i=Buffer.concat(n),a=Buffer.concat([t,i]),c=await pt(a);return Buffer.concat([a,Buffer.from(c,"hex")])}}function mt(r,t,e=!0,n=!0){const i=G(r),a=G(t);return e&&i.mode!==a.mode||i.mtimeSeconds!==a.mtimeSeconds||i.ctimeSeconds!==a.ctimeSeconds||i.uid!==a.uid||i.gid!==a.gid||n&&i.ino!==a.ino||i.size!==a.size}let kt=null;const Wt=Symbol("IndexCache");function re(){return{map:new Map,stats:new Map}}async function it(r,t,e){const[n,i]=await Promise.all([r.lstat(t),r.read(t)]),a=await dt.from(i);e.map.set(t,a),e.stats.set(t,n)}async function ct(r,t,e){const n=e.stats.get(t);if(n===void 0)return!0;if(n===null)return!1;const i=await r.lstat(t);return i===null?!1:mt(n,i)}class ft{static async acquire({fs:t,gitdir:e,cache:n,allowUnmerged:i=!0},a){n[Wt]||(n[Wt]=re());const c=`${e}/index`;kt===null&&(kt=new S({maxPending:1/0}));let l,p=[];return await kt.acquire(c,async()=>{const y=n[Wt];await ct(t,c,y)&&await it(t,c,y);const d=y.map.get(c);if(p=d.unmergedPaths,p.length&&!i)throw new C(p);if(l=await a(d),d._dirty){const v=await d.toObject();await t.write(c,v),y.stats.set(c,await t.lstat(c)),d._dirty=!1}}),l}}function Ut(r){const t=Math.max(r.lastIndexOf("/"),r.lastIndexOf("\\"));return t>-1&&(r=r.slice(t+1)),r}function Rt(r){const t=Math.max(r.lastIndexOf("/"),r.lastIndexOf("\\"));return t===-1?".":t===0?"/":r.slice(0,t)}function Nt(r){const t=new Map,e=function(i){if(!t.has(i)){const a={type:"tree",fullpath:i,basename:Ut(i),metadata:{},children:[]};t.set(i,a),a.parent=e(Rt(i)),a.parent&&a.parent!==a&&a.parent.children.push(a)}return t.get(i)},n=function(i,a){if(!t.has(i)){const c={type:"blob",fullpath:i,basename:Ut(i),metadata:a,parent:e(Rt(i)),children:[]};c.parent&&c.parent.children.push(c),t.set(i,c)}return t.get(i)};e(".");for(const i of r)n(i.path,i);return t}function Zt(r){switch(r){case 16384:return"tree";case 33188:return"blob";case 33261:return"blob";case 40960:return"blob";case 57344:return"commit"}throw new A(`Unexpected GitTree entry mode: ${r.toString(8)}`)}class fe{constructor({fs:t,gitdir:e,cache:n}){this.treePromise=ft.acquire({fs:t,gitdir:e,cache:n},async function(a){return Nt(a.entries)});const i=this;this.ConstructEntry=class{constructor(c){this._fullpath=c,this._type=!1,this._mode=!1,this._stat=!1,this._oid=!1}async type(){return i.type(this)}async mode(){return i.mode(this)}async stat(){return i.stat(this)}async content(){return i.content(this)}async oid(){return i.oid(this)}}}async readdir(t){const e=t._fullpath,i=(await this.treePromise).get(e);if(!i||i.type==="blob")return null;if(i.type!=="tree")throw new Error(`ENOTDIR: not a directory, scandir '${e}'`);const a=i.children.map(c=>c.fullpath);return a.sort(et),a}async type(t){return t._type===!1&&await t.stat(),t._type}async mode(t){return t._mode===!1&&await t.stat(),t._mode}async stat(t){if(t._stat===!1){const n=(await this.treePromise).get(t._fullpath);if(!n)throw new Error(`ENOENT: no such file or directory, lstat '${t._fullpath}'`);const i=n.type==="tree"?{}:G(n.metadata);t._type=n.type==="tree"?"tree":Zt(i.mode),t._mode=i.mode,n.type==="tree"?t._stat=void 0:t._stat=i}return t._stat}async content(t){}async oid(t){if(t._oid===!1){const n=(await this.treePromise).get(t._fullpath);t._oid=n.metadata.oid}return t._oid}}const te=Symbol("GitWalkSymbol");function qt(){const r=Object.create(null);return Object.defineProperty(r,te,{value:function({fs:t,gitdir:e,cache:n}){return new fe({fs:t,gitdir:e,cache:n})}}),Object.freeze(r),r}class Ct extends D{constructor(t){super(`Could not find ${t}.`),this.code=this.name=Ct.code,this.data={what:t}}}Ct.code="NotFoundError";class Ft extends D{constructor(t,e,n,i){super(`Object ${t} ${i?`at ${i}`:""}was anticipated to be a ${n} but it is a ${e}.`),this.code=this.name=Ft.code,this.data={oid:t,actual:e,expected:n,filepath:i}}}Ft.code="ObjectTypeError";class Ht extends D{constructor(t){super(`Expected a 40-char hex object id but saw "${t}".`),this.code=this.name=Ht.code,this.data={value:t}}}Ht.code="InvalidOidError";class jt extends D{constructor(t){super(`Could not find a fetch refspec for remote "${t}". Make sure the config file has an entry like the following:
[remote "${t}"]
	fetch = +refs/heads/*:refs/remotes/origin/*
`),this.code=this.name=jt.code,this.data={remote:t}}}jt.code="NoRefspecError";class Xt{constructor(t){if(this.refs=new Map,this.parsedConfig=[],t){let e=null;this.parsedConfig=t.trim().split(`
`).map(n=>{if(/^\s*#/.test(n))return{line:n,comment:!0};const i=n.indexOf(" ");if(n.startsWith("^")){const a=n.slice(1);return this.refs.set(e+"^{}",a),{line:n,ref:e,peeled:a}}else{const a=n.slice(0,i);return e=n.slice(i+1),this.refs.set(e,a),{line:n,ref:e,oid:a}}})}return this}static from(t){return new Xt(t)}delete(t){this.parsedConfig=this.parsedConfig.filter(e=>e.ref!==t),this.refs.delete(t)}toString(){return this.parsedConfig.map(({line:t})=>t).join(`
`)+`
`}}class Pt{constructor({remotePath:t,localPath:e,force:n,matchPrefix:i}){Object.assign(this,{remotePath:t,localPath:e,force:n,matchPrefix:i})}static from(t){const[e,n,i,a,c]=t.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1),l=e==="+",p=i==="*";if(p!==(c==="*"))throw new A("Invalid refspec");return new Pt({remotePath:n,localPath:a,force:l,matchPrefix:p})}translate(t){if(this.matchPrefix){if(t.startsWith(this.remotePath))return this.localPath+t.replace(this.remotePath,"")}else if(t===this.remotePath)return this.localPath;return null}reverseTranslate(t){if(this.matchPrefix){if(t.startsWith(this.localPath))return this.remotePath+t.replace(this.localPath,"")}else if(t===this.localPath)return this.remotePath;return null}}class zt{constructor(t=[]){this.rules=t}static from(t){const e=[];for(const n of t)e.push(Pt.from(n));return new zt(e)}add(t){const e=Pt.from(t);this.rules.push(e)}translate(t){const e=[];for(const n of this.rules)for(const i of t){const a=n.translate(i);a&&e.push([i,a])}return e}translateOne(t){let e=null;for(const n of this.rules){const i=n.translate(t);i&&(e=i)}return e}localNamespaces(){return this.rules.filter(t=>t.matchPrefix).map(t=>t.localPath.replace(/\/$/,""))}}function ne(r,t){const e=r.replace(/\^\{\}$/,""),n=t.replace(/\^\{\}$/,""),i=-(e<n)||+(e>n);return i===0?r.endsWith("^{}")?1:-1:i}/*!
 * This code for `path.join` is directly copied from @zenfs/core/path for bundle size improvements.
 * SPDX-License-Identifier: LGPL-3.0-or-later
 * Copyright (c) James Prevett and other ZenFS contributors.
 */function ue(r,t){let e="",n=0,i=-1,a=0,c="\0";for(let l=0;l<=r.length;++l){if(l<r.length)c=r[l];else{if(c==="/")break;c="/"}if(c==="/"){if(!(i===l-1||a===1))if(a===2){if(e.length<2||n!==2||e.at(-1)!=="."||e.at(-2)!=="."){if(e.length>2){const p=e.lastIndexOf("/");p===-1?(e="",n=0):(e=e.slice(0,p),n=e.length-1-e.lastIndexOf("/")),i=l,a=0;continue}else if(e.length!==0){e="",n=0,i=l,a=0;continue}}t&&(e+=e.length>0?"/..":"..",n=2)}else e.length>0?e+="/"+r.slice(i+1,l):e=r.slice(i+1,l),n=l-i-1;i=l,a=0}else c==="."&&a!==-1?++a:a=-1}return e}function Kt(r){if(!r.length)return".";const t=r[0]==="/",e=r.at(-1)==="/";return r=ue(r,!t),r.length?(e&&(r+="/"),t?`/${r}`:r):t?"/":e?"./":"."}function W(...r){if(r.length===0)return".";let t;for(let e=0;e<r.length;++e){const n=r[e];n.length>0&&(t===void 0?t=n:t+="/"+n)}return t===void 0?".":Kt(t)}const Mt=r=>{if(typeof r=="number")return r;r=r.toLowerCase();let t=parseInt(r);return r.endsWith("k")&&(t*=1024),r.endsWith("m")&&(t*=1024*1024),r.endsWith("g")&&(t*=1024*1024*1024),t},ie=r=>{if(typeof r=="boolean")return r;if(r=r.trim().toLowerCase(),r==="true"||r==="yes"||r==="on")return!0;if(r==="false"||r==="no"||r==="off")return!1;throw Error(`Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${r}`)},be={core:{filemode:ie,bare:ie,logallrefupdates:ie,symlinks:ie,ignorecase:ie,bigFileThreshold:Mt}},ae=/^\[([A-Za-z0-9-.]+)(?: "(.*)")?\]$/,Jt=/^[A-Za-z0-9-.]+$/,xe=/^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/,Ee=/^[A-Za-z][A-Za-z-]*$/,he=/^(.*?)( *[#;].*)$/,ze=r=>{const t=ae.exec(r);if(t!=null){const[e,n]=t.slice(1);return[e,n]}return null},w=r=>{const t=xe.exec(r);if(t!=null){const[e,n="true"]=t.slice(1),i=s(n),a=E(i);return[e,a]}return null},s=r=>{const t=he.exec(r);if(t==null)return r;const[e,n]=t.slice(1);return f(e)&&f(n)?`${e}${n}`:e},f=r=>(r.match(/(?:^|[^\\])"/g)||[]).length%2!==0,E=r=>r.split("").reduce((t,e,n,i)=>{const a=e==='"'&&i[n-1]!=="\\",c=e==="\\"&&i[n+1]==='"';return a||c?t:t+e},""),u=r=>r!=null?r.toLowerCase():null,k=(r,t,e)=>[u(r),t,u(e)].filter(n=>n!=null).join("."),F=r=>{const t=r.split("."),e=t.shift(),n=t.pop(),i=t.length?t.join("."):void 0;return{section:e,subsection:i,name:n,path:k(e,i,n),sectionPath:k(e,i,null),isSection:!!e}},ut=(r,t)=>r.reduce((e,n,i)=>t(n)?i:e,-1);class O{constructor(t){let e=null,n=null;this.parsedConfig=t?t.split(`
`).map(i=>{let a=null,c=null;const l=i.trim(),p=ze(l),y=p!=null;if(y)[e,n]=p;else{const v=w(l);v!=null&&([a,c]=v)}const d=k(e,n,a);return{line:i,isSection:y,section:e,subsection:n,name:a,value:c,path:d}}):[]}static from(t){return new O(t)}async get(t,e=!1){const n=F(t).path,i=this.parsedConfig.filter(a=>a.path===n).map(({section:a,name:c,value:l})=>{const p=be[a]&&be[a][c];return p?p(l):l});return e?i:i.pop()}async getall(t){return this.get(t,!0)}async getSubsections(t){return this.parsedConfig.filter(e=>e.isSection&&e.section===t).map(e=>e.subsection)}async deleteSection(t,e){this.parsedConfig=this.parsedConfig.filter(n=>!(n.section===t&&n.subsection===e))}async append(t,e){return this.set(t,e,!0)}async set(t,e,n=!1){const{section:i,subsection:a,name:c,path:l,sectionPath:p,isSection:y}=F(t),d=ut(this.parsedConfig,v=>v.path===l);if(e==null)d!==-1&&this.parsedConfig.splice(d,1);else if(d!==-1){const v=this.parsedConfig[d],x=Object.assign({},v,{name:c,value:e,modified:!0});n?this.parsedConfig.splice(d+1,0,x):this.parsedConfig[d]=x}else{const v=this.parsedConfig.findIndex($=>$.path===p),x={section:i,subsection:a,name:c,value:e,modified:!0,path:l};if(Jt.test(i)&&Ee.test(c))if(v>=0)this.parsedConfig.splice(v+1,0,x);else{const $={isSection:y,section:i,subsection:a,modified:!0,path:p};this.parsedConfig.push($,x)}}}toString(){return this.parsedConfig.map(({line:t,section:e,subsection:n,name:i,value:a,modified:c=!1})=>c?i!=null&&a!=null?typeof a=="string"&&/[#;]/.test(a)?`	${i} = "${a}"`:`	${i} = ${a}`:n!=null?`[${e} "${n}"]`:`[${e}]`:t).join(`
`)}}class z{static async get({fs:t,gitdir:e}){const n=await t.read(`${e}/config`,{encoding:"utf8"});return O.from(n)}static async save({fs:t,gitdir:e,config:n}){await t.write(`${e}/config`,n.toString(),{encoding:"utf8"})}}const h=r=>[`${r}`,`refs/${r}`,`refs/tags/${r}`,`refs/heads/${r}`,`refs/remotes/${r}`,`refs/remotes/${r}/HEAD`],rt=["config","description","index","shallow","commondir"];let Dt;async function o(r,t){return Dt===void 0&&(Dt=new S),Dt.acquire(r,t)}class B{static async updateRemoteRefs({fs:t,gitdir:e,remote:n,refs:i,symrefs:a,tags:c,refspecs:l=void 0,prune:p=!1,pruneTags:y=!1}){for(const Y of i.values())if(!Y.match(/[0-9a-f]{40}/))throw new Ht(Y);const d=await z.get({fs:t,gitdir:e});if(!l){if(l=await d.getall(`remote.${n}.fetch`),l.length===0)throw new jt(n);l.unshift(`+HEAD:refs/remotes/${n}/HEAD`)}const v=zt.from(l),x=new Map;if(y){const Y=await B.listRefs({fs:t,gitdir:e,filepath:"refs/tags"});await B.deleteRefs({fs:t,gitdir:e,refs:Y.map(at=>`refs/tags/${at}`)})}if(c){for(const Y of i.keys())if(Y.startsWith("refs/tags")&&!Y.endsWith("^{}")&&!await B.exists({fs:t,gitdir:e,ref:Y})){const at=i.get(Y);x.set(Y,at)}}const $=v.translate([...i.keys()]);for(const[Y,at]of $){const ot=i.get(Y);x.set(at,ot)}const q=v.translate([...a.keys()]);for(const[Y,at]of q){const ot=a.get(Y),vt=v.translateOne(ot);vt&&x.set(at,`ref: ${vt}`)}const tt=[];if(p){for(const Y of v.localNamespaces()){const at=(await B.listRefs({fs:t,gitdir:e,filepath:Y})).map(ot=>`${Y}/${ot}`);for(const ot of at)x.has(ot)||tt.push(ot)}tt.length>0&&await B.deleteRefs({fs:t,gitdir:e,refs:tt})}for(const[Y,at]of x)await o(Y,async()=>t.write(W(e,Y),`${at.trim()}
`,"utf8"));return{pruned:tt}}static async writeRef({fs:t,gitdir:e,ref:n,value:i}){if(!i.match(/[0-9a-f]{40}/))throw new Ht(i);await o(n,async()=>t.write(W(e,n),`${i.trim()}
`,"utf8"))}static async writeSymbolicRef({fs:t,gitdir:e,ref:n,value:i}){await o(n,async()=>t.write(W(e,n),`ref: ${i.trim()}
`,"utf8"))}static async deleteRef({fs:t,gitdir:e,ref:n}){return B.deleteRefs({fs:t,gitdir:e,refs:[n]})}static async deleteRefs({fs:t,gitdir:e,refs:n}){await Promise.all(n.map(l=>t.rm(W(e,l))));let i=await o("packed-refs",async()=>t.read(`${e}/packed-refs`,{encoding:"utf8"}));const a=Xt.from(i),c=a.refs.size;for(const l of n)a.refs.has(l)&&a.delete(l);a.refs.size<c&&(i=a.toString(),await o("packed-refs",async()=>t.write(`${e}/packed-refs`,i,{encoding:"utf8"})))}static async resolve({fs:t,gitdir:e,ref:n,depth:i=void 0}){if(i!==void 0&&(i--,i===-1))return n;if(n.startsWith("ref: "))return n=n.slice(5),B.resolve({fs:t,gitdir:e,ref:n,depth:i});if(n.length===40&&/[0-9a-f]{40}/.test(n))return n;const a=await B.packedRefs({fs:t,gitdir:e}),c=h(n).filter(l=>!rt.includes(l));for(const l of c){const p=await o(l,async()=>await t.read(`${e}/${l}`,{encoding:"utf8"})||a.get(l));if(p)return B.resolve({fs:t,gitdir:e,ref:p.trim(),depth:i})}throw new Ct(n)}static async exists({fs:t,gitdir:e,ref:n}){try{return await B.expand({fs:t,gitdir:e,ref:n}),!0}catch{return!1}}static async expand({fs:t,gitdir:e,ref:n}){if(n.length===40&&/[0-9a-f]{40}/.test(n))return n;const i=await B.packedRefs({fs:t,gitdir:e}),a=h(n);for(const c of a)if(await o(c,async()=>t.exists(`${e}/${c}`))||i.has(c))return c;throw new Ct(n)}static async expandAgainstMap({ref:t,map:e}){const n=h(t);for(const i of n)if(await e.has(i))return i;throw new Ct(t)}static resolveAgainstMap({ref:t,fullref:e=t,depth:n=void 0,map:i}){if(n!==void 0&&(n--,n===-1))return{fullref:e,oid:t};if(t.startsWith("ref: "))return t=t.slice(5),B.resolveAgainstMap({ref:t,fullref:e,depth:n,map:i});if(t.length===40&&/[0-9a-f]{40}/.test(t))return{fullref:e,oid:t};const a=h(t);for(const c of a){const l=i.get(c);if(l)return B.resolveAgainstMap({ref:l.trim(),fullref:c,depth:n,map:i})}throw new Ct(t)}static async packedRefs({fs:t,gitdir:e}){const n=await o("packed-refs",async()=>t.read(`${e}/packed-refs`,{encoding:"utf8"}));return Xt.from(n).refs}static async listRefs({fs:t,gitdir:e,filepath:n}){const i=B.packedRefs({fs:t,gitdir:e});let a=null;try{a=await t.readdirDeep(`${e}/${n}`),a=a.map(c=>c.replace(`${e}/${n}/`,""))}catch{a=[]}for(let c of(await i).keys())c.startsWith(n)&&(c=c.replace(n+"/",""),a.includes(c)||a.push(c));return a.sort(ne),a}static async listBranches({fs:t,gitdir:e,remote:n}){return n?B.listRefs({fs:t,gitdir:e,filepath:`refs/remotes/${n}`}):B.listRefs({fs:t,gitdir:e,filepath:"refs/heads"})}static async listTags({fs:t,gitdir:e}){return(await B.listRefs({fs:t,gitdir:e,filepath:"refs/tags"})).filter(i=>!i.endsWith("^{}"))}}function J(r,t){return et(g(r),g(t))}function g(r){return r.mode==="040000"?r.path+"/":r.path}function P(r){switch(r){case"040000":return"tree";case"100644":return"blob";case"100755":return"blob";case"120000":return"blob";case"160000":return"commit"}throw new A(`Unexpected GitTree entry mode: ${r}`)}function H(r){const t=[];let e=0;for(;e<r.length;){const n=r.indexOf(32,e);if(n===-1)throw new A(`GitTree: Error parsing buffer at byte location ${e}: Could not find the next space character.`);const i=r.indexOf(0,e);if(i===-1)throw new A(`GitTree: Error parsing buffer at byte location ${e}: Could not find the next null character.`);let a=r.slice(e,n).toString("utf8");a==="40000"&&(a="040000");const c=P(a),l=r.slice(n+1,i).toString("utf8");if(l.includes("\\")||l.includes("/"))throw new U(l);const p=r.slice(i+1,i+21).toString("hex");e=i+21,t.push({mode:a,path:l,oid:p,type:c})}return t}function Ot(r){if(typeof r=="number"&&(r=r.toString(8)),r.match(/^0?4.*/))return"040000";if(r.match(/^1006.*/))return"100644";if(r.match(/^1007.*/))return"100755";if(r.match(/^120.*/))return"120000";if(r.match(/^160.*/))return"160000";throw new A(`Could not understand file mode: ${r}`)}function St(r){return!r.oid&&r.sha&&(r.oid=r.sha),r.mode=Ot(r.mode),r.type||(r.type=P(r.mode)),r}class bt{constructor(t){if(Buffer.isBuffer(t))this._entries=H(t);else if(Array.isArray(t))this._entries=t.map(St);else throw new A("invalid type passed to GitTree constructor");this._entries.sort(lt)}static from(t){return new bt(t)}render(){return this._entries.map(t=>`${t.mode} ${t.type} ${t.oid}    ${t.path}`).join(`
`)}toObject(){const t=[...this._entries];return t.sort(J),Buffer.concat(t.map(e=>{const n=Buffer.from(e.mode.replace(/^0/,"")),i=Buffer.from(" "),a=Buffer.from(e.path,"utf8"),c=Buffer.from([0]),l=Buffer.from(e.oid,"hex");return Buffer.concat([n,i,a,c,l])}))}entries(){return this._entries}*[Symbol.iterator](){for(const t of this._entries)yield t}}class Gt{static wrap({type:t,object:e}){const n=`${t} ${e.length}\0`,i=n.length,a=i+e.length,c=new Uint8Array(a);for(let l=0;l<i;l++)c[l]=n.charCodeAt(l);return c.set(e,i),c}static unwrap(t){const e=t.indexOf(32),n=t.indexOf(0),i=t.slice(0,e).toString("utf8"),a=t.slice(e+1,n).toString("utf8"),c=t.length-(n+1);if(parseInt(a)!==c)throw new A(`Length mismatch: expected ${a} bytes but got ${c} instead.`);return{type:i,object:Buffer.from(t.slice(n+1))}}}async function Fe({fs:r,gitdir:t,oid:e}){const n=`objects/${e.slice(0,2)}/${e.slice(2)}`,i=await r.read(`${t}/${n}`);return i?{object:i,format:"deflated",source:n}:null}function se(r,t){const e=new L(r),n=Vt(e);if(n!==t.byteLength)throw new A(`applyDelta expected source buffer to be ${n} bytes but the provided buffer was ${t.length} bytes`);const i=Vt(e);let a;const c=ge(e,t);if(c.byteLength===i)a=c;else{a=Buffer.alloc(i);const l=new L(a);for(l.copy(c);!e.eof();)l.copy(ge(e,t));const p=l.tell();if(i!==p)throw new A(`applyDelta expected target buffer to be ${i} bytes but the resulting buffer was ${p} bytes`)}return a}function Vt(r){let t=0,e=0,n=null;do n=r.readUInt8(),t|=(n&127)<<e,e+=7;while(n&128);return t}function de(r,t,e){let n=0,i=0;for(;e--;)t&1&&(n|=r.readUInt8()<<i),t>>=1,i+=8;return n}function ge(r,t){const e=r.readUInt8(),n=128,i=15,a=112;if(e&n){const c=de(r,e&i,4);let l=de(r,(e&a)>>4,3);return l===0&&(l=65536),t.slice(c,c+l)}else return r.slice(e)}function ke(r){let t=[r];return{next(){return Promise.resolve({done:t.length===0,value:t.pop()})},return(){return t=[],{}},[Symbol.asyncIterator](){return this}}}function tr(r){return r[Symbol.asyncIterator]?r[Symbol.asyncIterator]():r[Symbol.iterator]?r[Symbol.iterator]():r.next?r:ke(r)}class er{constructor(t){if(typeof Buffer>"u")throw new Error("Missing Buffer dependency");this.stream=tr(t),this.buffer=null,this.cursor=0,this.undoCursor=0,this.started=!1,this._ended=!1,this._discardedBytes=0}eof(){return this._ended&&this.cursor===this.buffer.length}tell(){return this._discardedBytes+this.cursor}async byte(){if(!this.eof()&&(this.started||await this._init(),!(this.cursor===this.buffer.length&&(await this._loadnext(),this._ended))))return this._moveCursor(1),this.buffer[this.undoCursor]}async chunk(){if(!this.eof()&&(this.started||await this._init(),!(this.cursor===this.buffer.length&&(await this._loadnext(),this._ended))))return this._moveCursor(this.buffer.length),this.buffer.slice(this.undoCursor,this.cursor)}async read(t){if(!this.eof())return this.started||await this._init(),this.cursor+t>this.buffer.length&&(this._trim(),await this._accumulate(t)),this._moveCursor(t),this.buffer.slice(this.undoCursor,this.cursor)}async skip(t){this.eof()||(this.started||await this._init(),this.cursor+t>this.buffer.length&&(this._trim(),await this._accumulate(t)),this._moveCursor(t))}async undo(){this.cursor=this.undoCursor}async _next(){this.started=!0;let{done:t,value:e}=await this.stream.next();return t&&(this._ended=!0,!e)?Buffer.alloc(0):(e&&(e=Buffer.from(e)),e)}_trim(){this.buffer=this.buffer.slice(this.undoCursor),this.cursor-=this.undoCursor,this._discardedBytes+=this.undoCursor,this.undoCursor=0}_moveCursor(t){this.undoCursor=this.cursor,this.cursor+=t,this.cursor>this.buffer.length&&(this.cursor=this.buffer.length)}async _accumulate(t){if(this._ended)return;const e=[this.buffer];for(;this.cursor+t>pe(e);){const n=await this._next();if(this._ended)break;e.push(n)}this.buffer=Buffer.concat(e)}async _loadnext(){this._discardedBytes+=this.buffer.length,this.undoCursor=0,this.cursor=0,this.buffer=await this._next()}async _init(){this.buffer=await this._next()}}function pe(r){return r.reduce((t,e)=>t+e.length,0)}async function Te(r,t){const e=new er(r);let n=await e.read(4);if(n=n.toString("utf8"),n!=="PACK")throw new A(`Invalid PACK header '${n}'`);let i=await e.read(4);if(i=i.readUInt32BE(0),i!==2)throw new A(`Invalid packfile version: ${i}`);let a=await e.read(4);if(a=a.readUInt32BE(0),!(a<1))for(;!e.eof()&&a--;){const c=e.tell(),{type:l,length:p,ofs:y,reference:d}=await me(e),v=new N.Inflate;for(;!v.result;){const x=await e.chunk();if(!x)break;if(v.push(x,!1),v.err)throw new A(`Pako error: ${v.msg}`);if(v.result){if(v.result.length!==p)throw new A("Inflated object size is different from that stated in packfile.");await e.undo(),await e.read(x.length-v.strm.avail_in);const $=e.tell();await t({data:v.result,type:l,num:a,offset:c,end:$,reference:d,ofs:y})}}}}async function me(r){let t=await r.byte();const e=t>>4&7;let n=t&15;if(t&128){let c=4;do t=await r.byte(),n|=(t&127)<<c,c+=7;while(t&128)}let i,a;if(e===6){let c=0;i=0;const l=[];do t=await r.byte(),i|=(t&127)<<c,c+=7,l.push(t);while(t&128);a=Buffer.from(l)}return e===7&&(a=await r.read(20)),{type:e,length:n,ofs:i,reference:a}}async function De(r){return N.inflate(r)}function Ue(r){const t=[];let e=0,n=0;do{e=r.readUInt8();const i=e&127;t.push(i),n=e&128}while(n);return t.reduce((i,a)=>i+1<<7|a,-1)}function Jr(r,t){let e=t,n=4,i=null;do i=r.readUInt8(),e|=(i&127)<<n,n+=7;while(i&128);return e}class ur{constructor(t){Object.assign(this,t),this.offsetCache={}}static async fromIdx({idx:t,getExternalRefDelta:e}){const n=new L(t);if(n.slice(4).toString("hex")!=="ff744f63")return;const a=n.readUInt32BE();if(a!==2)throw new A(`Unable to read version ${a} packfile IDX. (Only version 2 supported)`);if(t.byteLength>2048*1024*1024)throw new A("To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.");n.seek(n.tell()+1020);const c=n.readUInt32BE(),l=[];for(let d=0;d<c;d++){const v=n.slice(20).toString("hex");l[d]=v}n.seek(n.tell()+4*c);const p=new Map;for(let d=0;d<c;d++)p.set(l[d],n.readUInt32BE());const y=n.slice(20).toString("hex");return new ur({hashes:l,crcs:{},offsets:p,packfileSha:y,getExternalRefDelta:e})}static async fromPack({pack:t,getExternalRefDelta:e,onProgress:n}){const i={1:"commit",2:"tree",3:"blob",4:"tag",6:"ofs-delta",7:"ref-delta"},a={},c=t.slice(-20).toString("hex"),l=[],p={},y=new Map;let d=null,v=null;await Te([t],async({data:Y,type:at,reference:ot,offset:vt,num:At})=>{d===null&&(d=At);const Bt=Math.floor((d-At)*100/d);Bt!==v&&n&&await n({phase:"Receiving objects",loaded:d-At,total:d}),v=Bt,at=i[at],["commit","tree","blob","tag"].includes(at)?a[vt]={type:at,offset:vt}:at==="ofs-delta"?a[vt]={type:at,offset:vt}:at==="ref-delta"&&(a[vt]={type:at,offset:vt})});const x=Object.keys(a).map(Number);for(const[Y,at]of x.entries()){const ot=Y+1===x.length?t.byteLength-20:x[Y+1],vt=a[at],At=I.buf(t.slice(at,ot))>>>0;vt.end=ot,vt.crc=At}const $=new ur({pack:Promise.resolve(t),packfileSha:c,crcs:p,hashes:l,offsets:y,getExternalRefDelta:e});v=null;let q=0;const tt=[0,0,0,0,0,0,0,0,0,0,0,0];for(let Y in a){Y=Number(Y);const at=Math.floor(q*100/d);at!==v&&n&&await n({phase:"Resolving deltas",loaded:q,total:d}),q++,v=at;const ot=a[Y];if(!ot.oid)try{$.readDepth=0,$.externalReadDepth=0;const{type:vt,object:At}=await $.readSlice({start:Y});tt[$.readDepth]+=1;const Bt=await pt(Gt.wrap({type:vt,object:At}));ot.oid=Bt,l.push(Bt),y.set(Bt,Y),p[Bt]=ot.crc}catch{continue}}return l.sort(),$}async toBuffer(){const t=[],e=(y,d)=>{t.push(Buffer.from(y,d))};e("ff744f63","hex"),e("00000002","hex");const n=new L(Buffer.alloc(256*4));for(let y=0;y<256;y++){let d=0;for(const v of this.hashes)parseInt(v.slice(0,2),16)<=y&&d++;n.writeUInt32BE(d)}t.push(n.buffer);for(const y of this.hashes)e(y,"hex");const i=new L(Buffer.alloc(this.hashes.length*4));for(const y of this.hashes)i.writeUInt32BE(this.crcs[y]);t.push(i.buffer);const a=new L(Buffer.alloc(this.hashes.length*4));for(const y of this.hashes)a.writeUInt32BE(this.offsets.get(y));t.push(a.buffer),e(this.packfileSha,"hex");const c=Buffer.concat(t),l=await pt(c),p=Buffer.alloc(20);return p.write(l,"hex"),Buffer.concat([c,p])}async load({pack:t}){this.pack=t}async unload(){this.pack=null}async read({oid:t}){if(!this.offsets.get(t)){if(this.getExternalRefDelta)return this.externalReadDepth++,this.getExternalRefDelta(t);throw new A(`Could not read object ${t} from packfile`)}const e=this.offsets.get(t);return this.readSlice({start:e})}async readSlice({start:t}){if(this.offsetCache[t])return Object.assign({},this.offsetCache[t]);this.readDepth++;const e={16:"commit",32:"tree",48:"blob",64:"tag",96:"ofs_delta",112:"ref_delta"};if(!this.pack)throw new A("Tried to read from a GitPackIndex with no packfile loaded into memory");const n=(await this.pack).slice(t),i=new L(n),a=i.readUInt8(),c=a&112;let l=e[c];if(l===void 0)throw new A("Unrecognized type: 0b"+c.toString(2));const p=a&15;let y=p;a&128&&(y=Jr(i,p));let v=null,x=null;if(l==="ofs_delta"){const q=Ue(i),tt=t-q;({object:v,type:l}=await this.readSlice({start:tt}))}if(l==="ref_delta"){const q=i.slice(20).toString("hex");({object:v,type:l}=await this.read({oid:q}))}const $=n.slice(i.tell());if(x=Buffer.from(await De($)),x.byteLength!==y)throw new A(`Packfile told us object would have length ${y} but it had length ${x.byteLength}`);return v&&(x=Buffer.from(se(x,v))),this.readDepth>3&&(this.offsetCache[t]={type:l,object:x}),{type:l,format:"content",object:x}}}const Qr=Symbol("PackfileCache");async function Vc({fs:r,filename:t,getExternalRefDelta:e,emitter:n,emitterPrefix:i}){const a=await r.read(t);return ur.fromIdx({idx:a,getExternalRefDelta:e})}function wn({fs:r,cache:t,filename:e,getExternalRefDelta:n,emitter:i,emitterPrefix:a}){t[Qr]||(t[Qr]=new Map);let c=t[Qr].get(e);return c||(c=Vc({fs:r,filename:e,getExternalRefDelta:n,emitter:i,emitterPrefix:a}),t[Qr].set(e,c)),c}async function Yc({fs:r,cache:t,gitdir:e,oid:n,format:i="content",getExternalRefDelta:a}){let c=await r.readdir(W(e,"objects/pack"));c=c.filter(l=>l.endsWith(".idx"));for(const l of c){const p=`${e}/objects/pack/${l}`,y=await wn({fs:r,cache:t,filename:p,getExternalRefDelta:a});if(y.error)throw new A(y.error);if(y.offsets.has(n)){if(!y.pack){const v=p.replace(/idx$/,"pack");y.pack=r.read(v)}const d=await y.read({oid:n,getExternalRefDelta:a});return d.format="content",d.source=`objects/pack/${l.replace(/idx$/,"pack")}`,d}}return null}async function oe({fs:r,cache:t,gitdir:e,oid:n,format:i="content"}){const a=d=>oe({fs:r,cache:t,gitdir:e,oid:d});let c;if(n==="4b825dc642cb6eb9a060e54bf8d69288fbee4904"&&(c={format:"wrapped",object:Buffer.from("tree 0\0")}),c||(c=await Fe({fs:r,gitdir:e,oid:n})),!c){if(c=await Yc({fs:r,cache:t,gitdir:e,oid:n,getExternalRefDelta:a}),!c)throw new Ct(n);return c}if(i==="deflated"||(c.format==="deflated"&&(c.object=Buffer.from(await De(c.object)),c.format="wrapped"),i==="wrapped"))return c;const l=await pt(c.object);if(l!==n)throw new A(`SHA check failed! Expected ${n}, computed ${l}`);const{object:p,type:y}=Gt.unwrap(c.object);if(c.type=y,c.object=p,c.format="content",i==="content")return c;throw new A(`invalid requested format "${i}"`)}class je extends D{constructor(t,e,n=!0){super(`Failed to create ${t} at ${e} because it already exists.${n?` (Hint: use 'force: true' parameter to overwrite existing ${t}.)`:""}`),this.code=this.name=je.code,this.data={noun:t,where:e,canForce:n}}}je.code="AlreadyExistsError";class kr extends D{constructor(t,e,n){super(`Found multiple ${t} matching "${e}" (${n.join(", ")}). Use a longer abbreviation length to disambiguate them.`),this.code=this.name=kr.code,this.data={nouns:t,short:e,matches:n}}}kr.code="AmbiguousError";class Rr extends D{constructor(t){super(`Your local changes to the following files would be overwritten by checkout: ${t.join(", ")}`),this.code=this.name=Rr.code,this.data={filepaths:t}}}Rr.code="CheckoutConflictError";class Br extends D{constructor(t,e){super(`Failed to checkout "${t}" because commit ${e} is not available locally. Do a git fetch to make the branch available locally.`),this.code=this.name=Br.code,this.data={ref:t,oid:e}}}Br.code="CommitNotFetchedError";class Ir extends D{constructor(){super("Empty response from git server."),this.code=this.name=Ir.code,this.data={}}}Ir.code="EmptyServerResponseError";class Tr extends D{constructor(){super("A simple fast-forward merge was not possible."),this.code=this.name=Tr.code,this.data={}}}Tr.code="FastForwardError";class Or extends D{constructor(t,e){super(`One or more branches were not updated: ${t}`),this.code=this.name=Or.code,this.data={prettyDetails:t,result:e}}}Or.code="GitPushError";class lr extends D{constructor(t,e,n){super(`HTTP Error: ${t} ${e}`),this.code=this.name=lr.code,this.data={statusCode:t,statusMessage:e,response:n}}}lr.code="HttpError";class Xe extends D{constructor(t){let e="invalid filepath";t==="leading-slash"||t==="trailing-slash"?e='"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.':t==="directory"&&(e='"filepath" should not be a directory.'),super(e),this.code=this.name=Xe.code,this.data={reason:t}}}Xe.code="InvalidFilepathError";class Le extends D{constructor(t,e){super(`"${t}" would be an invalid git reference. (Hint: a valid alternative would be "${e}".)`),this.code=this.name=Le.code,this.data={ref:t,suggestion:e}}}Le.code="InvalidRefNameError";class $r extends D{constructor(t){super(`Maximum search depth of ${t} exceeded.`),this.code=this.name=$r.code,this.data={depth:t}}}$r.code="MaxDepthError";class hr extends D{constructor(){super("Merges with conflicts are not supported yet."),this.code=this.name=hr.code,this.data={}}}hr.code="MergeNotSupportedError";class dr extends D{constructor(t,e,n,i){super(`Automatic merge failed with one or more merge conflicts in the following files: ${t.toString()}. Fix conflicts then commit the result.`),this.code=this.name=dr.code,this.data={filepaths:t,bothModified:e,deleteByUs:n,deleteByTheirs:i}}}dr.code="MergeConflictError";class Re extends D{constructor(t){super(`No name was provided for ${t} in the argument or in the .git/config file.`),this.code=this.name=Re.code,this.data={role:t}}}Re.code="MissingNameError";class Oe extends D{constructor(t){super(`The function requires a "${t}" parameter but none was provided.`),this.code=this.name=Oe.code,this.data={parameter:t}}}Oe.code="MissingParameterError";class Pr extends D{constructor(t){super('There are multiple errors that were thrown by the method. Please refer to the "errors" property to see more'),this.code=this.name=Pr.code,this.data={errors:t},this.errors=t}}Pr.code="MultipleGitError";class rr extends D{constructor(t,e){super(`Expected "${t}" but received "${e}".`),this.code=this.name=rr.code,this.data={expected:t,actual:e}}}rr.code="ParseError";class pr extends D{constructor(t){let e="";t==="not-fast-forward"?e=" because it was not a simple fast-forward":t==="tag-exists"&&(e=" because tag already exists"),super(`Push rejected${e}. Use "force: true" to override.`),this.code=this.name=pr.code,this.data={reason:t}}}pr.code="PushRejectedError";class Ve extends D{constructor(t,e){super(`Remote does not support the "${t}" so the "${e}" parameter cannot be used.`),this.code=this.name=Ve.code,this.data={capability:t,parameter:e}}}Ve.code="RemoteCapabilityError";class Cr extends D{constructor(t,e){super(`Remote did not reply using the "smart" HTTP protocol. Expected "001e# service=git-upload-pack" but received: ${t}`),this.code=this.name=Cr.code,this.data={preview:t,response:e}}}Cr.code="SmartHttpError";class Fr extends D{constructor(t,e,n){super(`Git remote "${t}" uses an unrecognized transport protocol: "${e}"`),this.code=this.name=Fr.code,this.data={url:t,transport:e,suggestion:n}}}Fr.code="UnknownTransportError";class Dr extends D{constructor(t){super(`Cannot parse remote URL: "${t}"`),this.code=this.name=Dr.code,this.data={url:t}}}Dr.code="UrlParseError";class wr extends D{constructor(){super("The operation was canceled."),this.code=this.name=wr.code,this.data={}}}wr.code="UserCanceledError";class Ur extends D{constructor(t){super(`Could not merge index: Entry for '${t}' is not up to date. Either reset the index entry to HEAD, or stage your unstaged changes.`),this.code=this.name=Ur.code,this.data={filepath:t}}}Ur.code="IndexResetError";class Nr extends D{constructor(t){super(`"${t}" does not point to any commit. You're maybe working on a repository with no commits yet. `),this.code=this.name=Nr.code,this.data={ref:t}}}Nr.code="NoCommitError";var ia=Object.freeze({__proto__:null,AlreadyExistsError:je,AmbiguousError:kr,CheckoutConflictError:Rr,CommitNotFetchedError:Br,EmptyServerResponseError:Ir,FastForwardError:Tr,GitPushError:Or,HttpError:lr,InternalError:A,InvalidFilepathError:Xe,InvalidOidError:Ht,InvalidRefNameError:Le,MaxDepthError:$r,MergeNotSupportedError:hr,MergeConflictError:dr,MissingNameError:Re,MissingParameterError:Oe,MultipleGitError:Pr,NoRefspecError:jt,NotFoundError:Ct,ObjectTypeError:Ft,ParseError:rr,PushRejectedError:pr,RemoteCapabilityError:Ve,SmartHttpError:Cr,UnknownTransportError:Fr,UnsafeFilepathError:U,UrlParseError:Dr,UserCanceledError:wr,UnmergedPathsError:C,IndexResetError:Ur,NoCommitError:Nr});function gn({name:r,email:t,timestamp:e,timezoneOffset:n}){return n=Kc(n),`${r} <${t}> ${e} ${n}`}function Kc(r){const t=Jc(Qc(r));r=Math.abs(r);const e=Math.floor(r/60);r-=e*60;let n=String(e),i=String(r);return n.length<2&&(n="0"+n),i.length<2&&(i="0"+i),(t===-1?"-":"+")+n+i}function Jc(r){return Math.sign(r)||(Object.is(r,-0)?-1:1)}function Qc(r){return r===0?r:-r}function Ze(r){return r=r.replace(/\r/g,""),r=r.replace(/^\n+/,""),r=r.replace(/\n+$/,"")+`
`,r}function tn(r){const[,t,e,n,i]=r.match(/^(.*) <(.*)> (.*) (.*)$/);return{name:t,email:e,timestamp:Number(n),timezoneOffset:tf(i)}}function tf(r){let[,t,e,n]=r.match(/(\+|-)(\d\d)(\d\d)/);return n=(t==="+"?1:-1)*(Number(e)*60+Number(n)),ef(n)}function ef(r){return r===0?r:-r}class Ie{constructor(t){if(typeof t=="string")this._tag=t;else if(Buffer.isBuffer(t))this._tag=t.toString("utf8");else if(typeof t=="object")this._tag=Ie.render(t);else throw new A("invalid type passed to GitAnnotatedTag constructor")}static from(t){return new Ie(t)}static render(t){return`object ${t.object}
type ${t.type}
tag ${t.tag}
tagger ${gn(t.tagger)}

${t.message}
${t.gpgsig?t.gpgsig:""}`}justHeaders(){return this._tag.slice(0,this._tag.indexOf(`

`))}message(){const t=this.withoutSignature();return t.slice(t.indexOf(`

`)+2)}parse(){return Object.assign(this.headers(),{message:this.message(),gpgsig:this.gpgsig()})}render(){return this._tag}headers(){const t=this.justHeaders().split(`
`),e=[];for(const i of t)i[0]===" "?e[e.length-1]+=`
`+i.slice(1):e.push(i);const n={};for(const i of e){const a=i.slice(0,i.indexOf(" ")),c=i.slice(i.indexOf(" ")+1);Array.isArray(n[a])?n[a].push(c):n[a]=c}return n.tagger&&(n.tagger=tn(n.tagger)),n.committer&&(n.committer=tn(n.committer)),n}withoutSignature(){const t=Ze(this._tag);return t.indexOf(`
-----BEGIN PGP SIGNATURE-----`)===-1?t:t.slice(0,t.lastIndexOf(`
-----BEGIN PGP SIGNATURE-----`))}gpgsig(){if(this._tag.indexOf(`
-----BEGIN PGP SIGNATURE-----`)===-1)return;const t=this._tag.slice(this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"),this._tag.indexOf("-----END PGP SIGNATURE-----")+27);return Ze(t)}payload(){return this.withoutSignature()+`
`}toObject(){return Buffer.from(this._tag,"utf8")}static async sign(t,e,n){const i=t.payload();let{signature:a}=await e({payload:i,secretKey:n});a=Ze(a);const c=i+a;return Ie.from(c)}}function mn(r){return r.trim().split(`
`).map(t=>" "+t).join(`
`)+`
`}function rf(r){return r.split(`
`).map(t=>t.replace(/^ /,"")).join(`
`)}class ce{constructor(t){if(typeof t=="string")this._commit=t;else if(Buffer.isBuffer(t))this._commit=t.toString("utf8");else if(typeof t=="object")this._commit=ce.render(t);else throw new A("invalid type passed to GitCommit constructor")}static fromPayloadSignature({payload:t,signature:e}){const n=ce.justHeaders(t),i=ce.justMessage(t),a=Ze(n+`
gpgsig`+mn(e)+`
`+i);return new ce(a)}static from(t){return new ce(t)}toObject(){return Buffer.from(this._commit,"utf8")}headers(){return this.parseHeaders()}message(){return ce.justMessage(this._commit)}parse(){return Object.assign({message:this.message()},this.headers())}static justMessage(t){return Ze(t.slice(t.indexOf(`

`)+2))}static justHeaders(t){return t.slice(0,t.indexOf(`

`))}parseHeaders(){const t=ce.justHeaders(this._commit).split(`
`),e=[];for(const i of t)i[0]===" "?e[e.length-1]+=`
`+i.slice(1):e.push(i);const n={parent:[]};for(const i of e){const a=i.slice(0,i.indexOf(" ")),c=i.slice(i.indexOf(" ")+1);Array.isArray(n[a])?n[a].push(c):n[a]=c}return n.author&&(n.author=tn(n.author)),n.committer&&(n.committer=tn(n.committer)),n}static renderHeaders(t){let e="";if(t.tree?e+=`tree ${t.tree}
`:e+=`tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
`,t.parent){if(t.parent.length===void 0)throw new A("commit 'parent' property should be an array");for(const a of t.parent)e+=`parent ${a}
`}const n=t.author;e+=`author ${gn(n)}
`;const i=t.committer||t.author;return e+=`committer ${gn(i)}
`,t.gpgsig&&(e+="gpgsig"+mn(t.gpgsig)),e}static render(t){return ce.renderHeaders(t)+`
`+Ze(t.message)}render(){return this._commit}withoutSignature(){const t=Ze(this._commit);if(t.indexOf(`
gpgsig`)===-1)return t;const e=t.slice(0,t.indexOf(`
gpgsig`)),n=t.slice(t.indexOf(`-----END PGP SIGNATURE-----
`)+28);return Ze(e+`
`+n)}isolateSignature(){const t=this._commit.slice(this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),this._commit.indexOf("-----END PGP SIGNATURE-----")+27);return rf(t)}static async sign(t,e,n){const i=t.withoutSignature(),a=ce.justMessage(t._commit);let{signature:c}=await e({payload:i,secretKey:n});c=Ze(c);const p=ce.justHeaders(t._commit)+`
gpgsig`+mn(c)+`
`+a;return ce.from(p)}}async function gr({fs:r,cache:t,gitdir:e,oid:n}){if(n==="4b825dc642cb6eb9a060e54bf8d69288fbee4904")return{tree:bt.from([]),oid:n};const{type:i,object:a}=await oe({fs:r,cache:t,gitdir:e,oid:n});if(i==="tag")return n=Ie.from(a).parse().object,gr({fs:r,cache:t,gitdir:e,oid:n});if(i==="commit")return n=ce.from(a).parse().tree,gr({fs:r,cache:t,gitdir:e,oid:n});if(i!=="tree")throw new Ft(n,i,"tree");return{tree:bt.from(a),oid:n}}class nf{constructor({fs:t,gitdir:e,ref:n,cache:i}){this.fs=t,this.cache=i,this.gitdir=e,this.mapPromise=(async()=>{const c=new Map;let l;try{l=await B.resolve({fs:t,gitdir:e,ref:n})}catch(y){y instanceof Ct&&(l="4b825dc642cb6eb9a060e54bf8d69288fbee4904")}const p=await gr({fs:t,cache:this.cache,gitdir:e,oid:l});return p.type="tree",p.mode="40000",c.set(".",p),c})();const a=this;this.ConstructEntry=class{constructor(l){this._fullpath=l,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return a.type(this)}async mode(){return a.mode(this)}async stat(){return a.stat(this)}async content(){return a.content(this)}async oid(){return a.oid(this)}}}async readdir(t){const e=t._fullpath,{fs:n,cache:i,gitdir:a}=this,c=await this.mapPromise,l=c.get(e);if(!l)throw new Error(`No obj for ${e}`);const p=l.oid;if(!p)throw new Error(`No oid for obj ${JSON.stringify(l)}`);if(l.type!=="tree")return null;const{type:y,object:d}=await oe({fs:n,cache:i,gitdir:a,oid:p});if(y!==l.type)throw new Ft(p,y,l.type);const v=bt.from(d);for(const x of v)c.set(W(e,x.path),x);return v.entries().map(x=>W(e,x.path))}async type(t){if(t._type===!1){const e=await this.mapPromise,{type:n}=e.get(t._fullpath);t._type=n}return t._type}async mode(t){if(t._mode===!1){const e=await this.mapPromise,{mode:n}=e.get(t._fullpath);t._mode=Z(parseInt(n,8))}return t._mode}async stat(t){}async content(t){if(t._content===!1){const e=await this.mapPromise,{fs:n,cache:i,gitdir:a}=this,l=e.get(t._fullpath).oid,{type:p,object:y}=await oe({fs:n,cache:i,gitdir:a,oid:l});p!=="blob"?t._content=void 0:t._content=new Uint8Array(y)}return t._content}async oid(t){if(t._oid===!1){const n=(await this.mapPromise).get(t._fullpath);t._oid=n.oid}return t._oid}}function Pe({ref:r="HEAD"}={}){const t=Object.create(null);return Object.defineProperty(t,te,{value:function({fs:e,gitdir:n,cache:i}){return new nf({fs:e,gitdir:n,ref:r,cache:i})}}),Object.freeze(t),t}class af{constructor({fs:t,dir:e,gitdir:n,cache:i}){this.fs=t,this.cache=i,this.dir=e,this.gitdir=n,this.config=null;const a=this;this.ConstructEntry=class{constructor(l){this._fullpath=l,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return a.type(this)}async mode(){return a.mode(this)}async stat(){return a.stat(this)}async content(){return a.content(this)}async oid(){return a.oid(this)}}}async readdir(t){const e=t._fullpath,{fs:n,dir:i}=this,a=await n.readdir(W(i,e));return a===null?null:a.map(c=>W(e,c))}async type(t){return t._type===!1&&await t.stat(),t._type}async mode(t){return t._mode===!1&&await t.stat(),t._mode}async stat(t){if(t._stat===!1){const{fs:e,dir:n}=this;let i=await e.lstat(`${n}/${t._fullpath}`);if(!i)throw new Error(`ENOENT: no such file or directory, lstat '${t._fullpath}'`);let a=i.isDirectory()?"tree":"blob";a==="blob"&&!i.isFile()&&!i.isSymbolicLink()&&(a="special"),t._type=a,i=G(i),t._mode=i.mode,i.size===-1&&t._actualSize&&(i.size=t._actualSize),t._stat=i}return t._stat}async content(t){if(t._content===!1){const{fs:e,dir:n,gitdir:i}=this;if(await t.type()==="tree")t._content=void 0;else{let a;if(await t.mode()>>12===10)a=await e.readlink(`${n}/${t._fullpath}`);else{const l=await(await this._getGitConfig(e,i)).get("core.autocrlf");a=await e.read(`${n}/${t._fullpath}`,{autocrlf:l})}t._actualSize=a.length,t._stat&&t._stat.size===-1&&(t._stat.size=t._actualSize),t._content=new Uint8Array(a)}}return t._content}async oid(t){if(t._oid===!1){const e=this,{fs:n,gitdir:i,cache:a}=this;let c;await ft.acquire({fs:n,gitdir:i,cache:a},async function(l){const p=l.entriesMap.get(t._fullpath),y=await t.stat(),v=await(await e._getGitConfig(n,i)).get("core.filemode"),x=typeof process<"u"?process.platform!=="win32":!0;if(!p||mt(y,p,v,x)){const $=await t.content();$===void 0?c=void 0:(c=await pt(Gt.wrap({type:"blob",object:$})),p&&c===p.oid&&(!v||y.mode===p.mode)&&mt(y,p,v,x)&&l.insert({filepath:t._fullpath,stats:y,oid:c}))}else c=p.oid}),t._oid=c}return t._oid}async _getGitConfig(t,e){return this.config?this.config:(this.config=await z.get({fs:t,gitdir:e}),this.config)}}function mr(){const r=Object.create(null);return Object.defineProperty(r,te,{value:function({fs:t,dir:e,gitdir:n,cache:i}){return new af({fs:t,dir:e,gitdir:n,cache:i})}}),Object.freeze(r),r}function of(r,t){const e=t-r;return Array.from({length:e},(n,i)=>r+i)}const aa=typeof Array.prototype.flat>"u"?r=>r.reduce((t,e)=>t.concat(e),[]):r=>r.flat();class sf{constructor(){this.value=null}consider(t){t!=null&&(this.value===null?this.value=t:t<this.value&&(this.value=t))}reset(){this.value=null}}function*cf(r){const t=new sf;let e;const n=[],i=r.length;for(let a=0;a<i;a++)n[a]=r[a].next().value,n[a]!==void 0&&t.consider(n[a]);if(t.value!==null)for(;;){const a=[];e=t.value,t.reset();for(let c=0;c<i;c++)n[c]!==void 0&&n[c]===e?(a[c]=n[c],n[c]=r[c].next().value):a[c]=null,n[c]!==void 0&&t.consider(n[c]);if(yield a,t.value===null)return}}async function Ye({fs:r,cache:t,dir:e,gitdir:n,trees:i,map:a=async(p,y)=>y,reduce:c=async(p,y)=>{const d=aa(y);return p!==void 0&&d.unshift(p),d},iterate:l=(p,y)=>Promise.all([...y].map(p))}){const p=i.map($=>$[te]({fs:r,dir:e,gitdir:n,cache:t})),y=new Array(p.length).fill("."),d=of(0,p.length),v=async $=>{d.forEach(Y=>{const at=$[Y];$[Y]=at&&new p[Y].ConstructEntry(at)});const tt=(await Promise.all(d.map(Y=>{const at=$[Y];return at?p[Y].readdir(at):[]}))).map(Y=>(Y===null?[]:Y)[Symbol.iterator]());return{entries:$,children:cf(tt)}},x=async $=>{const{entries:q,children:tt}=await v($),Y=q.find(ot=>ot&&ot._fullpath)._fullpath,at=await a(Y,q);if(at!==null){let ot=await l(x,tt);return ot=ot.filter(vt=>vt!==void 0),c(at,ot)}};return x(y)}async function yn(r,t){const e=await r.readdir(t);e==null?await r.rm(t):e.length?await Promise.all(e.map(n=>{const i=W(t,n);return r.lstat(i).then(a=>{if(a)return a.isDirectory()?yn(r,i):r.rm(i)})})).then(()=>r.rmdir(t)):await r.rmdir(t)}function ff(r){return uf(r)&&oa(r.then)&&oa(r.catch)}function uf(r){return r&&typeof r=="object"}function oa(r){return typeof r=="function"}function sa(r){return ff((e=>{try{return e.readFile().catch(n=>n)}catch(n){return n}})(r))}const ca=["readFile","writeFile","mkdir","rmdir","unlink","stat","lstat","readdir","readlink","symlink"];function fa(r,t){if(sa(t))for(const e of ca)r[`_${e}`]=t[e].bind(t);else for(const e of ca)r[`_${e}`]=T(t[e].bind(t));sa(t)?(t.cp&&(r._cp=t.cp.bind(t)),t.rm?r._rm=t.rm.bind(t):t.rmdir.length>1?r._rm=t.rmdir.bind(t):r._rm=yn.bind(null,r)):(t.cp&&(r._cp=T(t.cp.bind(t))),t.rm?r._rm=T(t.rm.bind(t)):t.rmdir.length>2?r._rm=T(t.rmdir.bind(t)):r._rm=yn.bind(null,r))}class Tt{constructor(t){if(typeof t._original_unwrapped_fs<"u")return t;const e=Object.getOwnPropertyDescriptor(t,"promises");e&&e.enumerable?fa(this,t.promises):fa(this,t),this._original_unwrapped_fs=t}async exists(t,e={}){try{return await this._stat(t),!0}catch(n){if(n.code==="ENOENT"||n.code==="ENOTDIR"||(n.code||"").includes("ENS"))return!1;throw console.log('Unhandled error in "FileSystem.exists()" function',n),n}}async read(t,e={}){try{let n=await this._readFile(t,e);if(e.autocrlf==="true")try{n=new TextDecoder("utf8",{fatal:!0}).decode(n),n=n.replace(/\r\n/g,`
`),n=new TextEncoder().encode(n)}catch{}return typeof n!="string"&&(n=Buffer.from(n)),n}catch{return null}}async write(t,e,n={}){try{await this._writeFile(t,e,n)}catch{await this.mkdir(Rt(t)),await this._writeFile(t,e,n)}}async mkdir(t,e=!1){try{await this._mkdir(t)}catch(n){if(n===null||n.code==="EEXIST")return;if(e)throw n;if(n.code==="ENOENT"){const i=Rt(t);if(i==="."||i==="/"||i===t)throw n;await this.mkdir(i),await this.mkdir(t,!0)}}}async rm(t){try{await this._unlink(t)}catch(e){if(e.code!=="ENOENT")throw e}}async rmdir(t,e){try{e&&e.recursive?await this._rm(t,e):await this._rmdir(t)}catch(n){if(n.code!=="ENOENT")throw n}}async readdir(t){try{const e=await this._readdir(t);return e.sort(et),e}catch(e){return e.code==="ENOTDIR"?null:[]}}async readdirDeep(t){const e=await this._readdir(t);return(await Promise.all(e.map(async i=>{const a=t+"/"+i;return(await this._stat(a)).isDirectory()?this.readdirDeep(a):a}))).reduce((i,a)=>i.concat(a),[])}async lstat(t){try{return await this._lstat(t)}catch(e){if(e.code==="ENOENT"||(e.code||"").includes("ENS"))return null;throw e}}async readlink(t,e={encoding:"buffer"}){try{const n=await this._readlink(t,e);return Buffer.isBuffer(n)?n:Buffer.from(n)}catch(n){if(n.code==="ENOENT"||(n.code||"").includes("ENS"))return null;throw n}}async writelink(t,e){return this._symlink(e.toString("utf8"),t)}}function M(r,t){if(t===void 0)throw new Oe(r)}async function $t({fsp:r,dotgit:t}){M("fsp",r),M("dotgit",t);const e=await r._stat(t).catch(()=>({isFile:()=>!1,isDirectory:()=>!1}));return e.isDirectory()?t:e.isFile()?r._readFile(t,"utf8").then(n=>n.trimRight().substr(8)).then(n=>W(Rt(t),n)):t}async function en(r,t){return!r&&!t?!1:r&&!t||!r&&t?!0:!(await r.type()==="tree"&&await t.type()==="tree"||await r.type()===await t.type()&&await r.mode()===await t.mode()&&await r.oid()===await t.oid())}async function ua({fs:r,dir:t,gitdir:e=W(t,".git"),commit:n="HEAD",cache:i={}}){try{M("fs",r),M("dir",t),M("gitdir",e);const a=new Tt(r),c=[Pe({ref:n}),mr(),qt()];let l=[];const p=await $t({fsp:a,dotgit:e});await ft.acquire({fs:a,gitdir:p,cache:i},async function(d){l=d.unmergedPaths});const y=await Ye({fs:a,cache:i,dir:t,gitdir:p,trees:c,map:async function(d,[v,x,$]){const q=!await en(x,$),tt=l.includes(d),Y=!await en($,v);if(q||tt)return v?{path:d,mode:await v.mode(),oid:await v.oid(),type:await v.type(),content:await v.content()}:void 0;if(Y)return!1;throw new Ur(d)}});await ft.acquire({fs:a,gitdir:p,cache:i},async function(d){for(const v of y)if(v!==!1){if(!v){await a.rmdir(`${t}/${v.path}`,{recursive:!0}),d.delete({filepath:v.path});continue}if(v.type==="blob"){const x=new TextDecoder().decode(v.content);await a.write(`${t}/${v.path}`,x,{mode:v.mode}),d.insert({filepath:v.path,oid:v.oid,stage:0})}}})}catch(a){throw a.caller="git.abortMerge",a}}class yr{static async isIgnored({fs:t,dir:e,gitdir:n=W(e,".git"),filepath:i}){if(Ut(i)===".git")return!0;if(i===".")return!1;let a="";const c=W(n,"info","exclude");await t.exists(c)&&(a=await t.read(c,"utf8"));const l=[{gitignore:W(e,".gitignore"),filepath:i}],p=i.split("/").filter(Boolean);for(let d=1;d<p.length;d++){const v=p.slice(0,d).join("/"),x=p.slice(d).join("/");l.push({gitignore:W(e,v,".gitignore"),filepath:x})}let y=!1;for(const d of l){let v;try{v=await t.read(d.gitignore,"utf8")}catch(q){if(q.code==="NOENT")continue}const x=R().add(a);x.add(v);const $=Rt(d.filepath);if($!=="."&&x.ignores($))return!0;y?y=!x.test(d.filepath).unignored:y=x.test(d.filepath).ignored}return y}}async function lf({fs:r,gitdir:t,object:e,format:n,oid:i}){const a=`objects/${i.slice(0,2)}/${i.slice(2)}`,c=`${t}/${a}`;await r.exists(c)||await r.write(c,e)}let _n=null;async function la(r){return _n===null&&(_n=df()),_n?hf(r):N.deflate(r)}async function hf(r){const t=new CompressionStream("deflate"),e=new Blob([r]).stream().pipeThrough(t);return new Uint8Array(await new Response(e).arrayBuffer())}function df(){try{return new CompressionStream("deflate").writable.close(),new Blob([]).stream().cancel(),!0}catch{return!1}}async function $e({fs:r,gitdir:t,type:e,object:n,format:i="content",oid:a=void 0,dryRun:c=!1}){return i!=="deflated"&&(i!=="wrapped"&&(n=Gt.wrap({type:e,object:n})),a=await pt(n),n=Buffer.from(await la(n))),c||await lf({fs:r,gitdir:t,object:n,format:"deflated",oid:a}),a}function ha(r){let t;for(;~(t=r.indexOf(92));)r[t]=47;return r}async function da({fs:r,dir:t,gitdir:e=W(t,".git"),filepath:n,cache:i={},force:a=!1,parallel:c=!0}){try{M("fs",r),M("dir",t),M("gitdir",e),M("filepath",n);const l=new Tt(r),p=await $t({fsp:l,dotgit:e});await ft.acquire({fs:l,gitdir:p,cache:i},async y=>{const v=await(await z.get({fs:l,gitdir:p})).get("core.autocrlf");return vn({dir:t,gitdir:p,fs:l,filepath:n,index:y,force:a,parallel:c,autocrlf:v})})}catch(l){throw l.caller="git.add",l}}async function vn({dir:r,gitdir:t,fs:e,filepath:n,index:i,force:a,parallel:c,autocrlf:l}){n=Array.isArray(n)?n:[n];const p=n.map(async x=>{if(!a&&await yr.isIgnored({fs:e,dir:r,gitdir:t,filepath:x}))return;const $=await e.lstat(W(r,x));if(!$)throw new Ct(x);if($.isDirectory()){const q=await e.readdir(W(r,x));if(c){const tt=q.map(Y=>vn({dir:r,gitdir:t,fs:e,filepath:[W(x,Y)],index:i,force:a,parallel:c,autocrlf:l}));await Promise.all(tt)}else for(const tt of q)await vn({dir:r,gitdir:t,fs:e,filepath:[W(x,tt)],index:i,force:a,parallel:c,autocrlf:l})}else{const q=$.isSymbolicLink()?await e.readlink(W(r,x)).then(ha):await e.read(W(r,x),{autocrlf:l});if(q===null)throw new Ct(x);const tt=await $e({fs:e,gitdir:t,type:"blob",object:q});i.insert({filepath:x,stats:$,oid:tt})}}),y=await Promise.allSettled(p),d=y.filter(x=>x.status==="rejected").map(x=>x.reason);if(d.length>1)throw new Pr(d);if(d.length===1)throw d[0];return y.filter(x=>x.status==="fulfilled"&&x.value).map(x=>x.value)}async function Mr({fs:r,gitdir:t,path:e}){return(await z.get({fs:r,gitdir:t})).get(e)}function pa(r,...t){for(const e of t)if(e)for(const n of Object.keys(e)){const i=e[n];i!==void 0&&(r[n]=i)}return r}async function Ke({fs:r,gitdir:t,author:e,commit:n}){const i=Math.floor(Date.now()/1e3),a={name:await Mr({fs:r,gitdir:t,path:"user.name"}),email:await Mr({fs:r,gitdir:t,path:"user.email"})||"",timestamp:i,timezoneOffset:new Date(i*1e3).getTimezoneOffset()},c=pa({},a,n?n.author:void 0,e);if(c.name!==void 0)return c}async function _r({fs:r,gitdir:t,author:e,committer:n,commit:i}){const a=Math.floor(Date.now()/1e3),c={name:await Mr({fs:r,gitdir:t,path:"user.name"}),email:await Mr({fs:r,gitdir:t,path:"user.email"})||"",timestamp:a,timezoneOffset:new Date(a*1e3).getTimezoneOffset()},l=pa({},c,i?i.committer:void 0,e,n);if(l.name!==void 0)return l}async function wa({fs:r,cache:t,gitdir:e,oid:n}){const{type:i,object:a}=await oe({fs:r,cache:t,gitdir:e,oid:n});if(i==="tag")return n=Ie.from(a).parse().object,wa({fs:r,cache:t,gitdir:e,oid:n});if(i!=="commit")throw new Ft(n,i,"commit");return{commit:ce.from(a),oid:n}}async function vr({fs:r,cache:t,gitdir:e,oid:n}){const{commit:i,oid:a}=await wa({fs:r,cache:t,gitdir:e,oid:n});return{oid:a,commit:i.parse(),payload:i.withoutSignature()}}async function rn({fs:r,cache:t,onSign:e,gitdir:n,message:i,author:a,committer:c,signingKey:l,amend:p=!1,dryRun:y=!1,noUpdateBranch:d=!1,ref:v,parent:x,tree:$}){let q=!1,tt=!1;v||(tt=!(await r.read(`${n}/HEAD`,{encoding:"utf8"})).startsWith("ref:"),v=await B.resolve({fs:r,gitdir:n,ref:"HEAD",depth:2}));let Y,at;try{Y=await B.resolve({fs:r,gitdir:n,ref:v}),at=await vr({fs:r,gitdir:n,oid:Y,cache:{}})}catch{q=!0}if(p&&q)throw new Nr(v);const ot=p?await Ke({fs:r,gitdir:n,author:a,commit:at.commit}):await Ke({fs:r,gitdir:n,author:a});if(!ot)throw new Re("author");const vt=p?await _r({fs:r,gitdir:n,author:ot,committer:c,commit:at.commit}):await _r({fs:r,gitdir:n,author:ot,committer:c});if(!vt)throw new Re("committer");return ft.acquire({fs:r,gitdir:n,cache:t,allowUnmerged:!1},async function(At){const It=Nt(At.entries).get(".");if($||($=await ga({fs:r,gitdir:n,inode:It,dryRun:y})),x?x=await Promise.all(x.map(xt=>B.resolve({fs:r,gitdir:n,ref:xt}))):p?x=at.commit.parent:x=Y?[Y]:[],!i)if(p)i=at.commit.message;else throw new Oe("message");let wt=ce.from({tree:$,parent:x,author:ot,committer:vt,message:i});l&&(wt=await ce.sign(wt,e,l));const yt=await $e({fs:r,gitdir:n,type:"commit",object:wt.toObject(),dryRun:y});return!d&&!y&&await B.writeRef({fs:r,gitdir:n,ref:tt?"HEAD":v,value:yt}),yt})}async function ga({fs:r,gitdir:t,inode:e,dryRun:n}){const i=e.children;for(const p of i)p.type==="tree"&&(p.metadata.mode="040000",p.metadata.oid=await ga({fs:r,gitdir:t,inode:p,dryRun:n}));const a=i.map(p=>({mode:p.metadata.mode,path:p.basename,oid:p.metadata.oid,type:p.type})),c=bt.from(a);return await $e({fs:r,gitdir:t,type:"tree",object:c.toObject(),dryRun:n})}async function jr({fs:r,cache:t,gitdir:e,oid:n,filepath:i}){if(i.startsWith("/"))throw new Xe("leading-slash");if(i.endsWith("/"))throw new Xe("trailing-slash");const a=n,c=await gr({fs:r,cache:t,gitdir:e,oid:n}),l=c.tree;if(i==="")n=c.oid;else{const p=i.split("/");n=await ma({fs:r,cache:t,gitdir:e,tree:l,pathArray:p,oid:a,filepath:i})}return n}async function ma({fs:r,cache:t,gitdir:e,tree:n,pathArray:i,oid:a,filepath:c}){const l=i.shift();for(const p of n)if(p.path===l){if(i.length===0)return p.oid;{const{type:y,object:d}=await oe({fs:r,cache:t,gitdir:e,oid:p.oid});if(y!=="tree")throw new Ft(a,y,"tree",c);return n=bt.from(d),ma({fs:r,cache:t,gitdir:e,tree:n,pathArray:i,oid:a,filepath:c})}}throw new Ct(`file or directory found at "${a}:${c}"`)}async function br({fs:r,cache:t,gitdir:e,oid:n,filepath:i=void 0}){i!==void 0&&(n=await jr({fs:r,cache:t,gitdir:e,oid:n,filepath:i}));const{tree:a,oid:c}=await gr({fs:r,cache:t,gitdir:e,oid:n});return{oid:c,tree:a.entries()}}async function Lr({fs:r,gitdir:t,tree:e}){const n=bt.from(e).toObject();return await $e({fs:r,gitdir:t,type:"tree",object:n,format:"content"})}async function pf({fs:r,cache:t,onSign:e,gitdir:n,ref:i,oid:a,note:c,force:l,author:p,committer:y,signingKey:d}){let v;try{v=await B.resolve({gitdir:n,fs:r,ref:i})}catch(at){if(!(at instanceof Ct))throw at}let $=(await br({fs:r,cache:t,gitdir:n,oid:v||"4b825dc642cb6eb9a060e54bf8d69288fbee4904"})).tree;if(l)$=$.filter(at=>at.path!==a);else for(const at of $)if(at.path===a)throw new je("note",a);typeof c=="string"&&(c=Buffer.from(c,"utf8"));const q=await $e({fs:r,gitdir:n,type:"blob",object:c,format:"content"});$.push({mode:"100644",path:a,oid:q,type:"blob"});const tt=await Lr({fs:r,gitdir:n,tree:$});return await rn({fs:r,cache:t,onSign:e,gitdir:n,ref:i,tree:tt,parent:v&&[v],message:`Note added by 'isomorphic-git addNote'
`,author:p,committer:y,signingKey:d})}async function ya({fs:r,onSign:t,dir:e,gitdir:n=W(e,".git"),ref:i="refs/notes/commits",oid:a,note:c,force:l,author:p,committer:y,signingKey:d,cache:v={}}){try{M("fs",r),M("gitdir",n),M("oid",a),M("note",c),d&&M("onSign",t);const x=new Tt(r),$=await Ke({fs:x,gitdir:n,author:p});if(!$)throw new Re("author");const q=await _r({fs:x,gitdir:n,author:$,committer:y});if(!q)throw new Re("committer");const tt=await $t({fsp:x,dotgit:n});return await pf({fs:x,cache:v,onSign:t,gitdir:tt,ref:i,oid:a,note:c,force:l,author:$,committer:q,signingKey:d})}catch(x){throw x.caller="git.addNote",x}}const wf=/(^|[/.])([/.]|$)|^@$|@{|[\x00-\x20\x7f~^:?*[\\]|\.lock(\/|$)/;function qr(r,t){if(typeof r!="string")throw new TypeError("Reference name must be a string");return!wf.test(r)&&!0}async function _a({fs:r,gitdir:t,remote:e,url:n,force:i}){if(!qr(e))throw new Le(e,m.clean(e));const a=await z.get({fs:r,gitdir:t});if(!i&&(await a.getSubsections("remote")).includes(e)&&n!==await a.get(`remote.${e}.url`))throw new je("remote",e);await a.set(`remote.${e}.url`,n),await a.set(`remote.${e}.fetch`,`+refs/heads/*:refs/remotes/${e}/*`),await z.save({fs:r,gitdir:t,config:a})}async function va({fs:r,dir:t,gitdir:e=W(t,".git"),remote:n,url:i,force:a=!1}){try{M("fs",r),M("gitdir",e),M("remote",n),M("url",i);const c=new Tt(r),l=await $t({fsp:c,dotgit:e});return await _a({fs:c,gitdir:l,remote:n,url:i,force:a})}catch(c){throw c.caller="git.addRemote",c}}async function gf({fs:r,cache:t,onSign:e,gitdir:n,ref:i,tagger:a,message:c=i,gpgsig:l,object:p,signingKey:y,force:d=!1}){if(i=i.startsWith("refs/tags/")?i:`refs/tags/${i}`,!d&&await B.exists({fs:r,gitdir:n,ref:i}))throw new je("tag",i);const v=await B.resolve({fs:r,gitdir:n,ref:p||"HEAD"}),{type:x}=await oe({fs:r,cache:t,gitdir:n,oid:v});let $=Ie.from({object:v,type:x,tag:i.replace("refs/tags/",""),tagger:a,message:c,gpgsig:l});y&&($=await Ie.sign($,e,y));const q=await $e({fs:r,gitdir:n,type:"tag",object:$.toObject()});await B.writeRef({fs:r,gitdir:n,ref:i,value:q})}async function ba({fs:r,onSign:t,dir:e,gitdir:n=W(e,".git"),ref:i,tagger:a,message:c=i,gpgsig:l,object:p,signingKey:y,force:d=!1,cache:v={}}){try{M("fs",r),M("gitdir",n),M("ref",i),y&&M("onSign",t);const x=new Tt(r),$=await $t({fsp:x,dotgit:n}),q=await Ke({fs:x,gitdir:$,author:a});if(!q)throw new Re("tagger");return await gf({fs:x,cache:v,onSign:t,gitdir:$,ref:i,tagger:q,message:c,gpgsig:l,object:p,signingKey:y,force:d})}catch(x){throw x.caller="git.annotatedTag",x}}async function mf({fs:r,gitdir:t,ref:e,object:n,checkout:i=!1,force:a=!1}){if(!qr(e))throw new Le(e,m.clean(e));const c=`refs/heads/${e}`;if(!a&&await B.exists({fs:r,gitdir:t,ref:c}))throw new je("branch",e,!1);let l;try{l=await B.resolve({fs:r,gitdir:t,ref:n||"HEAD"})}catch{}l&&await B.writeRef({fs:r,gitdir:t,ref:c,value:l}),i&&await B.writeSymbolicRef({fs:r,gitdir:t,ref:"HEAD",value:c})}async function xa({fs:r,dir:t,gitdir:e=W(t,".git"),ref:n,object:i,checkout:a=!1,force:c=!1}){try{M("fs",r),M("gitdir",e),M("ref",n);const l=new Tt(r),p=await $t({fsp:l,dotgit:e});return await mf({fs:l,gitdir:p,ref:n,object:i,checkout:a,force:c})}catch(l){throw l.caller="git.branch",l}}const Ea=(r,t)=>r==="."||t==null||t.length===0||t==="."?!0:t.length>=r.length?t.startsWith(r):r.startsWith(t);async function bn({fs:r,cache:t,onProgress:e,onPostCheckout:n,dir:i,gitdir:a,remote:c,ref:l,filepaths:p,noCheckout:y,noUpdateHead:d,dryRun:v,force:x,track:$=!0,nonBlocking:q=!1,batchSize:tt=100}){let Y;if(n)try{Y=await B.resolve({fs:r,gitdir:a,ref:"HEAD"})}catch{Y="0000000000000000000000000000000000000000"}let at;try{at=await B.resolve({fs:r,gitdir:a,ref:l})}catch(ot){if(l==="HEAD")throw ot;const vt=`${c}/${l}`;if(at=await B.resolve({fs:r,gitdir:a,ref:vt}),$){const At=await z.get({fs:r,gitdir:a});await At.set(`branch.${l}.remote`,c),await At.set(`branch.${l}.merge`,`refs/heads/${l}`),await z.save({fs:r,gitdir:a,config:At})}await B.writeRef({fs:r,gitdir:a,ref:`refs/heads/${l}`,value:at})}if(!y){let ot;try{ot=await yf({fs:r,cache:t,onProgress:e,dir:i,gitdir:a,ref:l,force:x,filepaths:p})}catch(wt){throw wt instanceof Ct&&wt.data.what===at?new Br(l,at):wt}const vt=ot.filter(([wt])=>wt==="conflict").map(([wt,yt])=>yt);if(vt.length>0)throw new Rr(vt);const At=ot.filter(([wt])=>wt==="error").map(([wt,yt])=>yt);if(At.length>0)throw new A(At.join(", "));if(v){n&&await n({previousHead:Y,newHead:at,type:p!=null&&p.length>0?"file":"branch"});return}let Bt=0;const It=ot.length;if(await ft.acquire({fs:r,gitdir:a,cache:t},async function(wt){await Promise.all(ot.filter(([yt])=>yt==="delete"||yt==="delete-index").map(async function([yt,xt]){const Lt=`${i}/${xt}`;yt==="delete"&&await r.rm(Lt),wt.delete({filepath:xt}),e&&await e({phase:"Updating workdir",loaded:++Bt,total:It})}))}),await ft.acquire({fs:r,gitdir:a,cache:t},async function(wt){for(const[yt,xt]of ot)if(yt==="rmdir"||yt==="rmdir-index"){const Lt=`${i}/${xt}`;try{yt==="rmdir"&&await r.rmdir(Lt),wt.delete({filepath:xt}),e&&await e({phase:"Updating workdir",loaded:++Bt,total:It})}catch(Yt){if(Yt.code==="ENOTEMPTY")console.log(`Did not delete ${xt} because directory is not empty`);else throw Yt}}}),await Promise.all(ot.filter(([wt])=>wt==="mkdir"||wt==="mkdir-index").map(async function([wt,yt]){const xt=`${i}/${yt}`;await r.mkdir(xt),e&&await e({phase:"Updating workdir",loaded:++Bt,total:It})})),q){const wt=ot.filter(([xt])=>xt==="create"||xt==="create-index"||xt==="update"||xt==="mkdir-index"),yt=await Sa("Update Working Dir",wt.map(([xt,Lt,Yt,ye,Qt])=>()=>vf({fs:r,cache:t,gitdir:a,dir:i},[xt,Lt,Yt,ye,Qt])),e,tt);await ft.acquire({fs:r,gitdir:a,cache:t,allowUnmerged:!0},async function(xt){await Sa("Update Index",yt.map(([Lt,Yt,ye])=>()=>_f({index:xt,fullpath:Lt,oid:Yt,stats:ye})),e,tt)})}else await ft.acquire({fs:r,gitdir:a,cache:t,allowUnmerged:!0},async function(wt){await Promise.all(ot.filter(([yt])=>yt==="create"||yt==="create-index"||yt==="update"||yt==="mkdir-index").map(async function([yt,xt,Lt,Yt,ye]){const Qt=`${i}/${xt}`;try{if(yt!=="create-index"&&yt!=="mkdir-index"){const{object:Se}=await oe({fs:r,cache:t,gitdir:a,oid:Lt});if(ye&&await r.rm(Qt),Yt===33188)await r.write(Qt,Se);else if(Yt===33261)await r.write(Qt,Se,{mode:511});else if(Yt===40960)await r.writelink(Qt,Se);else throw new A(`Invalid mode 0o${Yt.toString(8)} detected in blob ${Lt}`)}const _e=await r.lstat(Qt);Yt===33261&&(_e.mode=493),yt==="mkdir-index"&&(_e.mode=57344),wt.insert({filepath:xt,stats:_e,oid:Lt}),e&&await e({phase:"Updating workdir",loaded:++Bt,total:It})}catch(_e){console.log(_e)}}))});n&&await n({previousHead:Y,newHead:at,type:p!=null&&p.length>0?"file":"branch"})}if(!d){const ot=await B.expand({fs:r,gitdir:a,ref:l});ot.startsWith("refs/heads")?await B.writeSymbolicRef({fs:r,gitdir:a,ref:"HEAD",value:ot}):await B.writeRef({fs:r,gitdir:a,ref:"HEAD",value:at})}}async function yf({fs:r,cache:t,onProgress:e,dir:n,gitdir:i,ref:a,force:c,filepaths:l}){let p=0;return Ye({fs:r,cache:t,dir:n,gitdir:i,trees:[Pe({ref:a}),mr(),qt()],map:async function(y,[d,v,x]){if(y===".")return;if(l&&!l.some(q=>Ea(y,q)))return null;switch(e&&await e({phase:"Analyzing workdir",loaded:++p}),[!!x,!!d,!!v].map(Number).join("")){case"000":return;case"001":return c&&l&&l.includes(y)?["delete",y]:void 0;case"010":switch(await d.type()){case"tree":return["mkdir",y];case"blob":return["create",y,await d.oid(),await d.mode()];case"commit":return["mkdir-index",y,await d.oid(),await d.mode()];default:return["error",`new entry Unhandled type ${await d.type()}`]}case"011":switch(`${await d.type()}-${await v.type()}`){case"tree-tree":return;case"tree-blob":case"blob-tree":return["conflict",y];case"blob-blob":return await d.oid()!==await v.oid()?c?["update",y,await d.oid(),await d.mode(),await d.mode()!==await v.mode()]:["conflict",y]:await d.mode()!==await v.mode()?c?["update",y,await d.oid(),await d.mode(),!0]:["conflict",y]:["create-index",y,await d.oid(),await d.mode()];case"commit-tree":return;case"commit-blob":return["conflict",y];default:return["error",`new entry Unhandled type ${d.type}`]}case"100":return["delete-index",y];case"101":switch(await x.type()){case"tree":return["rmdir-index",y];case"blob":return await x.oid()!==await v.oid()?c?["delete",y]:["conflict",y]:["delete",y];case"commit":return["rmdir-index",y];default:return["error",`delete entry Unhandled type ${await x.type()}`]}case"110":case"111":switch(`${await x.type()}-${await d.type()}`){case"tree-tree":return;case"blob-blob":{if(await x.oid()===await d.oid()&&await x.mode()===await d.mode()&&!c)return;if(v){if(await v.oid()!==await x.oid()&&await v.oid()!==await d.oid())return c?["update",y,await d.oid(),await d.mode(),await d.mode()!==await v.mode()]:["conflict",y]}else if(c)return["update",y,await d.oid(),await d.mode(),await d.mode()!==await x.mode()];return await d.mode()!==await x.mode()?["update",y,await d.oid(),await d.mode(),!0]:await d.oid()!==await x.oid()?["update",y,await d.oid(),await d.mode(),!1]:void 0}case"tree-blob":return["update-dir-to-blob",y,await d.oid()];case"blob-tree":return["update-blob-to-tree",y];case"commit-commit":return["mkdir-index",y,await d.oid(),await d.mode()];default:return["error",`update entry Unhandled type ${await x.type()}-${await d.type()}`]}}},reduce:async function(y,d){return d=aa(d),y?y&&y[0]==="rmdir"?(d.push(y),d):(d.unshift(y),d):d}})}async function _f({index:r,fullpath:t,stats:e,oid:n}){try{r.insert({filepath:t,stats:e,oid:n})}catch(i){console.warn(`Error inserting ${t} into index:`,i)}}async function vf({fs:r,cache:t,gitdir:e,dir:n},[i,a,c,l,p]){const y=`${n}/${a}`;if(i!=="create-index"&&i!=="mkdir-index"){const{object:v}=await oe({fs:r,cache:t,gitdir:e,oid:c});if(p&&await r.rm(y),l===33188)await r.write(y,v);else if(l===33261)await r.write(y,v,{mode:511});else if(l===40960)await r.writelink(y,v);else throw new A(`Invalid mode 0o${l.toString(8)} detected in blob ${c}`)}const d=await r.lstat(y);return l===33261&&(d.mode=493),i==="mkdir-index"&&(d.mode=57344),[a,c,d]}async function Sa(r,t,e,n){const i=[];try{for(let a=0;a<t.length;a+=n){const c=t.slice(a,a+n).map(p=>p());(await Promise.allSettled(c)).forEach(p=>{p.status==="fulfilled"&&i.push(p.value)}),e&&await e({phase:"Updating workdir",loaded:a+c.length,total:t.length})}return i}catch(a){console.error(`Error during ${r}: ${a}`)}return i}async function xn({fs:r,onProgress:t,onPostCheckout:e,dir:n,gitdir:i=W(n,".git"),remote:a="origin",ref:c,filepaths:l,noCheckout:p=!1,noUpdateHead:y=c===void 0,dryRun:d=!1,force:v=!1,track:x=!0,cache:$={},nonBlocking:q=!1,batchSize:tt=100}){try{M("fs",r),M("dir",n),M("gitdir",i);const Y=c||"HEAD",at=new Tt(r),ot=await $t({fsp:at,dotgit:i});return await bn({fs:at,cache:$,onProgress:t,onPostCheckout:e,dir:n,gitdir:ot,remote:a,ref:Y,filepaths:l,noCheckout:p,noUpdateHead:y,dryRun:d,force:v,track:x,nonBlocking:q,batchSize:tt})}catch(Y){throw Y.caller="git.checkout",Y}}const bf=/^refs\/(heads\/|tags\/|remotes\/)?(.*)/;function nr(r){const t=bf.exec(r);return t?t[1]==="remotes/"&&r.endsWith("/HEAD")?t[2].slice(0,-5):t[2]:r}async function Je({fs:r,gitdir:t,fullname:e=!1,test:n=!1}){const i=await B.resolve({fs:r,gitdir:t,ref:"HEAD",depth:2});if(n)try{await B.resolve({fs:r,gitdir:t,ref:i})}catch{return}if(i.startsWith("refs/"))return e?i:nr(i)}function xf(r){return r=r.replace(/^git@([^:]+):/,"https://$1/"),r=r.replace(/^ssh:\/\//,"https://"),r}function Aa({username:r="",password:t=""}){return`Basic ${Buffer.from(`${r}:${t}`).toString("base64")}`}async function zr(r,t){const e=tr(r);for(;;){const{value:n,done:i}=await e.next();if(n&&await t(n),i)break}e.return&&e.return()}async function nn(r){let t=0;const e=[];await zr(r,a=>{e.push(a),t+=a.byteLength});const n=new Uint8Array(t);let i=0;for(const a of e)n.set(a,i),i+=a.byteLength;return n}function ka(r){let t=r.match(/^https?:\/\/([^/]+)@/);if(t==null)return{url:r,auth:{}};t=t[1];const[e,n]=t.split(":");return r=r.replace(`${t}@`,""),{url:r,auth:{username:e,password:n}}}function En(r,t){const e=t.toString(16);return"0".repeat(r-e.length)+e}class we{static flush(){return Buffer.from("0000","utf8")}static delim(){return Buffer.from("0001","utf8")}static encode(t){typeof t=="string"&&(t=Buffer.from(t));const e=t.length+4,n=En(4,e);return Buffer.concat([Buffer.from(n,"utf8"),t])}static streamReader(t){const e=new er(t);return async function(){try{let i=await e.read(4);if(i==null)return!0;if(i=parseInt(i.toString("utf8"),16),i===0||i===1)return null;const a=await e.read(i-4);return a??!0}catch(i){return t.error=i,!0}}}}async function Ra(r){const t={};let e;for(;e=await r(),e!==!0;){if(e===null)continue;e=e.toString("utf8").replace(/\n$/,"");const n=e.indexOf("=");if(n>-1){const i=e.slice(0,n),a=e.slice(n+1);t[i]=a}else t[e]=!0}return{protocolVersion:2,capabilities2:t}}async function Ba(r,{service:t}){const e=new Set,n=new Map,i=new Map,a=we.streamReader(r);let c=await a();for(;c===null;)c=await a();if(c===!0)throw new Ir;if(c.includes("version 2"))return Ra(a);if(c.toString("utf8").replace(/\n$/,"")!==`# service=${t}`)throw new rr(`# service=${t}\\n`,c.toString("utf8"));let l=await a();for(;l===null;)l=await a();if(l===!0)return{capabilities:e,refs:n,symrefs:i};if(l=l.toString("utf8"),l.includes("version 2"))return Ra(a);const[p,y]=Sn(l,"\0","\\x00");if(y.split(" ").map(d=>e.add(d)),p!=="0000000000000000000000000000000000000000 capabilities^{}"){const[d,v]=Sn(p," "," ");for(n.set(v,d);;){const x=await a();if(x===!0)break;if(x!==null){const[$,q]=Sn(x.toString("utf8")," "," ");n.set(q,$)}}}for(const d of e)if(d.startsWith("symref=")){const v=d.match(/symref=([^:]+):(.*)/);v.length===3&&i.set(v[1],v[2])}return{protocolVersion:1,capabilities:e,refs:n,symrefs:i}}function Sn(r,t,e){const n=r.trim().split(t);if(n.length!==2)throw new rr(`Two strings separated by '${e}'`,r.toString("utf8"));return n}const Ia=(r,t)=>r.endsWith("?")?`${r}${t}`:`${r}/${t.replace(/^https?:\/\//,"")}`,Ta=(r,t)=>{(t.username||t.password)&&(r.Authorization=Aa(t)),t.headers&&Object.assign(r,t.headers)},An=async r=>{try{const t=Buffer.from(await nn(r.body)),e=t.toString("utf8");return{preview:e.length<256?e:e.slice(0,256)+"...",response:e,data:t}}catch{return{}}};class an{static async capabilities(){return["discover","connect"]}static async discover({http:t,onProgress:e,onAuth:n,onAuthSuccess:i,onAuthFailure:a,corsProxy:c,service:l,url:p,headers:y,protocolVersion:d}){let{url:v,auth:x}=ka(p);const $=c?Ia(c,v):v;(x.username||x.password)&&(y.Authorization=Aa(x)),d===2&&(y["Git-Protocol"]="version=2");let q,tt,Y=!1;do if(q=await t.request({onProgress:e,method:"GET",url:`${$}/info/refs?service=${l}`,headers:y}),tt=!1,q.statusCode===401||q.statusCode===203){const at=Y?a:n;if(at){if(x=await at(v,{...x,headers:{...y}}),x&&x.cancel)throw new wr;x&&(Ta(y,x),Y=!0,tt=!0)}}else q.statusCode===200&&Y&&i&&await i(v,x);while(tt);if(q.statusCode!==200){const{response:at}=await An(q);throw new lr(q.statusCode,q.statusMessage,at)}if(q.headers["content-type"]===`application/x-${l}-advertisement`){const at=await Ba(q.body,{service:l});return at.auth=x,at}else{const{preview:at,response:ot,data:vt}=await An(q);try{const At=await Ba([vt],{service:l});return At.auth=x,At}catch{throw new Cr(at,ot)}}}static async connect({http:t,onProgress:e,corsProxy:n,service:i,url:a,auth:c,body:l,headers:p}){const y=ka(a);y&&(a=y.url),n&&(a=Ia(n,a)),p["content-type"]=`application/x-${i}-request`,p.accept=`application/x-${i}-result`,Ta(p,c);const d=await t.request({onProgress:e,method:"POST",url:`${a}/${i}`,body:l,headers:p});if(d.statusCode!==200){const{response:v}=An(d);throw new lr(d.statusCode,d.statusMessage,v)}return d}}class on{static getRemoteHelperFor({url:t}){const e=new Map;e.set("http",an),e.set("https",an);const n=Ef({url:t});if(!n)throw new Dr(t);if(e.has(n.transport))return e.get(n.transport);throw new Fr(t,n.transport,n.transport==="ssh"?xf(t):void 0)}}function Ef({url:r}){if(r.startsWith("git@"))return{transport:"ssh",address:r};const t=r.match(/(\w+)(:\/\/|::)(.*)/);if(t!==null){if(t[2]==="://")return{transport:t[1],address:t[0]};if(t[2]==="::")return{transport:t[1],address:t[3]}}}let ir=null;class Gr{static async read({fs:t,gitdir:e}){ir===null&&(ir=new S);const n=W(e,"shallow"),i=new Set;return await ir.acquire(n,async function(){const a=await t.read(n,{encoding:"utf8"});if(a===null||a.trim()==="")return i;a.trim().split(`
`).map(c=>i.add(c))}),i}static async write({fs:t,gitdir:e,oids:n}){ir===null&&(ir=new S);const i=W(e,"shallow");if(n.size>0){const a=[...n].join(`
`)+`
`;await ir.acquire(i,async function(){await t.write(i,a,{encoding:"utf8"})})}else await ir.acquire(i,async function(){await t.rm(i)})}}async function Sf({fs:r,gitdir:t,oid:e}){const n=`objects/${e.slice(0,2)}/${e.slice(2)}`;return r.exists(`${t}/${n}`)}async function Af({fs:r,cache:t,gitdir:e,oid:n,getExternalRefDelta:i}){let a=await r.readdir(W(e,"objects/pack"));a=a.filter(c=>c.endsWith(".idx"));for(const c of a){const l=`${e}/objects/pack/${c}`,p=await wn({fs:r,cache:t,filename:l,getExternalRefDelta:i});if(p.error)throw new A(p.error);if(p.offsets.has(n))return!0}return!1}async function Oa({fs:r,cache:t,gitdir:e,oid:n,format:i="content"}){const a=l=>oe({fs:r,cache:t,gitdir:e,oid:l});let c=await Sf({fs:r,gitdir:e,oid:n});return c||(c=await Af({fs:r,cache:t,gitdir:e,oid:n,getExternalRefDelta:a})),c}function kf(r){const i="5041434b"+"00000002"+"00000000";return r.slice(0,12).toString("hex")===i}function $a(r,t){const e=r.map(n=>n.split("=",1)[0]);return t.filter(n=>{const i=n.split("=",1)[0];return e.includes(i)})}const sn={name:"isomorphic-git",version:"1.36.3",agent:"git/isomorphic-git@1.36.3"};class cn{constructor(){this._queue=[]}write(t){if(this._ended)throw Error("You cannot write to a FIFO that has already been ended!");if(this._waiting){const e=this._waiting;this._waiting=null,e({value:t})}else this._queue.push(t)}end(){if(this._ended=!0,this._waiting){const t=this._waiting;this._waiting=null,t({done:!0})}}destroy(t){this.error=t,this.end()}async next(){if(this._queue.length>0)return{value:this._queue.shift()};if(this._ended)return{done:!0};if(this._waiting)throw Error("You cannot call read until the previous call to read has returned!");return new Promise(t=>{this._waiting=t})}}function Rf(r){const t=r.indexOf("\r"),e=r.indexOf(`
`);return t===-1&&e===-1?-1:t===-1?e+1:e===-1?t+1:e===t+1?e+1:Math.min(t,e)+1}function Pa(r){const t=new cn;let e="";return(async()=>(await zr(r,n=>{for(n=n.toString("utf8"),e+=n;;){const i=Rf(e);if(i===-1)break;t.write(e.slice(0,i)),e=e.slice(i)}}),e.length>0&&t.write(e),t.end()))(),t}class Ca{static demux(t){const e=we.streamReader(t),n=new cn,i=new cn,a=new cn,c=async function(){const l=await e();if(l===null)return c();if(l===!0){n.end(),a.end(),t.error?i.destroy(t.error):i.end();return}switch(l[0]){case 1:{i.write(l.slice(1));break}case 2:{a.write(l.slice(1));break}case 3:{const p=l.slice(1);a.write(p),n.end(),a.end(),i.destroy(new Error(p.toString("utf8")));return}default:n.write(l)}c()};return c(),{packetlines:n,packfile:i,progress:a}}}async function Bf(r){const{packetlines:t,packfile:e,progress:n}=Ca.demux(r),i=[],a=[],c=[];let l=!1,p=!1;return new Promise((y,d)=>{zr(t,v=>{const x=v.toString("utf8").trim();if(x.startsWith("shallow")){const $=x.slice(-41).trim();$.length!==40&&d(new Ht($)),i.push($)}else if(x.startsWith("unshallow")){const $=x.slice(-41).trim();$.length!==40&&d(new Ht($)),a.push($)}else if(x.startsWith("ACK")){const[,$,q]=x.split(" ");c.push({oid:$,status:q}),q||(p=!0)}else x.startsWith("NAK")?(l=!0,p=!0):(p=!0,l=!0);p&&(r.error?d(r.error):y({shallows:i,unshallows:a,acks:c,nak:l,packfile:e,progress:n}))}).finally(()=>{p||(r.error?d(r.error):y({shallows:i,unshallows:a,acks:c,nak:l,packfile:e,progress:n}))})})}function If({capabilities:r=[],wants:t=[],haves:e=[],shallows:n=[],depth:i=null,since:a=null,exclude:c=[]}){const l=[];t=[...new Set(t)];let p=` ${r.join(" ")}`;for(const y of t)l.push(we.encode(`want ${y}${p}
`)),p="";for(const y of n)l.push(we.encode(`shallow ${y}
`));i!==null&&l.push(we.encode(`deepen ${i}
`)),a!==null&&l.push(we.encode(`deepen-since ${Math.floor(a.valueOf()/1e3)}
`));for(const y of c)l.push(we.encode(`deepen-not ${y}
`));l.push(we.flush());for(const y of e)l.push(we.encode(`have ${y}
`));return l.push(we.encode(`done
`)),l}async function kn({fs:r,cache:t,http:e,onProgress:n,onMessage:i,onAuth:a,onAuthSuccess:c,onAuthFailure:l,gitdir:p,ref:y,remoteRef:d,remote:v,url:x,corsProxy:$,depth:q=null,since:tt=null,exclude:Y=[],relative:at=!1,tags:ot=!1,singleBranch:vt=!1,headers:At={},prune:Bt=!1,pruneTags:It=!1}){const wt=y||await Je({fs:r,gitdir:p,test:!0}),yt=await z.get({fs:r,gitdir:p}),xt=v||wt&&await yt.get(`branch.${wt}.remote`)||"origin",Lt=x||await yt.get(`remote.${xt}.url`);if(typeof Lt>"u")throw new Oe("remote OR url");const Yt=d||wt&&await yt.get(`branch.${wt}.merge`)||y||"HEAD";$===void 0&&($=await yt.get("http.corsProxy"));const ye=on.getRemoteHelperFor({url:Lt}),Qt=await ye.discover({http:e,onAuth:a,onAuthSuccess:c,onAuthFailure:l,corsProxy:$,service:"git-upload-pack",url:Lt,headers:At,protocolVersion:1}),_e=Qt.auth,Se=Qt.refs;if(Se.size===0)return{defaultBranch:null,fetchHead:null,fetchHeadDescription:null};if(q!==null&&!Qt.capabilities.has("shallow"))throw new Ve("shallow","depth");if(tt!==null&&!Qt.capabilities.has("deepen-since"))throw new Ve("deepen-since","since");if(Y.length>0&&!Qt.capabilities.has("deepen-not"))throw new Ve("deepen-not","exclude");if(at===!0&&!Qt.capabilities.has("deepen-relative"))throw new Ve("deepen-relative","relative");const{oid:ar,fullref:or}=B.resolveAgainstMap({ref:Yt,map:Se});for(const ee of Se.keys())ee===or||ee==="HEAD"||ee.startsWith("refs/heads/")||ot&&ee.startsWith("refs/tags/")||Se.delete(ee);const Er=$a([...Qt.capabilities],["multi_ack_detailed","no-done","side-band-64k","ofs-delta",`agent=${sn.agent}`]);at&&Er.push("deepen-relative");const $n=vt?[ar]:Se.values(),Pn=vt?[wt]:await B.listRefs({fs:r,gitdir:p,filepath:"refs"});let Ce=[];for(let ee of Pn)try{ee=await B.expand({fs:r,gitdir:p,ref:ee});const Ae=await B.resolve({fs:r,gitdir:p,ref:ee});await Oa({fs:r,cache:t,gitdir:p,oid:Ae})&&Ce.push(Ae)}catch{}Ce=[...new Set(Ce)];const le=await Gr.read({fs:r,gitdir:p}),Ge=Qt.capabilities.has("shallow")?[...le]:[],Be=If({capabilities:Er,wants:$n,haves:Ce,shallows:Ge,depth:q,since:tt,exclude:Y}),Hr=Buffer.from(await nn(Be)),sr=await ye.connect({http:e,onProgress:n,corsProxy:$,service:"git-upload-pack",url:Lt,auth:_e,body:[Hr],headers:At}),ve=await Bf(sr.body);sr.headers&&(ve.headers=sr.headers);for(const ee of ve.shallows)if(!le.has(ee))try{const{object:Ae}=await oe({fs:r,cache:t,gitdir:p,oid:ee}),Ne=new ce(Ae),He=await Promise.all(Ne.headers().parent.map(Wr=>Oa({fs:r,cache:t,gitdir:p,oid:Wr})));He.length===0||He.every(Wr=>Wr)||le.add(ee)}catch{le.add(ee)}for(const ee of ve.unshallows)le.delete(ee);if(await Gr.write({fs:r,gitdir:p,oids:le}),vt){const ee=new Map([[or,ar]]),Ae=new Map;let Ne=10,He=or;for(;Ne--;){const Fn=Qt.symrefs.get(He);if(Fn===void 0)break;Ae.set(He,Fn),He=Fn}const Cn=Se.get(He);Cn&&ee.set(He,Cn);const{pruned:Wr}=await B.updateRemoteRefs({fs:r,gitdir:p,remote:xt,refs:ee,symrefs:Ae,tags:ot,prune:Bt});Bt&&(ve.pruned=Wr)}else{const{pruned:ee}=await B.updateRemoteRefs({fs:r,gitdir:p,remote:xt,refs:Se,symrefs:Qt.symrefs,tags:ot,prune:Bt,pruneTags:It});Bt&&(ve.pruned=ee)}if(ve.HEAD=Qt.symrefs.get("HEAD"),ve.HEAD===void 0){const{oid:ee}=B.resolveAgainstMap({ref:"HEAD",map:Se});for(const[Ae,Ne]of Se.entries())if(Ae!=="HEAD"&&Ne===ee){ve.HEAD=Ae;break}}const _u=or.startsWith("refs/tags")?"tag":"branch";if(ve.FETCH_HEAD={oid:ar,description:`${_u} '${nr(or)}' of ${Lt}`},n||i){const ee=Pa(ve.progress);zr(ee,async Ae=>{if(i&&await i(Ae),n){const Ne=Ae.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);Ne&&await n({phase:Ne[1].trim(),loaded:parseInt(Ne[2],10),total:parseInt(Ne[3],10)})}})}const un=Buffer.from(await nn(ve.packfile));if(sr.body.error)throw sr.body.error;const as=un.slice(-20).toString("hex"),Zr={defaultBranch:ve.HEAD,fetchHead:ve.FETCH_HEAD.oid,fetchHeadDescription:ve.FETCH_HEAD.description};if(ve.headers&&(Zr.headers=ve.headers),Bt&&(Zr.pruned=ve.pruned),as!==""&&!kf(un)){Zr.packfile=`objects/pack/pack-${as}.pack`;const ee=W(p,Zr.packfile);await r.write(ee,un);const Ae=He=>oe({fs:r,cache:t,gitdir:p,oid:He}),Ne=await ur.fromPack({pack:un,getExternalRefDelta:Ae,onProgress:n});await r.write(ee.replace(/\.pack$/,".idx"),await Ne.toBuffer())}return Zr}async function Fa({fs:r,bare:t=!1,dir:e,gitdir:n=t?e:W(e,".git"),defaultBranch:i="master"}){if(await r.exists(n+"/config"))return;let a=["hooks","info","objects/info","objects/pack","refs/heads","refs/tags"];a=a.map(c=>n+"/"+c);for(const c of a)await r.mkdir(c);await r.write(n+"/config",`[core]
	repositoryformatversion = 0
	filemode = false
	bare = ${t}
`+(t?"":`	logallrefupdates = true
`)+`	symlinks = false
	ignorecase = true
`),await r.write(n+"/HEAD",`ref: refs/heads/${i}
`)}async function Tf({fs:r,cache:t,http:e,onProgress:n,onMessage:i,onAuth:a,onAuthSuccess:c,onAuthFailure:l,onPostCheckout:p,dir:y,gitdir:d,url:v,corsProxy:x,ref:$,remote:q,depth:tt,since:Y,exclude:at,relative:ot,singleBranch:vt,noCheckout:At,noTags:Bt,headers:It,nonBlocking:wt,batchSize:yt=100}){try{if(await Fa({fs:r,gitdir:d}),await _a({fs:r,gitdir:d,remote:q,url:v,force:!1}),x){const Yt=await z.get({fs:r,gitdir:d});await Yt.set("http.corsProxy",x),await z.save({fs:r,gitdir:d,config:Yt})}const{defaultBranch:xt,fetchHead:Lt}=await kn({fs:r,cache:t,http:e,onProgress:n,onMessage:i,onAuth:a,onAuthSuccess:c,onAuthFailure:l,gitdir:d,ref:$,remote:q,corsProxy:x,depth:tt,since:Y,exclude:at,relative:ot,singleBranch:vt,headers:It,tags:!Bt});if(Lt===null)return;$=$||xt,$=$.replace("refs/heads/",""),await bn({fs:r,cache:t,onProgress:n,onPostCheckout:p,dir:y,gitdir:d,ref:$,remote:q,noCheckout:At,nonBlocking:wt,batchSize:yt})}catch(xt){throw await r.rmdir(d,{recursive:!0,maxRetries:10}).catch(()=>{}),xt}}async function Da({fs:r,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,onPostCheckout:l,dir:p,gitdir:y=W(p,".git"),url:d,corsProxy:v=void 0,ref:x=void 0,remote:$="origin",depth:q=void 0,since:tt=void 0,exclude:Y=[],relative:at=!1,singleBranch:ot=!1,noCheckout:vt=!1,noTags:At=!1,headers:Bt={},cache:It={},nonBlocking:wt=!1,batchSize:yt=100}){try{M("fs",r),M("http",t),M("gitdir",y),vt||M("dir",p),M("url",d);const xt=new Tt(r),Lt=await $t({fsp:xt,dotgit:y});return await Tf({fs:xt,cache:It,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,onPostCheckout:l,dir:p,gitdir:Lt,url:d,corsProxy:v,ref:x,remote:$,depth:q,since:tt,exclude:Y,relative:at,singleBranch:ot,noCheckout:vt,noTags:At,headers:Bt,nonBlocking:wt,batchSize:yt})}catch(xt){throw xt.caller="git.clone",xt}}async function Ua({fs:r,onSign:t,dir:e,gitdir:n=W(e,".git"),message:i,author:a,committer:c,signingKey:l,amend:p=!1,dryRun:y=!1,noUpdateBranch:d=!1,ref:v,parent:x,tree:$,cache:q={}}){try{M("fs",r),p||M("message",i),l&&M("onSign",t);const tt=new Tt(r),Y=await $t({fsp:tt,dotgit:n});return await rn({fs:tt,cache:q,onSign:t,gitdir:Y,message:i,author:a,committer:c,signingKey:l,amend:p,dryRun:y,noUpdateBranch:d,ref:v,parent:x,tree:$})}catch(tt){throw tt.caller="git.commit",tt}}async function Na({fs:r,dir:t,gitdir:e=W(t,".git"),fullname:n=!1,test:i=!1}){try{M("fs",r),M("gitdir",e);const a=new Tt(r),c=await $t({fsp:a,dotgit:e});return await Je({fs:a,gitdir:c,fullname:n,test:i})}catch(a){throw a.caller="git.currentBranch",a}}async function Of({fs:r,gitdir:t,ref:e}){if(e=e.startsWith("refs/heads/")?e:`refs/heads/${e}`,!await B.exists({fs:r,gitdir:t,ref:e}))throw new Ct(e);const i=await B.expand({fs:r,gitdir:t,ref:e}),a=await Je({fs:r,gitdir:t,fullname:!0});if(i===a){const p=await B.resolve({fs:r,gitdir:t,ref:i});await B.writeRef({fs:r,gitdir:t,ref:"HEAD",value:p})}await B.deleteRef({fs:r,gitdir:t,ref:i});const c=nr(e),l=await z.get({fs:r,gitdir:t});await l.deleteSection("branch",c),await z.save({fs:r,gitdir:t,config:l})}async function Ma({fs:r,dir:t,gitdir:e=W(t,".git"),ref:n}){try{M("fs",r),M("ref",n);const i=new Tt(r),a=await $t({fsp:i,dotgit:e});return await Of({fs:i,gitdir:a,ref:n})}catch(i){throw i.caller="git.deleteBranch",i}}async function ja({fs:r,dir:t,gitdir:e=W(t,".git"),ref:n}){try{M("fs",r),M("ref",n);const i=new Tt(r),a=await $t({fsp:i,dotgit:e});await B.deleteRef({fs:i,gitdir:a,ref:n})}catch(i){throw i.caller="git.deleteRef",i}}async function $f({fs:r,gitdir:t,remote:e}){const n=await z.get({fs:r,gitdir:t});await n.deleteSection("remote",e),await z.save({fs:r,gitdir:t,config:n})}async function La({fs:r,dir:t,gitdir:e=W(t,".git"),remote:n}){try{M("fs",r),M("remote",n);const i=new Tt(r),a=await $t({fsp:i,dotgit:e});return await $f({fs:i,gitdir:a,remote:n})}catch(i){throw i.caller="git.deleteRemote",i}}async function Pf({fs:r,gitdir:t,ref:e}){e=e.startsWith("refs/tags/")?e:`refs/tags/${e}`,await B.deleteRef({fs:r,gitdir:t,ref:e})}async function qa({fs:r,dir:t,gitdir:e=W(t,".git"),ref:n}){try{M("fs",r),M("ref",n);const i=new Tt(r),a=await $t({fsp:i,dotgit:e});return await Pf({fs:i,gitdir:a,ref:n})}catch(i){throw i.caller="git.deleteTag",i}}async function Cf({fs:r,gitdir:t,oid:e}){const n=e.slice(0,2);return(await r.readdir(`${t}/objects/${n}`)).map(a=>`${n}${a}`).filter(a=>a.startsWith(e))}async function Ff({fs:r,cache:t,gitdir:e,oid:n,getExternalRefDelta:i}){const a=[];let c=await r.readdir(W(e,"objects/pack"));c=c.filter(l=>l.endsWith(".idx"));for(const l of c){const p=`${e}/objects/pack/${l}`,y=await wn({fs:r,cache:t,filename:p,getExternalRefDelta:i});if(y.error)throw new A(y.error);for(const d of y.offsets.keys())d.startsWith(n)&&a.push(d)}return a}async function Df({fs:r,cache:t,gitdir:e,oid:n}){const i=l=>oe({fs:r,cache:t,gitdir:e,oid:l}),a=await Cf({fs:r,gitdir:e,oid:n}),c=await Ff({fs:r,cache:t,gitdir:e,oid:n,getExternalRefDelta:i});for(const l of c)a.indexOf(l)===-1&&a.push(l);if(a.length===1)return a[0];throw a.length>1?new kr("oids",n,a):new Ct(`an object matching "${n}"`)}async function za({fs:r,dir:t,gitdir:e=W(t,".git"),oid:n,cache:i={}}){try{M("fs",r),M("gitdir",e),M("oid",n);const a=new Tt(r),c=await $t({fsp:a,dotgit:e});return await Df({fs:a,cache:i,gitdir:c,oid:n})}catch(a){throw a.caller="git.expandOid",a}}async function Ga({fs:r,dir:t,gitdir:e=W(t,".git"),ref:n}){try{M("fs",r),M("gitdir",e),M("ref",n);const i=new Tt(r),a=await $t({fsp:i,dotgit:e});return await B.expand({fs:i,gitdir:a,ref:n})}catch(i){throw i.caller="git.expandRef",i}}async function Rn({fs:r,cache:t,gitdir:e,oids:n}){const i={},a=n.length;let c=n.map((l,p)=>({index:p,oid:l}));for(;c.length;){const l=new Set;for(const{oid:y,index:d}of c)i[y]||(i[y]=new Set),i[y].add(d),i[y].size===a&&l.add(y);if(l.size>0)return[...l];const p=new Map;for(const{oid:y,index:d}of c)try{const{object:v}=await oe({fs:r,cache:t,gitdir:e,oid:y}),x=ce.from(v),{parent:$}=x.parseHeaders();for(const q of $)(!i[q]||!i[q].has(d))&&p.set(q+":"+d,{oid:q,index:d})}catch{}c=Array.from(p.values())}return[]}const Bn=/^.*(\r?\n|$)/gm;function Uf({branches:r,contents:t}){const e=r[1],n=r[2],i=t[0],a=t[1],c=t[2],l=a.match(Bn),p=i.match(Bn),y=c.match(Bn),d=_(l,p,y),v=7;let x="",$=!0;for(const q of d)q.ok&&(x+=q.ok.join("")),q.conflict&&($=!1,x+=`${"<".repeat(v)} ${e}
`,x+=q.conflict.a.join(""),x+=`${"=".repeat(v)}
`,x+=q.conflict.b.join(""),x+=`${">".repeat(v)} ${n}
`);return{cleanMerge:$,mergedText:x}}async function Nf({fs:r,cache:t,dir:e,gitdir:n=W(e,".git"),index:i,ourOid:a,baseOid:c,theirOid:l,ourName:p="ours",baseName:y="base",theirName:d="theirs",dryRun:v=!1,abortOnConflict:x=!0,mergeDriver:$}){const q=Pe({ref:a}),tt=Pe({ref:c}),Y=Pe({ref:l}),at=[],ot=[],vt=[],At=[],Bt=await Ye({fs:r,cache:t,dir:e,gitdir:n,trees:[q,tt,Y],map:async function(It,[wt,yt,xt]){const Lt=Ut(It),Yt=await en(wt,yt),ye=await en(xt,yt);switch(`${Yt}-${ye}`){case"false-false":return{mode:await yt.mode(),path:Lt,oid:await yt.oid(),type:await yt.type()};case"false-true":return!xt&&await wt.type()==="tree"?{mode:await wt.mode(),path:Lt,oid:await wt.oid(),type:await wt.type()}:xt?{mode:await xt.mode(),path:Lt,oid:await xt.oid(),type:await xt.type()}:void 0;case"true-false":return!wt&&await xt.type()==="tree"?{mode:await xt.mode(),path:Lt,oid:await xt.oid(),type:await xt.type()}:wt?{mode:await wt.mode(),path:Lt,oid:await wt.oid(),type:await wt.type()}:void 0;case"true-true":{if(wt&&xt&&await wt.type()==="tree"&&await xt.type()==="tree")return{mode:await wt.mode(),path:Lt,oid:await wt.oid(),type:"tree"};if(wt&&xt&&await wt.type()==="blob"&&await xt.type()==="blob")return Mf({fs:r,gitdir:n,path:Lt,ours:wt,base:yt,theirs:xt,ourName:p,baseName:y,theirName:d,mergeDriver:$}).then(async Qt=>{if(Qt.cleanMerge)x||i.insert({filepath:It,oid:Qt.mergeResult.oid,stage:0});else if(at.push(It),ot.push(It),!x){let _e="";yt&&await yt.type()==="blob"&&(_e=await yt.oid());const Se=await wt.oid(),ar=await xt.oid();i.delete({filepath:It}),_e&&i.insert({filepath:It,oid:_e,stage:1}),i.insert({filepath:It,oid:Se,stage:2}),i.insert({filepath:It,oid:ar,stage:3})}return Qt.mergeResult});if(yt&&!wt&&xt&&await yt.type()==="blob"&&await xt.type()==="blob"){if(at.push(It),vt.push(It),!x){const Qt=await yt.oid(),_e=await xt.oid();i.delete({filepath:It}),i.insert({filepath:It,oid:Qt,stage:1}),i.insert({filepath:It,oid:_e,stage:3})}return{mode:await xt.mode(),oid:await xt.oid(),type:"blob",path:Lt}}if(yt&&wt&&!xt&&await yt.type()==="blob"&&await wt.type()==="blob"){if(at.push(It),At.push(It),!x){const Qt=await yt.oid(),_e=await wt.oid();i.delete({filepath:It}),i.insert({filepath:It,oid:Qt,stage:1}),i.insert({filepath:It,oid:_e,stage:2})}return{mode:await wt.mode(),oid:await wt.oid(),type:"blob",path:Lt}}if(yt&&!wt&&!xt&&(await yt.type()==="blob"||await yt.type()==="tree"))return;throw new hr}}},reduce:at.length!==0&&(!e||x)?void 0:async(It,wt)=>{const yt=wt.filter(Boolean);if(It&&!(It&&It.type==="tree"&&yt.length===0&&It.path!==".")){if(yt.length>0||It.path==="."&&yt.length===0){const Lt=new bt(yt).toObject(),Yt=await $e({fs:r,gitdir:n,type:"tree",object:Lt,dryRun:v});It.oid=Yt}return It}}});return at.length!==0?(e&&!x&&await Ye({fs:r,cache:t,dir:e,gitdir:n,trees:[Pe({ref:Bt.oid})],map:async function(It,[wt]){const yt=`${e}/${It}`;if(await wt.type()==="blob"){const xt=await wt.mode(),Lt=new TextDecoder().decode(await wt.content());await r.write(yt,Lt,{mode:xt})}return!0}}),new dr(at,ot,vt,At)):Bt.oid}async function Mf({fs:r,gitdir:t,path:e,ours:n,base:i,theirs:a,ourName:c,theirName:l,baseName:p,dryRun:y,mergeDriver:d=Uf}){const v="blob";let x="100755",$="",q="";i&&await i.type()==="blob"&&(x=await i.mode(),$=await i.oid(),q=Buffer.from(await i.content()).toString("utf8"));const tt=x===await n.mode()?await a.mode():await n.mode();if(await n.oid()===await a.oid())return{cleanMerge:!0,mergeResult:{mode:tt,path:e,oid:await n.oid(),type:v}};if(await n.oid()===$)return{cleanMerge:!0,mergeResult:{mode:tt,path:e,oid:await a.oid(),type:v}};if(await a.oid()===$)return{cleanMerge:!0,mergeResult:{mode:tt,path:e,oid:await n.oid(),type:v}};const Y=Buffer.from(await n.content()).toString("utf8"),at=Buffer.from(await a.content()).toString("utf8"),{mergedText:ot,cleanMerge:vt}=await d({branches:[p,c,l],contents:[q,Y,at],path:e}),At=await $e({fs:r,gitdir:t,type:"blob",object:Buffer.from(ot,"utf8"),dryRun:y});return{cleanMerge:vt,mergeResult:{mode:tt,path:e,oid:At,type:v}}}async function Ha({fs:r,cache:t,dir:e,gitdir:n,ours:i,theirs:a,fastForward:c=!0,fastForwardOnly:l=!1,dryRun:p=!1,noUpdateBranch:y=!1,abortOnConflict:d=!0,message:v,author:x,committer:$,signingKey:q,onSign:tt,mergeDriver:Y,allowUnrelatedHistories:at=!1}){i===void 0&&(i=await Je({fs:r,gitdir:n,fullname:!0})),i=await B.expand({fs:r,gitdir:n,ref:i}),a=await B.expand({fs:r,gitdir:n,ref:a});const ot=await B.resolve({fs:r,gitdir:n,ref:i}),vt=await B.resolve({fs:r,gitdir:n,ref:a}),At=await Rn({fs:r,cache:t,gitdir:n,oids:[ot,vt]});if(At.length!==1)if(At.length===0&&at)At.push("4b825dc642cb6eb9a060e54bf8d69288fbee4904");else throw new hr;const Bt=At[0];if(Bt===vt)return{oid:ot,alreadyMerged:!0};if(c&&Bt===ot)return!p&&!y&&await B.writeRef({fs:r,gitdir:n,ref:i,value:vt}),{oid:vt,fastForward:!0};{if(l)throw new Tr;const It=await ft.acquire({fs:r,gitdir:n,cache:t,allowUnmerged:!1},async yt=>Nf({fs:r,cache:t,dir:e,gitdir:n,index:yt,ourOid:ot,theirOid:vt,baseOid:Bt,ourName:nr(i),baseName:"base",theirName:nr(a),dryRun:p,abortOnConflict:d,mergeDriver:Y}));if(It instanceof dr)throw It;return v||(v=`Merge branch '${nr(a)}' into ${nr(i)}`),{oid:await rn({fs:r,cache:t,gitdir:n,message:v,ref:i,tree:It,parent:[ot,vt],author:x,committer:$,signingKey:q,onSign:tt,dryRun:p,noUpdateBranch:y}),tree:It,mergeCommit:!0}}}async function Za({fs:r,cache:t,http:e,onProgress:n,onMessage:i,onAuth:a,onAuthSuccess:c,onAuthFailure:l,dir:p,gitdir:y,ref:d,url:v,remote:x,remoteRef:$,prune:q,pruneTags:tt,fastForward:Y,fastForwardOnly:at,corsProxy:ot,singleBranch:vt,headers:At,author:Bt,committer:It,signingKey:wt}){try{if(!d){const Lt=await Je({fs:r,gitdir:y});if(!Lt)throw new Oe("ref");d=Lt}const{fetchHead:yt,fetchHeadDescription:xt}=await kn({fs:r,cache:t,http:e,onProgress:n,onMessage:i,onAuth:a,onAuthSuccess:c,onAuthFailure:l,gitdir:y,corsProxy:ot,ref:d,url:v,remote:x,remoteRef:$,singleBranch:vt,headers:At,prune:q,pruneTags:tt});await Ha({fs:r,cache:t,gitdir:y,ours:d,theirs:yt,fastForward:Y,fastForwardOnly:at,message:`Merge ${xt}`,author:Bt,committer:It,signingKey:wt,dryRun:!1,noUpdateBranch:!1}),await bn({fs:r,cache:t,onProgress:n,dir:p,gitdir:y,ref:d,remote:x,noCheckout:!1})}catch(yt){throw yt.caller="git.pull",yt}}async function Wa({fs:r,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,dir:l,gitdir:p=W(l,".git"),ref:y,url:d,remote:v,remoteRef:x,corsProxy:$,singleBranch:q,headers:tt={},cache:Y={}}){try{M("fs",r),M("http",t),M("gitdir",p);const at={name:"",email:"",timestamp:Date.now(),timezoneOffset:0},ot=new Tt(r),vt=await $t({fsp:ot,dotgit:p});return await Za({fs:ot,cache:Y,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,dir:l,gitdir:vt,ref:y,url:d,remote:v,remoteRef:x,fastForwardOnly:!0,corsProxy:$,singleBranch:q,headers:tt,author:at,committer:at})}catch(at){throw at.caller="git.fastForward",at}}async function Xa({fs:r,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,dir:l,gitdir:p=W(l,".git"),ref:y,remote:d,remoteRef:v,url:x,corsProxy:$,depth:q=null,since:tt=null,exclude:Y=[],relative:at=!1,tags:ot=!1,singleBranch:vt=!1,headers:At={},prune:Bt=!1,pruneTags:It=!1,cache:wt={}}){try{M("fs",r),M("http",t),M("gitdir",p);const yt=new Tt(r),xt=await $t({fsp:yt,dotgit:p});return await kn({fs:yt,cache:wt,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,gitdir:xt,ref:y,remote:d,remoteRef:v,url:x,corsProxy:$,depth:q,since:tt,exclude:Y,relative:at,tags:ot,singleBranch:vt,headers:At,prune:Bt,pruneTags:It})}catch(yt){throw yt.caller="git.fetch",yt}}async function Va({fs:r,dir:t,gitdir:e=W(t,".git"),oids:n,cache:i={}}){try{M("fs",r),M("gitdir",e),M("oids",n);const a=new Tt(r),c=await $t({fsp:a,dotgit:e});return await Rn({fs:a,cache:i,gitdir:c,oids:n})}catch(a){throw a.caller="git.findMergeBase",a}}async function Ya({fs:r,filepath:t}){if(await r.exists(W(t,".git")))return t;{const e=Rt(t);if(e===t)throw new Ct(`git root for ${t}`);return Ya({fs:r,filepath:e})}}async function Ka({fs:r,filepath:t}){try{return M("fs",r),M("filepath",t),await Ya({fs:new Tt(r),filepath:t})}catch(e){throw e.caller="git.findRoot",e}}async function Ja({fs:r,dir:t,gitdir:e=W(t,".git"),path:n}){try{M("fs",r),M("gitdir",e),M("path",n);const i=new Tt(r),a=await $t({fsp:i,dotgit:e});return await Mr({fs:i,gitdir:a,path:n})}catch(i){throw i.caller="git.getConfig",i}}async function jf({fs:r,gitdir:t,path:e}){return(await z.get({fs:r,gitdir:t})).getall(e)}async function Qa({fs:r,dir:t,gitdir:e=W(t,".git"),path:n}){try{M("fs",r),M("gitdir",e),M("path",n);const i=new Tt(r),a=await $t({fsp:i,dotgit:e});return await jf({fs:i,gitdir:a,path:n})}catch(i){throw i.caller="git.getConfigAll",i}}async function to({http:r,onAuth:t,onAuthSuccess:e,onAuthFailure:n,corsProxy:i,url:a,headers:c={},forPush:l=!1}){try{M("http",r),M("url",a);const y=await on.getRemoteHelperFor({url:a}).discover({http:r,onAuth:t,onAuthSuccess:e,onAuthFailure:n,corsProxy:i,service:l?"git-receive-pack":"git-upload-pack",url:a,headers:c,protocolVersion:1}),d={capabilities:[...y.capabilities]};for(const[v,x]of y.refs){const $=v.split("/"),q=$.pop();let tt=d;for(const Y of $)tt[Y]=tt[Y]||{},tt=tt[Y];tt[q]=x}for(const[v,x]of y.symrefs){const $=v.split("/"),q=$.pop();let tt=d;for(const Y of $)tt[Y]=tt[Y]||{},tt=tt[Y];tt[q]=x}return d}catch(p){throw p.caller="git.getRemoteInfo",p}}function eo(r,t,e,n){const i=[];for(const[a,c]of r.refs){if(t&&!a.startsWith(t))continue;if(a.endsWith("^{}")){if(n){const p=a.replace("^{}",""),y=i[i.length-1],d=y.ref===p?y:i.find(v=>v.ref===p);if(d===void 0)throw new Error("I did not expect this to happen");d.peeled=c}continue}const l={ref:a,oid:c};e&&r.symrefs.has(a)&&(l.target=r.symrefs.get(a)),i.push(l)}return i}async function ro({http:r,onAuth:t,onAuthSuccess:e,onAuthFailure:n,corsProxy:i,url:a,headers:c={},forPush:l=!1,protocolVersion:p=2}){try{M("http",r),M("url",a);const d=await on.getRemoteHelperFor({url:a}).discover({http:r,onAuth:t,onAuthSuccess:e,onAuthFailure:n,corsProxy:i,service:l?"git-receive-pack":"git-upload-pack",url:a,headers:c,protocolVersion:p});if(d.protocolVersion===2)return{protocolVersion:d.protocolVersion,capabilities:d.capabilities2};const v={};for(const x of d.capabilities){const[$,q]=x.split("=");q?v[$]=q:v[$]=!0}return{protocolVersion:1,capabilities:v,refs:eo(d,void 0,!0,!0)}}catch(y){throw y.caller="git.getRemoteInfo2",y}}async function Lf({type:r,object:t,format:e="content",oid:n=void 0}){return e!=="deflated"&&(e!=="wrapped"&&(t=Gt.wrap({type:r,object:t})),n=await pt(t)),{oid:n,object:t}}async function no({object:r}){try{M("object",r),typeof r=="string"?r=Buffer.from(r,"utf8"):r instanceof Uint8Array||(r=new Uint8Array(r));const t="blob",{oid:e,object:n}=await Lf({type:t,format:"content",object:r});return{oid:e,type:t,object:n,format:"wrapped"}}catch(t){throw t.caller="git.hashBlob",t}}async function qf({fs:r,cache:t,onProgress:e,dir:n,gitdir:i,filepath:a}){try{a=W(n,a);const c=await r.read(a),l=y=>oe({fs:r,cache:t,gitdir:i,oid:y}),p=await ur.fromPack({pack:c,getExternalRefDelta:l,onProgress:e});return await r.write(a.replace(/\.pack$/,".idx"),await p.toBuffer()),{oids:[...p.hashes]}}catch(c){throw c.caller="git.indexPack",c}}async function io({fs:r,onProgress:t,dir:e,gitdir:n=W(e,".git"),filepath:i,cache:a={}}){try{M("fs",r),M("dir",e),M("gitdir",e),M("filepath",i);const c=new Tt(r),l=await $t({fsp:c,dotgit:n});return await qf({fs:c,cache:a,onProgress:t,dir:e,gitdir:l,filepath:i})}catch(c){throw c.caller="git.indexPack",c}}async function ao({fs:r,bare:t=!1,dir:e,gitdir:n=t?e:W(e,".git"),defaultBranch:i="master"}){try{M("fs",r),M("gitdir",n),t||M("dir",e);const a=new Tt(r),c=await $t({fsp:a,dotgit:n});return await Fa({fs:a,bare:t,dir:e,gitdir:c,defaultBranch:i})}catch(a){throw a.caller="git.init",a}}async function oo({fs:r,cache:t,gitdir:e,oid:n,ancestor:i,depth:a}){const c=await Gr.read({fs:r,gitdir:e});if(!n)throw new Oe("oid");if(!i)throw new Oe("ancestor");if(n===i)return!1;const l=[n],p=new Set;let y=0;for(;l.length;){if(y++===a)throw new $r(a);const d=l.shift(),{type:v,object:x}=await oe({fs:r,cache:t,gitdir:e,oid:d});if(v!=="commit")throw new Ft(d,v,"commit");const $=ce.from(x).parse();for(const q of $.parent)if(q===i)return!0;if(!c.has(d))for(const q of $.parent)p.has(q)||(l.push(q),p.add(q))}return!1}async function so({fs:r,dir:t,gitdir:e=W(t,".git"),oid:n,ancestor:i,depth:a=-1,cache:c={}}){try{M("fs",r),M("gitdir",e),M("oid",n),M("ancestor",i);const l=new Tt(r),p=await $t({fsp:l,dotgit:e});return await oo({fs:l,cache:c,gitdir:p,oid:n,ancestor:i,depth:a})}catch(l){throw l.caller="git.isDescendent",l}}async function co({fs:r,dir:t,gitdir:e=W(t,".git"),filepath:n}){try{M("fs",r),M("dir",t),M("gitdir",e),M("filepath",n);const i=new Tt(r),a=await $t({fsp:i,dotgit:e});return yr.isIgnored({fs:i,dir:t,gitdir:a,filepath:n})}catch(i){throw i.caller="git.isIgnored",i}}async function fo({fs:r,dir:t,gitdir:e=W(t,".git"),remote:n}){try{M("fs",r),M("gitdir",e);const i=new Tt(r),a=await $t({fsp:i,dotgit:e});return B.listBranches({fs:i,gitdir:a,remote:n})}catch(i){throw i.caller="git.listBranches",i}}async function zf({fs:r,gitdir:t,ref:e,cache:n}){if(e){const i=await B.resolve({gitdir:t,fs:r,ref:e}),a=[];return await uo({fs:r,cache:n,gitdir:t,oid:i,filenames:a,prefix:""}),a}else return ft.acquire({fs:r,gitdir:t,cache:n},async function(i){return i.entries.map(a=>a.path)})}async function uo({fs:r,cache:t,gitdir:e,oid:n,filenames:i,prefix:a}){const{tree:c}=await br({fs:r,cache:t,gitdir:e,oid:n});for(const l of c)l.type==="tree"?await uo({fs:r,cache:t,gitdir:e,oid:l.oid,filenames:i,prefix:W(a,l.path)}):i.push(W(a,l.path))}async function lo({fs:r,dir:t,gitdir:e=W(t,".git"),ref:n,cache:i={}}){try{M("fs",r),M("gitdir",e);const a=new Tt(r),c=await $t({fsp:a,dotgit:e});return await zf({fs:a,cache:i,gitdir:c,ref:n})}catch(a){throw a.caller="git.listFiles",a}}async function Gf({fs:r,cache:t,gitdir:e,ref:n}){let i;try{i=await B.resolve({gitdir:e,fs:r,ref:n})}catch(l){if(l instanceof Ct)return[]}return(await br({fs:r,cache:t,gitdir:e,oid:i})).tree.map(l=>({target:l.path,note:l.oid}))}async function ho({fs:r,dir:t,gitdir:e=W(t,".git"),ref:n="refs/notes/commits",cache:i={}}){try{M("fs",r),M("gitdir",e),M("ref",n);const a=new Tt(r),c=await $t({fsp:a,dotgit:e});return await Gf({fs:a,cache:i,gitdir:c,ref:n})}catch(a){throw a.caller="git.listNotes",a}}async function po({fs:r,dir:t,gitdir:e=W(t,".git"),filepath:n}){try{M("fs",r),M("gitdir",e);const i=new Tt(r),a=await $t({fsp:i,dotgit:e});return B.listRefs({fs:i,gitdir:a,filepath:n})}catch(i){throw i.caller="git.listRefs",i}}async function Hf({fs:r,gitdir:t}){const e=await z.get({fs:r,gitdir:t}),n=await e.getSubsections("remote");return Promise.all(n.map(async a=>{const c=await e.get(`remote.${a}.url`);return{remote:a,url:c}}))}async function wo({fs:r,dir:t,gitdir:e=W(t,".git")}){try{M("fs",r),M("gitdir",e);const n=new Tt(r),i=await $t({fsp:n,dotgit:e});return await Hf({fs:n,gitdir:i})}catch(n){throw n.caller="git.listRemotes",n}}async function Zf(r){const t=we.streamReader(r),e=[];let n;for(;n=await t(),n!==!0;){if(n===null)continue;n=n.toString("utf8").replace(/\n$/,"");const[i,a,...c]=n.split(" "),l={ref:a,oid:i};for(const p of c){const[y,d]=p.split(":");y==="symref-target"?l.target=d:y==="peeled"&&(l.peeled=d)}e.push(l)}return e}async function Wf({prefix:r,symrefs:t,peelTags:e}){const n=[];return n.push(we.encode(`command=ls-refs
`)),n.push(we.encode(`agent=${sn.agent}
`)),(e||t||r)&&n.push(we.delim()),e&&n.push(we.encode("peel")),t&&n.push(we.encode("symrefs")),r&&n.push(we.encode(`ref-prefix ${r}`)),n.push(we.flush()),n}async function go({http:r,onAuth:t,onAuthSuccess:e,onAuthFailure:n,corsProxy:i,url:a,headers:c={},forPush:l=!1,protocolVersion:p=2,prefix:y,symrefs:d,peelTags:v}){try{M("http",r),M("url",a);const x=await an.discover({http:r,onAuth:t,onAuthSuccess:e,onAuthFailure:n,corsProxy:i,service:l?"git-receive-pack":"git-upload-pack",url:a,headers:c,protocolVersion:p});if(x.protocolVersion===1)return eo(x,y,d,v);const $=await Wf({prefix:y,symrefs:d,peelTags:v}),q=await an.connect({http:r,auth:x.auth,headers:c,corsProxy:i,service:l?"git-receive-pack":"git-upload-pack",url:a,body:$});return Zf(q.body)}catch(x){throw x.caller="git.listServerRefs",x}}async function mo({fs:r,dir:t,gitdir:e=W(t,".git")}){try{M("fs",r),M("gitdir",e);const n=new Tt(r),i=await $t({fsp:n,dotgit:e});return B.listTags({fs:n,gitdir:i})}catch(n){throw n.caller="git.listTags",n}}function Xf(r,t){return r.committer.timestamp-t.committer.timestamp}const Vf="e69de29bb2d1d6434b8b29ae775ad8c2e48c5391";async function yo({fs:r,cache:t,gitdir:e,oid:n,fileId:i}){if(i===Vf)return;const a=n;let c;const l=await gr({fs:r,cache:t,gitdir:e,oid:n}),p=l.tree;return i===l.oid?c=l.path:(c=await _o({fs:r,cache:t,gitdir:e,tree:p,fileId:i,oid:a}),Array.isArray(c)&&(c.length===0?c=void 0:c.length===1&&(c=c[0]))),c}async function _o({fs:r,cache:t,gitdir:e,tree:n,fileId:i,oid:a,filepaths:c=[],parentPath:l=""}){const p=n.entries().map(function(y){let d;return y.oid===i?(d=W(l,y.path),c.push(d)):y.type==="tree"&&(d=oe({fs:r,cache:t,gitdir:e,oid:y.oid}).then(function({object:v}){return _o({fs:r,cache:t,gitdir:e,tree:bt.from(v),fileId:i,oid:a,filepaths:c,parentPath:W(l,y.path)})})),d});return await Promise.all(p),c}async function Yf({fs:r,cache:t,gitdir:e,filepath:n,ref:i,depth:a,since:c,force:l,follow:p}){const y=typeof c>"u"?void 0:Math.floor(c.valueOf()/1e3),d=[],v=await Gr.read({fs:r,gitdir:e}),x=await B.resolve({fs:r,gitdir:e,ref:i}),$=[await vr({fs:r,cache:t,gitdir:e,oid:x})];let q,tt,Y;function at(ot){Y&&n&&d.push(ot)}for(;$.length>0;){const ot=$.pop();if(y!==void 0&&ot.commit.committer.timestamp<=y)break;if(n){let vt;try{vt=await jr({fs:r,cache:t,gitdir:e,oid:ot.commit.tree,filepath:n}),tt&&q!==vt&&d.push(tt),q=vt,tt=ot,Y=!0}catch(At){if(At instanceof Ct){let Bt=p&&q;if(Bt&&(Bt=await yo({fs:r,cache:t,gitdir:e,oid:ot.commit.tree,fileId:q}),Bt))if(Array.isArray(Bt)){if(tt){const It=await yo({fs:r,cache:t,gitdir:e,oid:tt.commit.tree,fileId:q});if(Array.isArray(It))if(Bt=Bt.filter(wt=>It.indexOf(wt)===-1),Bt.length===1)Bt=Bt[0],n=Bt,tt&&d.push(tt);else{Bt=!1,tt&&d.push(tt);break}}}else n=Bt,tt&&d.push(tt);if(!Bt){if(Y&&q&&(d.push(tt),!l))break;if(!l&&!p)throw At}tt=ot,Y=!1}else throw At}}else d.push(ot);if(a!==void 0&&d.length===a){at(ot);break}if(!v.has(ot.oid))for(const vt of ot.commit.parent){const At=await vr({fs:r,cache:t,gitdir:e,oid:vt});$.map(Bt=>Bt.oid).includes(At.oid)||$.push(At)}$.length===0&&at(ot),$.sort((vt,At)=>Xf(vt.commit,At.commit))}return d}async function vo({fs:r,dir:t,gitdir:e=W(t,".git"),filepath:n,ref:i="HEAD",depth:a,since:c,force:l,follow:p,cache:y={}}){try{M("fs",r),M("gitdir",e),M("ref",i);const d=new Tt(r),v=await $t({fsp:d,dotgit:e});return await Yf({fs:d,cache:y,gitdir:v,filepath:n,ref:i,depth:a,since:c,force:l,follow:p})}catch(d){throw d.caller="git.log",d}}async function bo({fs:r,onSign:t,dir:e,gitdir:n=W(e,".git"),ours:i,theirs:a,fastForward:c=!0,fastForwardOnly:l=!1,dryRun:p=!1,noUpdateBranch:y=!1,abortOnConflict:d=!0,message:v,author:x,committer:$,signingKey:q,cache:tt={},mergeDriver:Y,allowUnrelatedHistories:at=!1}){try{M("fs",r),q&&M("onSign",t);const ot=new Tt(r),vt=await $t({fsp:ot,dotgit:n}),At=await Ke({fs:ot,gitdir:vt,author:x});if(!At&&(!l||!c))throw new Re("author");const Bt=await _r({fs:ot,gitdir:vt,author:At,committer:$});if(!Bt&&(!l||!c))throw new Re("committer");return await Ha({fs:ot,cache:tt,dir:e,gitdir:vt,ours:i,theirs:a,fastForward:c,fastForwardOnly:l,dryRun:p,noUpdateBranch:y,abortOnConflict:d,message:v,author:At,committer:Bt,signingKey:q,onSign:t,mergeDriver:Y,allowUnrelatedHistories:at})}catch(ot){throw ot.caller="git.merge",ot}}const Kf={commit:16,tree:32,blob:48,tag:64,ofs_delta:96,ref_delta:112};async function xo({fs:r,cache:t,dir:e,gitdir:n=W(e,".git"),oids:i}){const a=new j,c=[];function l(d,v){const x=Buffer.from(d,v);c.push(x),a.update(x)}async function p({stype:d,object:v}){const x=Kf[d];let $=v.length,q=$>15?128:0;const tt=$&15;$=$>>>4;let Y=(q|x|tt).toString(16);for(l(Y,"hex");q;)q=$>127?128:0,Y=q|$&127,l(En(2,Y),"hex"),$=$>>>7;l(Buffer.from(await la(v)))}l("PACK"),l("00000002","hex"),l(En(8,i.length),"hex");for(const d of i){const{type:v,object:x}=await oe({fs:r,cache:t,gitdir:n,oid:d});await p({object:x,stype:v})}const y=a.digest();return c.push(y),c}async function Jf({fs:r,cache:t,gitdir:e,oids:n,write:i}){const a=await xo({fs:r,cache:t,gitdir:e,oids:n}),c=Buffer.from(await nn(a)),p=`pack-${c.slice(-20).toString("hex")}.pack`;return i?(await r.write(W(e,`objects/pack/${p}`),c),{filename:p}):{filename:p,packfile:new Uint8Array(c)}}async function Eo({fs:r,dir:t,gitdir:e=W(t,".git"),oids:n,write:i=!1,cache:a={}}){try{M("fs",r),M("gitdir",e),M("oids",n);const c=new Tt(r),l=await $t({fsp:c,dotgit:e});return await Jf({fs:c,cache:a,gitdir:l,oids:n,write:i})}catch(c){throw c.caller="git.packObjects",c}}async function So({fs:r,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,dir:l,gitdir:p=W(l,".git"),ref:y,url:d,remote:v,remoteRef:x,prune:$=!1,pruneTags:q=!1,fastForward:tt=!0,fastForwardOnly:Y=!1,corsProxy:at,singleBranch:ot,headers:vt={},author:At,committer:Bt,signingKey:It,cache:wt={}}){try{M("fs",r),M("gitdir",p);const yt=new Tt(r),xt=await $t({fsp:yt,dotgit:p}),Lt=await Ke({fs:yt,gitdir:xt,author:At});if(!Lt)throw new Re("author");const Yt=await _r({fs:yt,gitdir:xt,author:Lt,committer:Bt});if(!Yt)throw new Re("committer");return await Za({fs:yt,cache:wt,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,dir:l,gitdir:xt,ref:y,url:d,remote:v,remoteRef:x,fastForward:tt,fastForwardOnly:Y,corsProxy:at,singleBranch:ot,headers:vt,author:Lt,committer:Yt,signingKey:It,prune:$,pruneTags:q})}catch(yt){throw yt.caller="git.pull",yt}}async function Qf({fs:r,cache:t,dir:e,gitdir:n=W(e,".git"),start:i,finish:a}){const c=await Gr.read({fs:r,gitdir:n}),l=new Set,p=new Set;for(const v of i)l.add(await B.resolve({fs:r,gitdir:n,ref:v}));for(const v of a)try{const x=await B.resolve({fs:r,gitdir:n,ref:v});p.add(x)}catch{}const y=new Set;async function d(v){y.add(v);const{type:x,object:$}=await oe({fs:r,cache:t,gitdir:n,oid:v});if(x==="tag"){const tt=Ie.from($).headers().object;return d(tt)}if(x!=="commit")throw new Ft(v,x,"commit");if(!c.has(v)){const tt=ce.from($).headers().parent;for(v of tt)!p.has(v)&&!y.has(v)&&await d(v)}}for(const v of l)await d(v);return y}async function In({fs:r,cache:t,dir:e,gitdir:n=W(e,".git"),oids:i}){const a=new Set;async function c(l){if(a.has(l))return;a.add(l);const{type:p,object:y}=await oe({fs:r,cache:t,gitdir:n,oid:l});if(p==="tag"){const v=Ie.from(y).headers().object;await c(v)}else if(p==="commit"){const v=ce.from(y).headers().tree;await c(v)}else if(p==="tree"){const d=bt.from(y);for(const v of d)v.type==="blob"&&a.add(v.oid),v.type==="tree"&&await c(v.oid)}}for(const l of i)await c(l);return a}async function tu(r){const t={};let e="";const n=we.streamReader(r);let i=await n();for(;i!==!0;)i!==null&&(e+=i.toString("utf8")+`
`),i=await n();const a=e.toString("utf8").split(`
`);if(i=a.shift(),!i.startsWith("unpack "))throw new rr('unpack ok" or "unpack [error message]',i);t.ok=i==="unpack ok",t.ok||(t.error=i.slice(7)),t.refs={};for(const c of a){if(c.trim()==="")continue;const l=c.slice(0,2),p=c.slice(3);let y=p.indexOf(" ");y===-1&&(y=p.length);const d=p.slice(0,y),v=p.slice(y+1);t.refs[d]={ok:l==="ok",error:v}}return t}async function eu({capabilities:r=[],triplets:t=[]}){const e=[];let n=`\0 ${r.join(" ")}`;for(const i of t)e.push(we.encode(`${i.oldoid} ${i.oid} ${i.fullRef}${n}
`)),n="";return e.push(we.flush()),e}async function ru({fs:r,cache:t,http:e,onProgress:n,onMessage:i,onAuth:a,onAuthSuccess:c,onAuthFailure:l,onPrePush:p,gitdir:y,ref:d,remoteRef:v,remote:x,url:$,force:q=!1,delete:tt=!1,corsProxy:Y,headers:at={}}){const ot=d||await Je({fs:r,gitdir:y});if(typeof ot>"u")throw new Oe("ref");const vt=await z.get({fs:r,gitdir:y});x=x||await vt.get(`branch.${ot}.pushRemote`)||await vt.get("remote.pushDefault")||await vt.get(`branch.${ot}.remote`)||"origin";const At=$||await vt.get(`remote.${x}.pushurl`)||await vt.get(`remote.${x}.url`);if(typeof At>"u")throw new Oe("remote OR url");const Bt=v||await vt.get(`branch.${ot}.merge`);if(typeof At>"u")throw new Oe("remoteRef");Y===void 0&&(Y=await vt.get("http.corsProxy"));const It=await B.expand({fs:r,gitdir:y,ref:ot}),wt=tt?"0000000000000000000000000000000000000000":await B.resolve({fs:r,gitdir:y,ref:It}),yt=on.getRemoteHelperFor({url:At}),xt=await yt.discover({http:e,onAuth:a,onAuthSuccess:c,onAuthFailure:l,corsProxy:Y,service:"git-receive-pack",url:At,headers:at,protocolVersion:1}),Lt=xt.auth;let Yt;if(!Bt)Yt=It;else try{Yt=await B.expandAgainstMap({ref:Bt,map:xt.refs})}catch(le){if(le instanceof Ct)Yt=Bt.startsWith("refs/")?Bt:`refs/heads/${Bt}`;else throw le}const ye=xt.refs.get(Yt)||"0000000000000000000000000000000000000000";if(p&&!await p({remote:x,url:At,localRef:{ref:tt?"(delete)":It,oid:wt},remoteRef:{ref:Yt,oid:ye}}))throw new wr;const Qt=!xt.capabilities.has("no-thin");let _e=new Set;if(!tt){const le=[...xt.refs.values()];let Ge=new Set;if(ye!=="0000000000000000000000000000000000000000"){const Be=await Rn({fs:r,cache:t,gitdir:y,oids:[wt,ye]});for(const Hr of Be)le.push(Hr);Qt&&(Ge=await In({fs:r,cache:t,gitdir:y,oids:Be}))}if(!le.includes(wt)){const Be=await Qf({fs:r,cache:t,gitdir:y,start:[wt],finish:le});_e=await In({fs:r,cache:t,gitdir:y,oids:Be})}if(Qt){try{const Be=await B.resolve({fs:r,gitdir:y,ref:`refs/remotes/${x}/HEAD`,depth:2}),{oid:Hr}=await B.resolveAgainstMap({ref:Be.replace(`refs/remotes/${x}/`,""),fullref:Be,map:xt.refs}),sr=[Hr];for(const ve of await In({fs:r,cache:t,gitdir:y,oids:sr}))Ge.add(ve)}catch{}for(const Be of Ge)_e.delete(Be)}if(wt===ye&&(q=!0),!q){if(It.startsWith("refs/tags")&&ye!=="0000000000000000000000000000000000000000")throw new pr("tag-exists");if(wt!=="0000000000000000000000000000000000000000"&&ye!=="0000000000000000000000000000000000000000"&&!await oo({fs:r,cache:t,gitdir:y,oid:wt,ancestor:ye,depth:-1}))throw new pr("not-fast-forward")}}const Se=$a([...xt.capabilities],["report-status","side-band-64k",`agent=${sn.agent}`]),ar=await eu({capabilities:Se,triplets:[{oldoid:ye,oid:wt,fullRef:Yt}]}),or=tt?[]:await xo({fs:r,cache:t,gitdir:y,oids:[..._e]}),Er=await yt.connect({http:e,onProgress:n,corsProxy:Y,service:"git-receive-pack",url:At,auth:Lt,headers:at,body:[...ar,...or]}),{packfile:$n,progress:Pn}=await Ca.demux(Er.body);if(i){const le=Pa(Pn);zr(le,async Ge=>{await i(Ge)})}const Ce=await tu($n);if(Er.headers&&(Ce.headers=Er.headers),x&&Ce.ok&&Ce.refs[Yt].ok&&!It.startsWith("refs/tags")){const le=`refs/remotes/${x}/${Yt.replace("refs/heads","")}`;tt?await B.deleteRef({fs:r,gitdir:y,ref:le}):await B.writeRef({fs:r,gitdir:y,ref:le,value:wt})}if(Ce.ok&&Object.values(Ce.refs).every(le=>le.ok))return Ce;{const le=Object.entries(Ce.refs).filter(([Ge,Be])=>!Be.ok).map(([Ge,Be])=>`
  - ${Ge}: ${Be.error}`).join("");throw new Or(le,Ce)}}async function Ao({fs:r,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,onPrePush:l,dir:p,gitdir:y=W(p,".git"),ref:d,remoteRef:v,remote:x="origin",url:$,force:q=!1,delete:tt=!1,corsProxy:Y,headers:at={},cache:ot={}}){try{M("fs",r),M("http",t),M("gitdir",y);const vt=new Tt(r),At=await $t({fsp:vt,dotgit:y});return await ru({fs:vt,cache:ot,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,onPrePush:l,gitdir:At,ref:d,remoteRef:v,remote:x,url:$,force:q,delete:tt,corsProxy:Y,headers:at})}catch(vt){throw vt.caller="git.push",vt}}async function ko({fs:r,cache:t,gitdir:e,oid:n}){const{type:i,object:a}=await oe({fs:r,cache:t,gitdir:e,oid:n});if(i==="tag")return n=Ie.from(a).parse().object,ko({fs:r,cache:t,gitdir:e,oid:n});if(i!=="blob")throw new Ft(n,i,"blob");return{oid:n,blob:new Uint8Array(a)}}async function Ro({fs:r,cache:t,gitdir:e,oid:n,filepath:i=void 0}){return i!==void 0&&(n=await jr({fs:r,cache:t,gitdir:e,oid:n,filepath:i})),await ko({fs:r,cache:t,gitdir:e,oid:n})}async function Bo({fs:r,dir:t,gitdir:e=W(t,".git"),oid:n,filepath:i,cache:a={}}){try{M("fs",r),M("gitdir",e),M("oid",n);const c=new Tt(r),l=await $t({fsp:c,dotgit:e});return await Ro({fs:c,cache:a,gitdir:l,oid:n,filepath:i})}catch(c){throw c.caller="git.readBlob",c}}async function Tn({fs:r,dir:t,gitdir:e=W(t,".git"),oid:n,cache:i={}}){try{M("fs",r),M("gitdir",e),M("oid",n);const a=new Tt(r),c=await $t({fsp:a,dotgit:e});return await vr({fs:a,cache:i,gitdir:c,oid:n})}catch(a){throw a.caller="git.readCommit",a}}async function nu({fs:r,cache:t,gitdir:e,ref:n="refs/notes/commits",oid:i}){const a=await B.resolve({gitdir:e,fs:r,ref:n}),{blob:c}=await Ro({fs:r,cache:t,gitdir:e,oid:a,filepath:i});return c}async function Io({fs:r,dir:t,gitdir:e=W(t,".git"),ref:n="refs/notes/commits",oid:i,cache:a={}}){try{M("fs",r),M("gitdir",e),M("ref",n),M("oid",i);const c=new Tt(r),l=await $t({fsp:c,dotgit:e});return await nu({fs:c,cache:a,gitdir:l,ref:n,oid:i})}catch(c){throw c.caller="git.readNote",c}}async function To({fs:r,dir:t,gitdir:e=W(t,".git"),oid:n,format:i="parsed",filepath:a=void 0,encoding:c=void 0,cache:l={}}){try{M("fs",r),M("gitdir",e),M("oid",n);const p=new Tt(r),y=await $t({fsp:p,dotgit:e});a!==void 0&&(n=await jr({fs:p,cache:l,gitdir:y,oid:n,filepath:a}));const v=await oe({fs:p,cache:l,gitdir:y,oid:n,format:i==="parsed"?"content":i});if(v.oid=n,i==="parsed")switch(v.format="parsed",v.type){case"commit":v.object=ce.from(v.object).parse();break;case"tree":v.object=bt.from(v.object).entries();break;case"blob":c?v.object=v.object.toString(c):(v.object=new Uint8Array(v.object),v.format="content");break;case"tag":v.object=Ie.from(v.object).parse();break;default:throw new Ft(v.oid,v.type,"blob|commit|tag|tree")}else(v.format==="deflated"||v.format==="wrapped")&&(v.type=v.format);return v}catch(p){throw p.caller="git.readObject",p}}async function iu({fs:r,cache:t,gitdir:e,oid:n}){const{type:i,object:a}=await oe({fs:r,cache:t,gitdir:e,oid:n,format:"content"});if(i!=="tag")throw new Ft(n,i,"tag");const c=Ie.from(a);return{oid:n,tag:c.parse(),payload:c.payload()}}async function Oo({fs:r,dir:t,gitdir:e=W(t,".git"),oid:n,cache:i={}}){try{M("fs",r),M("gitdir",e),M("oid",n);const a=new Tt(r),c=await $t({fsp:a,dotgit:e});return await iu({fs:a,cache:i,gitdir:c,oid:n})}catch(a){throw a.caller="git.readTag",a}}async function $o({fs:r,dir:t,gitdir:e=W(t,".git"),oid:n,filepath:i=void 0,cache:a={}}){try{M("fs",r),M("gitdir",e),M("oid",n);const c=new Tt(r),l=await $t({fsp:c,dotgit:e});return await br({fs:c,cache:a,gitdir:l,oid:n,filepath:i})}catch(c){throw c.caller="git.readTree",c}}async function Po({fs:r,dir:t,gitdir:e=W(t,".git"),filepath:n,cache:i={}}){try{M("fs",r),M("gitdir",e),M("filepath",n);const a=new Tt(r),c=await $t({fsp:a,dotgit:e});await ft.acquire({fs:a,gitdir:c,cache:i},async function(l){l.delete({filepath:n})})}catch(a){throw a.caller="git.remove",a}}async function au({fs:r,cache:t,onSign:e,gitdir:n,ref:i="refs/notes/commits",oid:a,author:c,committer:l,signingKey:p}){let y;try{y=await B.resolve({gitdir:n,fs:r,ref:i})}catch(q){if(!(q instanceof Ct))throw q}let v=(await br({fs:r,cache:t,gitdir:n,oid:y||"4b825dc642cb6eb9a060e54bf8d69288fbee4904"})).tree;v=v.filter(q=>q.path!==a);const x=await Lr({fs:r,gitdir:n,tree:v});return await rn({fs:r,cache:t,onSign:e,gitdir:n,ref:i,tree:x,parent:y&&[y],message:`Note removed by 'isomorphic-git removeNote'
`,author:c,committer:l,signingKey:p})}async function Co({fs:r,onSign:t,dir:e,gitdir:n=W(e,".git"),ref:i="refs/notes/commits",oid:a,author:c,committer:l,signingKey:p,cache:y={}}){try{M("fs",r),M("gitdir",n),M("oid",a);const d=new Tt(r),v=await $t({fsp:d,dotgit:n}),x=await Ke({fs:d,gitdir:v,author:c});if(!x)throw new Re("author");const $=await _r({fs:d,gitdir:v,author:x,committer:l});if(!$)throw new Re("committer");return await au({fs:d,cache:y,onSign:t,gitdir:v,ref:i,oid:a,author:x,committer:$,signingKey:p})}catch(d){throw d.caller="git.removeNote",d}}async function ou({fs:r,gitdir:t,oldref:e,ref:n,checkout:i=!1}){if(!qr(n))throw new Le(n,m.clean(n));if(!qr(e))throw new Le(e,m.clean(e));const a=`refs/heads/${e}`,c=`refs/heads/${n}`;if(await B.exists({fs:r,gitdir:t,ref:c}))throw new je("branch",n,!1);const p=await B.resolve({fs:r,gitdir:t,ref:a,depth:1});await B.writeRef({fs:r,gitdir:t,ref:c,value:p}),await B.deleteRef({fs:r,gitdir:t,ref:a});const d=await Je({fs:r,gitdir:t,fullname:!0})===a;(i||d)&&await B.writeSymbolicRef({fs:r,gitdir:t,ref:"HEAD",value:c})}async function Fo({fs:r,dir:t,gitdir:e=W(t,".git"),ref:n,oldref:i,checkout:a=!1}){try{M("fs",r),M("gitdir",e),M("ref",n),M("oldref",i);const c=new Tt(r),l=await $t({fsp:c,dotgit:e});return await ou({fs:c,gitdir:l,ref:n,oldref:i,checkout:a})}catch(c){throw c.caller="git.renameBranch",c}}async function Do({gitdir:r,type:t,object:e}){return pt(Gt.wrap({type:t,object:e}))}async function Uo({fs:r,dir:t,gitdir:e=W(t,".git"),filepath:n,ref:i,cache:a={}}){try{M("fs",r),M("gitdir",e),M("filepath",n);const c=new Tt(r),l=await $t({fsp:c,dotgit:e});let p,y;try{p=await B.resolve({fs:c,gitdir:l,ref:i||"HEAD"})}catch(x){if(i)throw x}if(p)try{p=await jr({fs:c,cache:a,gitdir:l,oid:p,filepath:n})}catch{p=null}let d={ctime:new Date(0),mtime:new Date(0),dev:0,ino:0,mode:0,uid:0,gid:0,size:0};const v=t&&await c.read(W(t,n));v&&(y=await Do({gitdir:l,type:"blob",object:v}),p===y&&(d=await c.lstat(W(t,n)))),await ft.acquire({fs:c,gitdir:l,cache:a},async function(x){x.delete({filepath:n}),p&&x.insert({filepath:n,stats:d,oid:p})})}catch(c){throw c.caller="git.reset",c}}async function No({fs:r,dir:t,gitdir:e=W(t,".git"),ref:n,depth:i}){try{M("fs",r),M("gitdir",e),M("ref",n);const a=new Tt(r),c=await $t({fsp:a,dotgit:e});return await B.resolve({fs:a,gitdir:c,ref:n,depth:i})}catch(a){throw a.caller="git.resolveRef",a}}async function Mo({fs:r,dir:t,gitdir:e=W(t,".git"),path:n,value:i,append:a=!1}){try{M("fs",r),M("gitdir",e),M("path",n);const c=new Tt(r),l=await $t({fsp:c,dotgit:e}),p=await z.get({fs:c,gitdir:l});a?await p.append(n,i):await p.set(n,i),await z.save({fs:c,gitdir:l,config:p})}catch(c){throw c.caller="git.setConfig",c}}async function jo({fs:r,gitdir:t,commit:e}){const n=ce.from(e).toObject();return await $e({fs:r,gitdir:t,type:"commit",object:n,format:"content"})}class fn{static get timezoneOffsetForRefLogEntry(){const t=new Date().getTimezoneOffset(),e=Math.abs(Math.floor(t/60)),n=Math.abs(t%60).toString().padStart(2,"0");return`${t>0?"-":"+"}${e.toString().padStart(2,"0")}${n}`}static createStashReflogEntry(t,e,n){const i=t.name.replace(/\s/g,""),a="0000000000000000000000000000000000000000",c=Math.floor(Date.now()/1e3),l=fn.timezoneOffsetForRefLogEntry;return`${a} ${e} ${i} ${t.email} ${c} ${l}	${n}
`}static getStashReflogEntry(t,e=!1){return t.split(`
`).filter(a=>a).reverse().map((a,c)=>e?`stash@{${c}}: ${a.split("	")[1]}`:a)}}const su={stage:qt,workdir:mr};let On;async function xr(r,t){return On===void 0&&(On=new S),On.acquire(r,t)}async function cu(r,t,e,n,i=null){const a=W(e,n),c=await r.lstat(a);if(!c)throw new Ct(a);if(c.isDirectory())throw new A(`${a}: file expected, but found directory`);const l=i?await Fe({fs:r,gitdir:t,oid:i}):void 0;let p=l?i:void 0;return l||await xr({fs:r,gitdir:t,currentFilepath:a},async()=>{const y=c.isSymbolicLink()?await r.readlink(a).then(ha):await r.read(a);if(y===null)throw new Ct(a);p=await $e({fs:r,gitdir:t,type:"blob",object:y})}),p}async function fu({fs:r,dir:t,gitdir:e,entries:n}){async function i(a){if(a.type==="tree"){if(!a.oid){const c=await Promise.all(a.children.map(i));a.oid=await Lr({fs:r,gitdir:e,tree:c}),a.mode=16384}}else a.type==="blob"&&(a.oid=await cu(r,e,t,a.path,a.oid),a.mode=33188);return a.path=a.path.split("/").pop(),a}return Promise.all(n.map(i))}async function Lo({fs:r,dir:t,gitdir:e,treePair:n}){const i=n[1]==="stage",a=n.map($=>typeof $=="string"?su[$]():$),c=[],d=await Ye({fs:r,cache:{},dir:t,gitdir:e,trees:a,map:async($,[q,tt])=>{if(!($==="."||await yr.isIgnored({fs:r,dir:t,gitdir:e,filepath:$}))&&tt)return(!q||await q.oid()!==await tt.oid()&&await tt.oid()!==void 0)&&c.push([q,tt]),{mode:await tt.mode(),path:$,oid:await tt.oid(),type:await tt.type()}},reduce:async($,q)=>(q=q.filter(Boolean),$?($.children=q,$):q.length>0?q:void 0),iterate:async($,q)=>{const tt=[];for(const Y of q){const[at,ot]=Y;i?ot&&(await r.exists(`${t}/${ot.toString()}`)?tt.push(Y):c.push([null,ot])):at&&(ot?tt.push(Y):c.push([at,null]))}return tt.length?Promise.all(tt.map($)):[]}});if(c.length===0||d.length===0)return null;const x=(await fu({fs:r,dir:t,gitdir:e,entries:d})).filter(Boolean).map($=>({mode:$.mode,path:$.path,oid:$.oid,type:$.type}));return Lr({fs:r,gitdir:e,tree:x})}async function uu({fs:r,dir:t,gitdir:e,stashCommit:n,parentCommit:i,wasStaged:a}){const c=[],l=[],p=await Ye({fs:r,cache:{},dir:t,gitdir:e,trees:[Pe({ref:i}),Pe({ref:n})],map:async(y,[d,v])=>{if(y==="."||await yr.isIgnored({fs:r,dir:t,gitdir:e,filepath:y}))return;const x=v?await v.type():await d.type();if(x!=="tree"&&x!=="blob")return;if(!v&&d){const q=x==="tree"?"rmdir":"rm";return x==="tree"&&c.push(y),x==="blob"&&a&&l.push({filepath:y,oid:await d.oid()}),{method:q,filepath:y}}const $=await v.oid();if(!d||await d.oid()!==$)return x==="tree"?{method:"mkdir",filepath:y}:(a&&l.push({filepath:y,oid:$,stats:await r.lstat(W(t,y))}),{method:"write",filepath:y,oid:$})}});await xr({fs:r,gitdir:e,dirRemoved:c,ops:p},async()=>{for(const y of p){const d=W(t,y.filepath);switch(y.method){case"rmdir":await r.rmdir(d);break;case"mkdir":await r.mkdir(d);break;case"rm":await r.rm(d);break;case"write":if(!c.some(v=>d.startsWith(v))){const{object:v}=await oe({fs:r,cache:{},gitdir:e,oid:y.oid});await r.exists(d)&&await r.rm(d),await r.write(d,v)}break}}}),await ft.acquire({fs:r,gitdir:e,cache:{}},async y=>{l.forEach(({filepath:d,stats:v,oid:x})=>{y.insert({filepath:d,stats:v,oid:x})})})}class We{constructor({fs:t,dir:e,gitdir:n=W(e,".git")}){Object.assign(this,{fs:t,dir:e,gitdir:n,_author:null})}static get refStash(){return"refs/stash"}static get refLogsStash(){return"logs/refs/stash"}get refStashPath(){return W(this.gitdir,We.refStash)}get refLogsStashPath(){return W(this.gitdir,We.refLogsStash)}async getAuthor(){if(!this._author&&(this._author=await Ke({fs:this.fs,gitdir:this.gitdir,author:{}}),!this._author))throw new Re("author");return this._author}async getStashSHA(t,e){return await this.fs.exists(this.refStashPath)?(e||await this.readStashReflogs({parsed:!1}))[t].split(" ")[1]:null}async writeStashCommit({message:t,tree:e,parent:n}){return jo({fs:this.fs,gitdir:this.gitdir,commit:{message:t,tree:e,parent:n,author:await this.getAuthor(),committer:await this.getAuthor()}})}async readStashCommit(t){const e=await this.readStashReflogs({parsed:!1});if(t!==0&&(t<0||t>e.length-1))throw new Le(`stash@${t}`,"number that is in range of [0, num of stash pushed]");const n=await this.getStashSHA(t,e);return n?vr({fs:this.fs,cache:{},gitdir:this.gitdir,oid:n}):{}}async writeStashRef(t){return B.writeRef({fs:this.fs,gitdir:this.gitdir,ref:We.refStash,value:t})}async writeStashReflogEntry({stashCommit:t,message:e}){const n=await this.getAuthor(),i=fn.createStashReflogEntry(n,t,e),a=this.refLogsStashPath;await xr({filepath:a,entry:i},async()=>{const c=await this.fs.exists(a)?await this.fs.read(a,"utf8"):"";await this.fs.write(a,c+i,"utf8")})}async readStashReflogs({parsed:t=!1}){if(!await this.fs.exists(this.refLogsStashPath))return[];const e=await this.fs.read(this.refLogsStashPath,"utf8");return fn.getStashReflogEntry(e,t)}}async function qo({fs:r,dir:t,gitdir:e,message:n=""}){const i=new We({fs:r,dir:t,gitdir:e});await i.getAuthor();const a=await Je({fs:r,gitdir:e,fullname:!1}),c=await B.resolve({fs:r,gitdir:e,ref:"HEAD"}),p=(await Tn({fs:r,dir:t,gitdir:e,oid:c})).commit.message,y=[c];let d=null,v=Pe({ref:"HEAD"});const x=await Lo({fs:r,dir:t,gitdir:e,treePair:[Pe({ref:"HEAD"}),"stage"]});if(x){const Y=await i.writeStashCommit({message:`stash-Index: WIP on ${a} - ${new Date().toISOString()}`,tree:x,parent:y});y.push(Y),d=x,v=qt()}const $=await Lo({fs:r,dir:t,gitdir:e,treePair:[v,"workdir"]});if($){const Y=await i.writeStashCommit({message:`stash-WorkDir: WIP on ${a} - ${new Date().toISOString()}`,tree:$,parent:[y[y.length-1]]});y.push(Y),d=$}if(!d||!x&&!$)throw new Ct("changes, nothing to stash");const q=(n.trim()||`WIP on ${a}`)+`: ${c.substring(0,7)} ${p}`;return{stashCommit:await i.writeStashCommit({message:q,tree:d,parent:y}),stashMsg:q,branch:a,stashMgr:i}}async function lu({fs:r,dir:t,gitdir:e,message:n=""}){const{stashCommit:i,stashMsg:a,branch:c,stashMgr:l}=await qo({fs:r,dir:t,gitdir:e,message:n});return await l.writeStashRef(i),await l.writeStashReflogEntry({stashCommit:i,message:a}),await xn({fs:r,dir:t,gitdir:e,ref:c,track:!1,force:!0}),i}async function hu({fs:r,dir:t,gitdir:e,message:n=""}){const{stashCommit:i}=await qo({fs:r,dir:t,gitdir:e,message:n});return i}async function zo({fs:r,dir:t,gitdir:e,refIdx:n=0}){const a=await new We({fs:r,dir:t,gitdir:e}).readStashCommit(n),{parent:c=null}=a.commit?a.commit:{};if(!(!c||!Array.isArray(c)))for(let l=0;l<c.length-1;l++){const y=(await vr({fs:r,cache:{},gitdir:e,oid:c[l+1]})).commit.message.startsWith("stash-Index");await uu({fs:r,dir:t,gitdir:e,stashCommit:c[l+1],parentCommit:c[l],wasStaged:y})}}async function Go({fs:r,dir:t,gitdir:e,refIdx:n=0}){const i=new We({fs:r,dir:t,gitdir:e});if(!(await i.readStashCommit(n)).commit)return;const c=i.refStashPath;await xr(c,async()=>{await r.exists(c)&&await r.rm(c)});const l=await i.readStashReflogs({parsed:!1});if(!l.length)return;l.splice(n,1);const p=i.refLogsStashPath;await xr({reflogEntries:l,stashReflogPath:p,stashMgr:i},async()=>{if(l.length){await r.write(p,l.reverse().join(`
`)+`
`,"utf8");const y=l[l.length-1].split(" ")[1];await i.writeStashRef(y)}else await r.rm(p)})}async function du({fs:r,dir:t,gitdir:e}){return new We({fs:r,dir:t,gitdir:e}).readStashReflogs({parsed:!0})}async function pu({fs:r,dir:t,gitdir:e}){const n=new We({fs:r,dir:t,gitdir:e}),i=[n.refStashPath,n.refLogsStashPath];await xr(i,async()=>{await Promise.all(i.map(async a=>{if(await r.exists(a))return r.rm(a)}))})}async function wu({fs:r,dir:t,gitdir:e,refIdx:n=0}){await zo({fs:r,dir:t,gitdir:e,refIdx:n}),await Go({fs:r,dir:t,gitdir:e,refIdx:n})}async function Ho({fs:r,dir:t,gitdir:e=W(t,".git"),op:n="push",message:i="",refIdx:a=0}){M("fs",r),M("dir",t),M("gitdir",e),M("op",n);const c={push:lu,apply:zo,drop:Go,list:du,clear:pu,pop:wu,create:hu},l=["apply","drop","pop"];try{const p=new Tt(r),y=await $t({fsp:p,dotgit:e});["refs","logs","logs/refs"].map(x=>W(y,x)).forEach(async x=>{await p.exists(x)||await p.mkdir(x)});const v=c[n];if(v){if(l.includes(n)&&a<0)throw new Le(`stash@${a}`,"number that is in range of [0, num of stash pushed]");return await v({fs:p,dir:t,gitdir:y,message:i,refIdx:a})}throw new Error(`To be implemented: ${n}`)}catch(p){throw p.caller="git.stash",p}}async function Zo({fs:r,dir:t,gitdir:e=W(t,".git"),filepath:n,cache:i={}}){try{M("fs",r),M("gitdir",e),M("filepath",n);const a=new Tt(r),c=await $t({fsp:a,dotgit:e});if(await yr.isIgnored({fs:a,gitdir:c,dir:t,filepath:n}))return"ignored";const p=await gu({fs:a,cache:i,gitdir:c}),y=await Wo({fs:a,cache:i,gitdir:c,tree:p,path:n}),d=await ft.acquire({fs:a,gitdir:c,cache:i},async function(Y){for(const at of Y)if(at.path===n)return at;return null}),v=await a.lstat(W(t,n)),x=y!==null,$=d!==null,q=v!==null,tt=async()=>{if($&&!mt(d,v))return d.oid;{const Y=await a.read(W(t,n)),at=await Do({gitdir:c,type:"blob",object:Y});return $&&d.oid===at&&v.size!==-1&&ft.acquire({fs:a,gitdir:c,cache:i},async function(ot){ot.insert({filepath:n,stats:v,oid:at})}),at}};if(!x&&!q&&!$)return"absent";if(!x&&!q&&$)return"*absent";if(!x&&q&&!$)return"*added";if(!x&&q&&$)return await tt()===d.oid?"added":"*added";if(x&&!q&&!$)return"deleted";if(x&&!q&&$)return y===d.oid,"*deleted";if(x&&q&&!$)return await tt()===y?"*undeleted":"*undeletemodified";if(x&&q&&$){const Y=await tt();return Y===y?Y===d.oid?"unmodified":"*unmodified":Y===d.oid?"modified":"*modified"}}catch(a){throw a.caller="git.status",a}}async function Wo({fs:r,cache:t,gitdir:e,tree:n,path:i}){typeof i=="string"&&(i=i.split("/"));const a=i.shift();for(const c of n)if(c.path===a){if(i.length===0)return c.oid;const{type:l,object:p}=await oe({fs:r,cache:t,gitdir:e,oid:c.oid});if(l==="tree"){const y=bt.from(p);return Wo({fs:r,cache:t,gitdir:e,tree:y,path:i})}if(l==="blob")throw new Ft(c.oid,l,"blob",i.join("/"))}return null}async function gu({fs:r,cache:t,gitdir:e}){let n;try{n=await B.resolve({fs:r,gitdir:e,ref:"HEAD"})}catch(a){if(a instanceof Ct)return[]}const{tree:i}=await br({fs:r,cache:t,gitdir:e,oid:n});return i}async function Xo({fs:r,dir:t,gitdir:e=W(t,".git"),ref:n="HEAD",filepaths:i=["."],filter:a,cache:c={},ignored:l=!1}){try{M("fs",r),M("gitdir",e),M("ref",n);const p=new Tt(r),y=await $t({fsp:p,dotgit:e});return await Ye({fs:p,cache:c,dir:t,gitdir:y,trees:[Pe({ref:n}),mr(),qt()],map:async function(d,[v,x,$]){if(!v&&!$&&x&&!l&&await yr.isIgnored({fs:p,dir:t,filepath:d})||!i.some(wt=>Ea(d,wt)))return null;if(a&&!a(d))return;const[q,tt,Y]=await Promise.all([v&&v.type(),x&&x.type(),$&&$.type()]),at=[q,tt,Y].includes("blob");if((q==="tree"||q==="special")&&!at)return;if(q==="commit")return null;if((tt==="tree"||tt==="special")&&!at)return;if(Y==="commit")return null;if((Y==="tree"||Y==="special")&&!at)return;const ot=q==="blob"?await v.oid():void 0,vt=Y==="blob"?await $.oid():void 0;let At;q!=="blob"&&tt==="blob"&&Y!=="blob"?At="42":tt==="blob"&&(At=await x.oid());const Bt=[void 0,ot,At,vt],It=Bt.map(wt=>Bt.indexOf(wt));return It.shift(),[d,...It]}})}catch(p){throw p.caller="git.statusMatrix",p}}async function Vo({fs:r,dir:t,gitdir:e=W(t,".git"),ref:n,object:i,force:a=!1}){try{M("fs",r),M("gitdir",e),M("ref",n);const c=new Tt(r);if(n===void 0)throw new Oe("ref");n=n.startsWith("refs/tags/")?n:`refs/tags/${n}`;const l=await $t({fsp:c,dotgit:e}),p=await B.resolve({fs:c,gitdir:l,ref:i||"HEAD"});if(!a&&await B.exists({fs:c,gitdir:l,ref:n}))throw new je("tag",n);await B.writeRef({fs:c,gitdir:l,ref:n,value:p})}catch(c){throw c.caller="git.tag",c}}async function Yo({fs:r,dir:t,gitdir:e=W(t,".git"),cache:n={},filepath:i,oid:a,mode:c,add:l,remove:p,force:y}){try{M("fs",r),M("gitdir",e),M("filepath",i);const d=new Tt(r),v=await $t({fsp:d,dotgit:e});if(p)return await ft.acquire({fs:d,gitdir:v,cache:n},async function($){if(!y){const q=await d.lstat(W(t,i));if(q){if(q.isDirectory())throw new Xe("directory");return}}$.has({filepath:i})&&$.delete({filepath:i})});let x;if(!a){if(x=await d.lstat(W(t,i)),!x)throw new Ct(`file at "${i}" on disk and "remove" not set`);if(x.isDirectory())throw new Xe("directory")}return await ft.acquire({fs:d,gitdir:v,cache:n},async function($){if(!l&&!$.has({filepath:i}))throw new Ct(`file at "${i}" in index and "add" not set`);let q;if(a)q={ctime:new Date(0),mtime:new Date(0),dev:0,ino:0,mode:c,uid:0,gid:0,size:0};else{q=x;const tt=q.isSymbolicLink()?await d.readlink(W(t,i)):await d.read(W(t,i));a=await $e({fs:d,gitdir:v,type:"blob",format:"content",object:tt})}return $.insert({filepath:i,oid:a,stats:q}),a})}catch(d){throw d.caller="git.updateIndex",d}}function Ko(){try{return sn.version}catch(r){throw r.caller="git.version",r}}async function Jo({fs:r,dir:t,gitdir:e=W(t,".git"),trees:n,map:i,reduce:a,iterate:c,cache:l={}}){try{M("fs",r),M("gitdir",e),M("trees",n);const p=new Tt(r),y=await $t({fsp:p,dotgit:e});return await Ye({fs:p,cache:l,dir:t,gitdir:y,trees:n,map:i,reduce:a,iterate:c})}catch(p){throw p.caller="git.walk",p}}async function Qo({fs:r,dir:t,gitdir:e=W(t,".git"),blob:n}){try{M("fs",r),M("gitdir",e),M("blob",n);const i=new Tt(r),a=await $t({fsp:i,dotgit:e});return await $e({fs:i,gitdir:a,type:"blob",object:n,format:"content"})}catch(i){throw i.caller="git.writeBlob",i}}async function ts({fs:r,dir:t,gitdir:e=W(t,".git"),commit:n}){try{M("fs",r),M("gitdir",e),M("commit",n);const i=new Tt(r),a=await $t({fsp:i,dotgit:e});return await jo({fs:i,gitdir:a,commit:n})}catch(i){throw i.caller="git.writeCommit",i}}async function es({fs:r,dir:t,gitdir:e=W(t,".git"),type:n,object:i,format:a="parsed",oid:c,encoding:l=void 0}){try{const p=new Tt(r),y=await $t({fsp:p,dotgit:e});if(a==="parsed"){switch(n){case"commit":i=ce.from(i).toObject();break;case"tree":i=bt.from(i).toObject();break;case"blob":i=Buffer.from(i,l);break;case"tag":i=Ie.from(i).toObject();break;default:throw new Ft(c||"",n,"blob|commit|tag|tree")}a="content"}return c=await $e({fs:p,gitdir:y,type:n,object:i,oid:c,format:a}),c}catch(p){throw p.caller="git.writeObject",p}}async function rs({fs:r,dir:t,gitdir:e=W(t,".git"),ref:n,value:i,force:a=!1,symbolic:c=!1}){try{M("fs",r),M("gitdir",e),M("ref",n),M("value",i);const l=new Tt(r);if(!qr(n,!0))throw new Le(n,m.clean(n));const p=await $t({fsp:l,dotgit:e});if(!a&&await B.exists({fs:l,gitdir:p,ref:n}))throw new je("ref",n);c?await B.writeSymbolicRef({fs:l,gitdir:p,ref:n,value:i}):(i=await B.resolve({fs:l,gitdir:p,ref:i}),await B.writeRef({fs:l,gitdir:p,ref:n,value:i}))}catch(l){throw l.caller="git.writeRef",l}}async function mu({fs:r,gitdir:t,tag:e}){const n=Ie.from(e).toObject();return await $e({fs:r,gitdir:t,type:"tag",object:n,format:"content"})}async function ns({fs:r,dir:t,gitdir:e=W(t,".git"),tag:n}){try{M("fs",r),M("gitdir",e),M("tag",n);const i=new Tt(r),a=await $t({fsp:i,dotgit:e});return await mu({fs:i,gitdir:a,tag:n})}catch(i){throw i.caller="git.writeTag",i}}async function is({fs:r,dir:t,gitdir:e=W(t,".git"),tree:n}){try{M("fs",r),M("gitdir",e),M("tree",n);const i=new Tt(r),a=await $t({fsp:i,dotgit:e});return await Lr({fs:i,gitdir:a,tree:n})}catch(i){throw i.caller="git.writeTree",i}}var yu={Errors:ia,STAGE:qt,TREE:Pe,WORKDIR:mr,add:da,abortMerge:ua,addNote:ya,addRemote:va,annotatedTag:ba,branch:xa,checkout:xn,clone:Da,commit:Ua,getConfig:Ja,getConfigAll:Qa,setConfig:Mo,currentBranch:Na,deleteBranch:Ma,deleteRef:ja,deleteRemote:La,deleteTag:qa,expandOid:za,expandRef:Ga,fastForward:Wa,fetch:Xa,findMergeBase:Va,findRoot:Ka,getRemoteInfo:to,getRemoteInfo2:ro,hashBlob:no,indexPack:io,init:ao,isDescendent:so,isIgnored:co,listBranches:fo,listFiles:lo,listNotes:ho,listRefs:po,listRemotes:wo,listServerRefs:go,listTags:mo,log:vo,merge:bo,packObjects:Eo,pull:So,push:Ao,readBlob:Bo,readCommit:Tn,readNote:Io,readObject:To,readTag:Oo,readTree:$o,remove:Po,removeNote:Co,renameBranch:Fo,resetIndex:Uo,updateIndex:Yo,resolveRef:No,status:Zo,statusMatrix:Xo,tag:Vo,version:Ko,walk:Jo,writeBlob:Qo,writeCommit:ts,writeObject:es,writeRef:rs,writeTag:ns,writeTree:is,stash:Ho};return Et.Errors=ia,Et.STAGE=qt,Et.TREE=Pe,Et.WORKDIR=mr,Et.abortMerge=ua,Et.add=da,Et.addNote=ya,Et.addRemote=va,Et.annotatedTag=ba,Et.branch=xa,Et.checkout=xn,Et.clone=Da,Et.commit=Ua,Et.currentBranch=Na,Et.default=yu,Et.deleteBranch=Ma,Et.deleteRef=ja,Et.deleteRemote=La,Et.deleteTag=qa,Et.expandOid=za,Et.expandRef=Ga,Et.fastForward=Wa,Et.fetch=Xa,Et.findMergeBase=Va,Et.findRoot=Ka,Et.getConfig=Ja,Et.getConfigAll=Qa,Et.getRemoteInfo=to,Et.getRemoteInfo2=ro,Et.hashBlob=no,Et.indexPack=io,Et.init=ao,Et.isDescendent=so,Et.isIgnored=co,Et.listBranches=fo,Et.listFiles=lo,Et.listNotes=ho,Et.listRefs=po,Et.listRemotes=wo,Et.listServerRefs=go,Et.listTags=mo,Et.log=vo,Et.merge=bo,Et.packObjects=Eo,Et.pull=So,Et.push=Ao,Et.readBlob=Bo,Et.readCommit=Tn,Et.readNote=Io,Et.readObject=To,Et.readTag=Oo,Et.readTree=$o,Et.remove=Po,Et.removeNote=Co,Et.renameBranch=Fo,Et.resetIndex=Uo,Et.resolveRef=No,Et.setConfig=Mo,Et.stash=Ho,Et.status=Zo,Et.statusMatrix=Xo,Et.tag=Vo,Et.updateIndex=Yo,Et.version=Ko,Et.walk=Jo,Et.writeBlob=Qo,Et.writeCommit=ts,Et.writeObject=es,Et.writeRef=rs,Et.writeTag=ns,Et.writeTree=is,Et}export{El as g,Bl as r};
